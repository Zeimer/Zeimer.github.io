<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-88023543-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<h1 class="libtitle">R2: Indukcja i rekursja</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 W poprzednim rozdziale dowiedzieliśmy się już co nieco o typach, a
    także spotkaliśmy kilka z nich oraz kilka sposobów tworzenia nowych
    typów ze starych (takich jak np. koniunkcja; pamiętaj, że zdania są
    typami). W tym rozdziale dowiemy się o nich nieco więcej: spotkamy
    się z ich sortami oraz uniwersami, w których żyją; dowiemy się, jak
    definiować nowe typy przy pomocy indukcji oraz jak użyć rekursji do
    tworzenia funkcji, które konstruują i dekonstruują ich termy. 
<div class="paragraph"> </div>

<a name="lab62"></a><h1 class="section">Sorty</h1>

<div class="paragraph"> </div>

 Jeżeli przeczytałeś uważnie sekcję "Typy i termy" z poprzedniego
    rozdziału, zauważyłeś zapewne stwierdzenie, że typy są termami.
    W połączeniu ze stwierdzeniem, że każdy term ma swój typ, zrodzić
    musi się pytanie: jakiego typu są typy? Zacznijmy od tego, że
    żeby uniknąć używania mało poetyckiego określenia "typy typów",
    typy typów nazywamy sortami. 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, jak już wiesz, jest sortem zdań logicznych. Jeżeli
    <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> oraz <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> (tzn. <span class="inlinecode"><span class="id" title="var">A</span></span> jest sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>), to typ
    <span class="inlinecode"><span class="id" title="var">P</span></span> możemy interpretować jako zdanie logiczne, a term <span class="inlinecode"><span class="id" title="var">x</span></span>
    jako jego dowód. Na przykład <span class="inlinecode"><span class="id" title="var">I</span></span> jest dowodem zdania <span class="inlinecode"><span class="id" title="var">True</span></span>,
    tzn. <span class="inlinecode"><span class="id" title="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">True</span></span>, zaś term <span class="inlinecode">42</span> nie jest dowodem <span class="inlinecode"><span class="id" title="var">True</span></span>, gdyż
    <span class="inlinecode">42</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;True&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#I"><span class="id" title="constructor">I</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;I&nbsp;:&nbsp;True&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> 42.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;42&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
O ile jednak każde zdanie logiczne jest typem, nie każdy typ jest
    zdaniem — przykładem niech będą liczby naturalne <span class="inlinecode"><span class="id" title="var">nat</span></span>. Sortem <span class="inlinecode"><span class="id" title="var">nat</span></span>
    jest <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Niech nie zmyli cię ta nazwa: <span class="inlinecode"><span class="id" title="keyword">Set</span></span> nie ma nic wspólnego
    ze zbiorami znanymi choćby z teorii zbiorów ZF.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">Set</span></span> jest sortem, w którym żyją specyfikacje. Jeżeli <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span> (tzn. sortem <span class="inlinecode"><span class="id" title="var">A</span></span> jest <span class="inlinecode"><span class="id" title="keyword">Set</span></span>), to <span class="inlinecode"><span class="id" title="var">A</span></span> możemy interpretować
    jako specyfikację pewnej klasy programów, a term <span class="inlinecode"><span class="id" title="var">x</span></span> jako program,
    który tę specyfikację spełnia (implementuje). Na przykład <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span>
    jest programem, ktory spełnia specyfikację <span class="inlinecode"><span class="id" title="var">nat</span></span>, tzn. <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    zaś <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> nie spełnia specyfikacji <span class="inlinecode"><span class="id" title="var">nat</span></span>, gdyż
    <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nat&nbsp;:&nbsp;Set&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 2.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;2&nbsp;+&nbsp;2&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="comment">(*&nbsp;fun&nbsp;n&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;n&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Oczywiście w przypadku typu <span class="inlinecode"><span class="id" title="var">nat</span></span> mówiene o specyfikacji jest trochę
    na wyrost, gdyż określenie "specyfikacja" kojarzy nam się z czymś,
    co określa właściwości, jakie powinien mieć spełniający ją program.
    O takich specyfikacjach dowiemy się więcej w kolejnych rozdziałach.
    Choć każda specyfikacja jest typem, to rzecz jasna nie każdy typ jest
    specyfikacją — niektóre typy są przecież zdaniami. 
<div class="paragraph"> </div>

<a name="lab63"></a><h1 class="section">Hierarchia uniwersów</h1>

<div class="paragraph"> </div>

 Uwaga: ta sekcja jest czysto teoretyczna. Jeżeli boisz
    się uprawiania teorii dla samej teorii, możesz ją pominąć.

<div class="paragraph"> </div>

    Jeżeli czytasz uważnie, to pewnie wciąż czujesz niedosyt — wszakże
    sorty, jako typy, także są termami. Jakie są więc typy/sorty sortów?
    Przekonajmy się. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Prop</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;:&nbsp;Type&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Set</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Set&nbsp;:&nbsp;Type&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">Prop</span></span> oraz <span class="inlinecode"><span class="id" title="keyword">Set</span></span> są typu/sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, który bywa też nazywany
    uniwersum. To stwierdzenie wciąż jednak pewnie nie zaspakaja twojej
    ciekawości. Pójdźmy więc po nitce do kłębka. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Type&nbsp;:&nbsp;Type&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Zdaje się, że osiągnęliśmy kłębek i że <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest typu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.
    Rzeczywistość jest jednak o wiele ciekawsza. Gdyby rzeczywiście
    zachodziło <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, doszłoby do paradoksu znanego jako
    paradoks Girarda (którego omówienie jednak pominiemy). Prawda
    jest inna. 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Set&nbsp;Printing&nbsp;Universes.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Uwaga: powyższa komenda zadziała jedynie w konsoli (program coqtop).
    Aby osiągnąć ten sam efekt w CoqIDE, zaznacz opcję
    View &gt; Display universe levels. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Type&nbsp;<span class="comment">(*&nbsp;Top.7&nbsp;*)</span>&nbsp;:&nbsp;Type&nbsp;<span class="comment">(*&nbsp;(Top.7)+1&nbsp;*)</span>&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Co oznacza ten dziwny napis? Otóż w Coqu mamy do czynienia nie z
    jednym, ale z wieloma (a nawet nieskończenie wieloma) uniwersami.
    Uniwersa te są numerowane liczbami naturalnymi: najniższe uniwersum
    ma numer 0, a każde kolejne o jeden większy. Wobec tego hierarchia
    uniwersów wygląda tak (użyta notacja nie jest tą, której używa Coq;
    została wymyślona ad hoc):
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="keyword">Set</span></span> jest typu/sortu <span class="inlinecode"><span class="id" title="keyword">Type</span>(0)</span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">Type</span>(0)</span> jest typu/sortu <span class="inlinecode"><span class="id" title="keyword">Type</span>(1)</span>

</li>
<li> w ogólności, <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">i</span>)</span> jest typu/sortu <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">i</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> 
</li>
</ul>

<div class="paragraph"> </div>

 Aby uniknąć paradoksu, definicje odnoszące się do typów żyjących
    na różnych poziomach hierarchii muszą same bytować w uniwersum
    na poziomie wyższym niż każdy z tych, do których się odwołują.
    Aby to zapewnić, Coq musi pamiętać, na którym poziomie znajduje
    każde użycie <span class="inlinecode"><span class="id" title="keyword">Type</span></span> i odpowiednio dopasowywać poziom hierarchii,
    do którego wrzucone zostaną nowe definicje.

<div class="paragraph"> </div>

    Co więcej, w poprzednim rozdziale dopuściłem się drobnego kłamstewka
    twierdząc, że każdy term ma dokładnie jeden typ. W pewnym sensie nie
    jest tak, gdyż powyższa hierarcha jest <i>kumulatywna</i> — znaczy to, że
    jeśli <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">i</span>)</span>, to także <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>(<span class="id" title="var">j</span>)</span> dla i &lt; j. Tak więc każdy
    typ, którego sortem jest <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, nie tylko nie ma unikalnego typu/sortu,
    ale ma ich nieskończenie wiele.

<div class="paragraph"> </div>

    Brawo! Czytając tę sekcję, dotarłeś do króliczej nory i posiadłeś
    wiedzę tajemną, której prawie na pewno nigdy ani nigdzie nie użyjesz.
    Możemy zatem przejść do meritum. 
<div class="paragraph"> </div>

<a name="lab64"></a><h1 class="section">Typy induktywne</h1>

<div class="paragraph"> </div>

 W Coqu są trzy główne rodzaje typów: produkt zależny, typy induktywne
    i typy koinduktywne. Z pierwszym z nich już się zetknęliśmy, drugi
    poznamy w tym rozdziale, trzeci na razie pominiemy.

<div class="paragraph"> </div>

    Typ induktywny definiuje się przy pomocy zbioru konstruktorów, które
    służą, jak sama nazwa wskazuje, do budowania termów tego typu.
    Konstruktory te są funkcjami (być może zależnymi), których
    przeciwdziedziną jest definiowany typ, ale niczego nie
    obliczają — nadają jedynie termom ich "kształt". W szczególności, nie
    mają nic wspólnego z konstruktorami w takich językach jak C++ lub Java
    — nie mogą przetwarzać swoich argumentów, alokować pamięci, dokonywać
    operacji wejścia/wyjścia etc.

<div class="paragraph"> </div>

    Tym, co jest ważne w przypadku konstruktorów, jest ich ilość, nazwy
    oraz ilość i typy przyjmowanych argumentów. To te cztery rzeczy decydują
    o tym, jakie "kształty" będą miały termy danego typu, a więc i czym
    będzie sam typ. W ogolności każdy term jest skończonym, ukorzenionym
    drzewem, którego kształt zależy od charakterystyki konstruktorów tak:
<ul class="doclist">
<li> każdy konstruktor to inny rodzaj węzła (nazwa konstruktora to nazwa
      węzła)

</li>
<li> konstruktory nierekurencyjne to liście, a rekurencyjne — węzły
      wewnętrzne

</li>
<li> argumenty konstruktorów to dane przechowywane w danym węźle 
</li>
</ul>

<div class="paragraph"> </div>

 Typ induktywny można wyobrażać sobie jako przestrzeń zawierającą
    te i tylko te drzewa, które można zrobić przy pomocy jego
    konstruktorów. Nie przejmuj się, jeżeli opis ten wydaje ci się
    dziwny — sposób definiowania typów induktywnych i ich wartości
    w Coqu jest diametralnie różny od sposobu definiowania klas i
    obiektów w językach imperatywnych i wymaga przyzwyczajenia się
    do niego. Zobaczmy, jak powyższy opis ma się do konkretnych
    przykładów. 
<div class="paragraph"> </div>

<a name="lab65"></a><h2 class="section">Enumeracje</h2>

<div class="paragraph"> </div>

 Najprostszym rodzajem typów induktywnych są enumeracje, czyli typy,
    których wszystkie konstruktory są stałymi. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="bool"><span class="id" title="inductive">bool</span></a> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="true"><span class="id" title="constructor">true</span></a> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="false"><span class="id" title="constructor">false</span></a> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>

<br/>
</div>

<div class="doc">
Definicja typu induktywnego ma następującą postać: najpierw występuje
    słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, następnie nazwa typu, a po dwukropku sort
    (<span class="inlinecode"><span class="id" title="keyword">Set</span></span>, <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> lub <span class="inlinecode"><span class="id" title="keyword">Type</span></span>). Następnie wymieniamy konstruktory typu —
    dla czytelności każdy w osobnej linii. Mają one swoje unikalne nazwy i
    są funkcjami, których przeciwdziedziną jest definiowany typ. W naszym
    przypadku mamy 2 konstruktory, zwane <span class="inlinecode"><span class="id" title="var">true</span></span> oraz <span class="inlinecode"><span class="id" title="var">false</span></span>, które są
    funkcjami zeroargumentowymi.

<div class="paragraph"> </div>

    Definicję tę możemy udczytać następująco: "<span class="inlinecode"><span class="id" title="var">true</span></span> jest typu <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    <span class="inlinecode"><span class="id" title="var">false</span></span> jest typu <span class="inlinecode"><span class="id" title="var">bool</span></span> i nie ma żadnych więcej wartości typu
    <span class="inlinecode"><span class="id" title="var">bool</span></span>".

<div class="paragraph"> </div>

    Uwaga: należy odróżnić symbole <span class="inlinecode">:=</span> oraz <span class="inlinecode">=</span>. Pierwszy z nich służy
    do definiowania, a drugi do zapisywania równości.

<div class="paragraph"> </div>

    Zapis <span class="inlinecode"><span class="id" title="var">name</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">term</span></span> oznacza "niech od teraz <span class="inlinecode"><span class="id" title="var">name</span></span> będzie inną nazwą
    dla <span class="inlinecode"><span class="id" title="var">term</span></span>". Jest to komenda, a nie zdanie logiczne. Od teraz jeżeli
    natkniemy się na nazwę <span class="inlinecode"><span class="id" title="var">name</span></span>, będziemy mogli odwinąć jej definicję i
    wstawić w jej miejsce <span class="inlinecode"><span class="id" title="var">term</span></span>. Przykład: <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> <span class="inlinecode"><span class="id" title="var">five</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">5</span>.
    Antyprzykład: <span class="inlinecode">2</span> <span class="inlinecode">:=</span> <span class="inlinecode">5</span> (błąd składni).

<div class="paragraph"> </div>

    Zapis <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> oznacza "<span class="inlinecode"><span class="id" title="var">a</span></span> jest równe <span class="inlinecode"><span class="id" title="var">b</span></span>". Jest to zdanie logiczne,
    a nie komenda. Zdanie to rzecz jasna nie musi być prawdziwe. Przykład:
    <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">5</span>. Antyprzykład: <span class="inlinecode"><span class="id" title="var">five</span></span> <span class="inlinecode">=</span> <span class="inlinecode">5</span> (jeżeli <span class="inlinecode"><span class="id" title="var">five</span></span> nie jest zdefiniowane,
    to dostajemy komunikat w stylu "nie znaleziono nazwy <span class="inlinecode"><span class="id" title="var">five</span></span>"). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="negb"><span class="id" title="definition">negb</span></a> (<span class="id" title="var">b</span> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="R2.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a> =&gt; <a class="idref" href="R2.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="R2.html#false"><span class="id" title="constructor">false</span></a> =&gt; <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja funkcji wygląda tak: najpierw mamy słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>
    (jeżeli funkcja nie jest rekurencyjna), następnie argumenty funkcji
    w postaci <span class="inlinecode">(<span class="id" title="var">name</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">type</span>)</span>; po dwukropku przeciwdziedzina, a po symbolu
    <span class="inlinecode">:=</span> ciało funkcji.

<div class="paragraph"> </div>

    Podstawowym narzędziem służącym do definiowania funkcji jest
    "dopasowywanie do wzorca" (ang. pattern matching; w dalszej części
    będę używał nazwy angielskiej). Pozwala ono sprawdzić, którego
    konstruktora użyto do zrobienia dopasowywanej wartości. Podobnym
    tworem występującym w językach imperatywnych jest instrukcja
    switch, ale pattern matching jest od niej dużo potężniejszy.

<div class="paragraph"> </div>

    Nasza funkcja działa następująco: sprawdzamy, którym konstruktorem
    zrobiono argument <span class="inlinecode"><span class="id" title="var">b</span></span> — jeżeli było to <span class="inlinecode"><span class="id" title="var">true</span></span>, zwracamy <span class="inlinecode"><span class="id" title="var">false</span></span>, a
    gdy było to <span class="inlinecode"><span class="id" title="var">false</span></span>, zwracamy <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

<a name="lab66"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcje <span class="inlinecode"><span class="id" title="var">andb</span></span> (koniunkcja boolowska) i <span class="inlinecode"><span class="id" title="var">orb</span></span> (alternatywa
    boolowska). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Zanim odpalimy naszą funkcję, powinniśmy zadać sobie pytanie: w jaki
    sposób programy są wykonywane? W celu lepszego zrozumienia tego
    zagadnienia porównamy ewaluację programów napisanych w językach
    imperatywnych oraz funkcyjnych.

<div class="paragraph"> </div>

    Rozważmy bardzo uproszczony model: interpreter wykonuje program,
    który nie dokonuje operacji wejścia/wyjścia, napisany w jakimś
    języku imperatywnym. W tej sytuacji działanie interpretera
    sprowadza się do tego, że czyta on kod programu instrukcja po
    instrukcji, a następnie w zależności od przeczytanej instrukcji
    odpowiednio zmienia swój stan.

<div class="paragraph"> </div>

    W języku czysto funkcyjnym taki model ewaluacji jest niemożliwy,
    gdyż nie dysponujemy globalnym stanem. Zamiast tego, w Coqu
    wykonanie programu polega na jego redukcji. O co chodzi?
    Przypomnijmy najpierw, że program to term, którego typem jest
    specyfikacja, czyli typ sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Termy mogą być redukowane,
    czyli zamieniane na równoważne, ale prostsze, przy użyciu
    reguł redukcji. Prześledźmy wykonanie programu <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>
    krok po kroku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="keyword">in</span> <a class="idref" href="R2.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;(fun&nbsp;b&nbsp;:&nbsp;bool&nbsp;=&gt;&nbsp;match&nbsp;b&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;=&gt;&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja delta odwija definicje. Żeby użyć jakiejś redukcji, używamy
    komendy <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> <span class="inlinecode"><span class="id" title="var">redukcje</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">term</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">in</span> <a class="idref" href="R2.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;match&nbsp;true&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;=&gt;&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;=&gt;&nbsp;true<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja beta podstawia argument do funkcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">iota</span> <span class="id" title="keyword">in</span> <a class="idref" href="R2.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="comment">(*&nbsp;===&nbsp;=&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Redukcja jota dopasowuje term do wzorca i zamienia go na term
    znajdujący się po prawej stronie <span class="inlinecode">=&gt;</span> dla dopasowanego przypadku. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">cbv</span> <span class="id" title="keyword">in</span> <a class="idref" href="R2.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Żeby zredukować term za jednym zamachem, możemy pominąć nazwy
    redukcji występujące po <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> — w taki wypadku zostaną zaaplikowane
    wszystkie możliwe redukcje, czyli program zostanie wykonany. Do
    jego wykonania możemy też użyć komend <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> oraz <span class="inlinecode"><span class="id" title="keyword">Eval</span></span>
    <span class="inlinecode"><span class="id" title="tactic">compute</span></span> (a od wersji Coqa 8.5 także <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="var">cbn</span></span>). 
<div class="paragraph"> </div>

<a name="lab67"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zredukuj "ręcznie" programy <span class="inlinecode"><span class="id" title="var">andb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> oraz <span class="inlinecode"><span class="id" title="var">orb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

 Jak widać, wykonanie programu w Coqu jest dość toporne. Wynika to
    z faktu, że Coq nie został stworzony do wykonywania programów, a
    jedynie do ich definiowania i dowodzenia ich poprawności. Aby użyć
    programu napisanego w Coqu w świecie rzeczywistym, stosuje się
    zazwyczaj mechanizm ekstrakcji, który pozwala z programu napisanego
    w Coqu atuomatycznie uzyskać program w Scheme, OCamlu lub Haskellu,
    które są od Coqa dużo szybsze i dużo powszechniej używane. My jednak
    nie będziemy się tym przejmować. 

<div class="paragraph"> </div>

    Zdefiniowawszy naszą funkcję, możemy zadać sobie pytanie:
    czy definicja jest poprawna? Gdybyśmy pisali w jednym z
    języków imperatywnych, moglibyśmy napisać dla niej testy
    jednostkowe, polegające np. na tym, że generujemy losowo
    wejście funkcji i sprawdzamy, czy wynik posiada żądaną przez
    nas właściwość. Coq umożliwia nam coś dużo silniejszego:
    możemy wyrazić przy pomocy twierdzenia, że funkcja posiada
    interesującą nas własność, a następnie spróbować je udowodnić.
    Jeżeli nam się powiedzie, mamy całkowitą pewność, że funkcja
    rzeczywiście posiada żądaną własność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="negb_involutive"><span class="id" title="lemma">negb_involutive</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>, <a class="idref" href="R2.html#negb"><span class="id" title="definition">negb</span></a> (<a class="idref" href="R2.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="R2.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Nasze twierdzenie głosi, że funkcja <span class="inlinecode"><span class="id" title="var">negb</span></span> jest inwolucją,
    tzn. że dwukrotne jej zaaplikowanie do danego argumentu
    nie zmienia go, lub też, innymi słowy, że <span class="inlinecode"><span class="id" title="var">negb</span></span> jest
    swoją własną odwrotnością.

<div class="paragraph"> </div>

    Dowód przebiega w następujący sposób: taktyką <span class="inlinecode"><span class="id" title="tactic">intro</span></span>
    wprowadzamy zmienną <span class="inlinecode"><span class="id" title="var">b</span></span> do kontekstu, a następnie
    używamy taktyki <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, aby sprawdzić, którym
    konstruktorem została zrobiona. Ponieważ typ <span class="inlinecode"><span class="id" title="var">bool</span></span> ma
    dwa konstruktory, taktyka ta generuje nam dwa podcele:
    musimy udowodnić twierdzenie osobno dla przypadku, gdy
    <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> oraz dla <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span>. Potem przy pomocy
    taktyki <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> redukujemy (czyli wykonujemy) programy
    <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span>)</span> i <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">false</span>)</span>. zauważ, że
    byłoby to niemożliwe, gdyby argument był postaci <span class="inlinecode"><span class="id" title="var">b</span></span>
    (nie można wtedy zaaplikować żadnej redukcji), ale jest
    jak najbardziej możliwe, gdy jest on postaci <span class="inlinecode"><span class="id" title="var">true</span></span> albo
    <span class="inlinecode"><span class="id" title="var">false</span></span> (wtedy redukcja przebiega jak w przykładzie). Na
    koniec używamy taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, która potrafi udowodnić
    cel postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> jest taktykowym odpowiednikiem pattern matchingu
    i bardzo często jest używany, gdy mamy do czynienia z czymś,
    co zostało za jego pomocą zdefiniowane.

<div class="paragraph"> </div>

    Być może poczułeś dyskomfort spowodowany tym, że cel postaci
    <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> można udowodnić dwoma różnymi taktykami (<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>
    oraz <span class="inlinecode"><span class="id" title="tactic">trivial</span></span>) albo że termy można redukować na cztery różne
    sposoby (<span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">cbv</span></span>, <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="var">cbn</span></span>).
    Niestety, będziesz musiał się do tego przyzwyczaić — język
    taktyka Coqa jest strasznie zabałaganiony i niesie ze sobą
    spory bagaż swej mrocznej przeszłości. Na szczęście od niedawna
    trwają prace nad jego ucywilizowaniem, czego pierwsze efekty
    widać już od wersji 8.5. W chwilach desperacji uratować może
    cię jedynie dokumentacja:
<ul class="doclist">
<li> https://coq.inria.fr/refman/tactic-index.html

</li>
<li> https://coq.inria.fr/refman/Reference-Manual010.html 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="negb_involutive'"><span class="id" title="lemma">negb_involutive'</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>, <a class="idref" href="R2.html#negb"><span class="id" title="definition">negb</span></a> (<a class="idref" href="R2.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="R2.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Zauważmy, że nie musimy używać taktyki <span class="inlinecode"><span class="id" title="tactic">intro</span></span>, żeby wprowadzić
    <span class="inlinecode"><span class="id" title="var">b</span></span> do kontekstu: taktyka <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> sama jest w stanie wykryć,
    że nie ma go w kontekście i wprowadzić je tam przed rozbiciem
    go na konstruktory. Zauważmy też, że oba podcele rozwiązaliśmy
    w ten sam sposób, więc możemy użyć kombinatora <span class="inlinecode">;</span> (średnika),
    żeby rozwiązać je oba za jednym zamachem. 
<div class="paragraph"> </div>

<a name="lab68"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="andb_assoc"><span class="id" title="lemma">andb_assoc</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="R2.html#b1"><span class="id" title="variable">b1</span></a> (<a class="idref" href="R2.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="R2.html#b2"><span class="id" title="variable">b2</span></a> <a class="idref" href="R2.html#b3"><span class="id" title="variable">b3</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#andb"><span class="id" title="definition">andb</span></a> (<a class="idref" href="R2.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="R2.html#b1"><span class="id" title="variable">b1</span></a> <a class="idref" href="R2.html#b2"><span class="id" title="variable">b2</span></a>) <a class="idref" href="R2.html#b3"><span class="id" title="variable">b3</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="andb_comm"><span class="id" title="lemma">andb_comm</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="R2.html#b1"><span class="id" title="variable">b1</span></a> <a class="idref" href="R2.html#b2"><span class="id" title="variable">b2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#andb"><span class="id" title="definition">andb</span></a> <a class="idref" href="R2.html#b2"><span class="id" title="variable">b2</span></a> <a class="idref" href="R2.html#b1"><span class="id" title="variable">b1</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="orb_assoc"><span class="id" title="lemma">orb_assoc</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> <span class="id" title="var">b3</span> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#orb"><span class="id" title="definition">orb</span></a> <a class="idref" href="R2.html#b1"><span class="id" title="variable">b1</span></a> (<a class="idref" href="R2.html#orb"><span class="id" title="definition">orb</span></a> <a class="idref" href="R2.html#b2"><span class="id" title="variable">b2</span></a> <a class="idref" href="R2.html#b3"><span class="id" title="variable">b3</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#orb"><span class="id" title="definition">orb</span></a> (<a class="idref" href="R2.html#orb"><span class="id" title="definition">orb</span></a> <a class="idref" href="R2.html#b1"><span class="id" title="variable">b1</span></a> <a class="idref" href="R2.html#b2"><span class="id" title="variable">b2</span></a>) <a class="idref" href="R2.html#b3"><span class="id" title="variable">b3</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="orb_comm"><span class="id" title="lemma">orb_comm</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#orb"><span class="id" title="definition">orb</span></a> <a class="idref" href="R2.html#b1"><span class="id" title="variable">b1</span></a> <a class="idref" href="R2.html#b2"><span class="id" title="variable">b2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#orb"><span class="id" title="definition">orb</span></a> <a class="idref" href="R2.html#b2"><span class="id" title="variable">b2</span></a> <a class="idref" href="R2.html#b1"><span class="id" title="variable">b1</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab69"></a><h2 class="section">Konstruktory rekurencyjne</h2>

<div class="paragraph"> </div>

 Powiedzieliśmy, że termy typów induktywnych są drzewami. W przypadku
    enumeracji jest to słabo widoczne, gdyż drzewa te są zdegenerowane —
    są to po prostu punkciki oznaczone nazwami konstruktorów. Efekt
    rozgałęzienia możemy uzyskać, gdy jeden z konstruktorów będzie
    rekurencyjny, tzn. gdy jako argument będzie przyjmował term typu,
    który właśnie definiujemy. Naszym przykładem będą liczby naturalne
    (choć i tutaj rozgałęzienie będzie nieco zdegenerowane ­- każdy term
    będzie mógł mieć co najwyżej jedno). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="NatDef"><span class="id" title="module">NatDef</span></a>.<br/>

<br/>
</div>

<div class="doc">
Mechanizm modułów jest podobny do mechanizmu sekcji i na razie nie
    będzie nas interesował — użyjemy go, żeby nie zaśmiecać głównej
    przestrzeni nazw (mechanizm sekcji w tym przypadku by nie pomógł). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="NatDef.nat"><span class="id" title="inductive">nat</span></a> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="NatDef.O"><span class="id" title="constructor">O</span></a> : <a class="idref" href="R2.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="NatDef.S"><span class="id" title="constructor">S</span></a> : <a class="idref" href="R2.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="516fcd3cd824628d1bdea91d0094a65f"><span class="id" title="notation">&quot;</span></a>0" := <a class="idref" href="R2.html#NatDef.O"><span class="id" title="constructor">O</span></a>.<br/>

<br/>
</div>

<div class="doc">
Uwaga: nazwa pierwszego konstruktora to duża litera O, a nie cyfra 0
    — cyfry nie mogą być nazwami. Żeby obejść tę niedogodność, musimy
    posłużyć się mechanizmem notacji — dzięki temu będziemy mogli pisać
    0 zamiast O.

<div class="paragraph"> </div>

    Definicję tę możemy odczytać w następujący sposób: "<span class="inlinecode">0</span> jest liczbą
    naturalną; jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest liczbą naturalną, to <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> również jest
    liczbą naturalną". Konstruktor <span class="inlinecode"><span class="id" title="var">S</span></span> odpowiada tutaj dodawaniu jedynki:
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span> to 1, <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span> to 2, <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0))</span> to 3 i tak dalej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<a class="idref" href="R2.html#NatDef.S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="R2.html#NatDef.S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="R2.html#NatDef.S"><span class="id" title="constructor">S</span></a> 0))).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;S&nbsp;(S&nbsp;(S&nbsp;0))&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#NatDef"><span class="id" title="module">NatDef</span></a>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> 0)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;3&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Ręczne liczenie ilości <span class="inlinecode"><span class="id" title="var">S</span></span> w każdej liczbie szybko staje się trudne
    nawet dla małych liczb. Na szczęście standardowa biblioteka Coqa
    udostępnia notacje, które pozwalają nam zapisywać liczby naturalne
    przy pomocy dobrze znanych nam cyfr arabskich. Żeby uzyskać do nich
    dostęp, musimy opuścić zdefiniowany przez nas moduł <span class="inlinecode"><span class="id" title="var">NatDef</span></span>, żeby
    nasza definicja <span class="inlinecode"><span class="id" title="var">nat</span></span> nie przysłaniała tej bibliotecznej. Zaczniemy
    za to nowy moduł, żebyśmy mogli swobodnie zredefiniować działania
    na liczbach naturalnych z biblioteki standardowej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="NatOps"><span class="id" title="module">NatOps</span></a>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="NatOps.plus"><span class="id" title="definition">plus</span></a> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="R2.html#plus"><span class="id" title="definition">plus</span></a> <span class="id" title="var">n'</span> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
W zapisie unarnym liczby naturalne możemy wyobrażać sobie jako kupki
    <span class="inlinecode"><span class="id" title="var">S</span></span>-ów, więc dodawanie dwóch liczb sprowadza się do przerzucenia <span class="inlinecode"><span class="id" title="var">S</span></span>-ów
    z jednej kupki na drugą.

<div class="paragraph"> </div>

    Definiowanie funkcji dla typów z konstruktorami rekurencyjnymi
    wygląda podobnie jak dla enumeracji, ale występują drobne różnice:
    jeżeli będziemy używać rekurencji, musimy zaznaczyć to za pomocą
    słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> (zamiast wcześniejszego <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>).
    Zauważmy też, że jeżeli funkcja ma wiele argumentów tego samego typu,
    możemy napisać <span class="inlinecode">(<span class="id" title="var">arg1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">argN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">type</span>)</span> zamiast dłuższego <span class="inlinecode">(<span class="id" title="var">arg1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">type</span>)</span>
    <span class="inlinecode">...</span> <span class="inlinecode">(<span class="id" title="var">argN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">type</span>)</span>.

<div class="paragraph"> </div>

    Jeżeli konstruktor typu induktywnego bierze jakieś argumenty, to wzorce,
    które go dopasowują, stają się nieco bardziej skomplikowane: poza nazwą
    konstruktora muszą też dopasowywać argumenty — w naszym przypadku używamy
    zmiennej o nazwie <span class="inlinecode"><span class="id" title="var">n'</span></span>, która istnieje tylko lokalnie (tylko we wzorcu
    dopasowania oraz po prawej stronie strzałki <span class="inlinecode">=&gt;</span>).

<div class="paragraph"> </div>

    Naszą funkcję zdefiniowaliśmy przy pomocy najbardziej elementarnego
    rodzaju rekursji, jaki jest dostępny w Coqu: rekursji strukturalnej.
    W przypadku takiej rekursji wywołania rekurencyjne mogą odbywać się
    jedynie na termach strukturalnie mniejszych, niż obecny argument
    główny rekurencji. W naszym przypadku argumentem głównym jest <span class="inlinecode"><span class="id" title="var">n</span></span>
    (bo on jest dopasowywany), zaś rekurencyjnych wywołań dokonujemy na
    <span class="inlinecode"><span class="id" title="var">n'</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>. <span class="inlinecode"><span class="id" title="var">n'</span></span> jest strukturalnie mniejszy od <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>,
    gdyż składa się z jednego <span class="inlinecode"><span class="id" title="var">S</span></span> mniej. Jeżeli wyobrazimy sobie nasze
    liczby jako kupki <span class="inlinecode"><span class="id" title="var">S</span></span>-ów, to wywołania rekurencyjne możemy robić
    jedynie po zdjęciu z kupki co najmniej jednego <span class="inlinecode"><span class="id" title="var">S</span></span>. 
<div class="paragraph"> </div>

<a name="lab70"></a><h4 class="section">Ćwiczenie.</h4>
 Wymyśl funkcję z liczb naturalnych w liczby naturalne,
    która jest rekurencyjna, ale nie jest strukturalnie rekurencyjna. 
<div class="paragraph"> </div>

 Podobnie jak w przypadku funkcji <span class="inlinecode"><span class="id" title="var">negb</span></span>, tak i tym razem w celu
    sprawdzenia poprawności naszej definicji spróbujemy udowodnić, że
    posiada ona właściwości, których się spodziewamy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.plus_O_n"><span class="id" title="lemma">plus_O_n</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.plus"><span class="id" title="definition">plus</span></a> 0 <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Tak prosty dowód nie powinien nas dziwić — wszakże twierdzenie to
    wynika wprost z definicji (spróbuj zredukować "ręcznie" wyrażenie
    <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.plus_n_O_try1"><span class="id" title="lemma">plus_n_O_try1</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.plus"><span class="id" title="definition">plus</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">f_equal</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Tym razem nie jest już tak prosto — <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> nie wynika z definicji
    przez prostą redukcję, gdyż argumentem głównym funkcji <span class="inlinecode"><span class="id" title="var">plus</span></span> jest
    jej pierwszy argument, czyli <span class="inlinecode"><span class="id" title="var">n</span></span>. Żeby móc zredukować to wyrażenie,
    musimy rozbić <span class="inlinecode"><span class="id" title="var">n</span></span>. Pokazanie, że <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> jest trywialne, ale
    drugi przypadek jest już beznadziejny. Ponieważ funkcje zachowują
    równość (czyli <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> implikuje <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>), to aby pokazać, że
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>, wystarczyć pokazać, że <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> — w ten właśnie sposób
    działa taktyka <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span>. Nie pomogła nam ona jednak — po jej
    użyciu mamy do pokazania to samo, co na początku, czyli <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.plus_n_O"><span class="id" title="lemma">plus_n_O</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.plus"><span class="id" title="definition">plus</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Do udowodnienia tego twierdzenia musimy posłużyć się indukcją.
    Indukcja jest sposobem dowodzenia właściwości typów induktywnych
    i funkcji rekurencyjnych, który działa mniej więcej tak: żeby
    udowodnić, że każdy term typu <span class="inlinecode"><span class="id" title="var">A</span></span> posiada własność <span class="inlinecode"><span class="id" title="var">P</span></span>, pokazujemy
    najpierw, że konstruktory nierekurencyjne posiadają tę własność
    dla dowolnych argumentów, a następnie, że konstruktory rekurencyjne
    zachowują tę własność.

<div class="paragraph"> </div>

    W przypadku liczb naturalnych indukcja wygląda tak: żeby pokazać,
    że każda liczba naturalna ma własność <span class="inlinecode"><span class="id" title="var">P</span></span>, najpierw należy
    pokazać, że zachodzi <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">0</span>, a następnie, że jeżeli zachodzi <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>,
    to zachodzi także <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>. Z tych dwóch reguł możemy zbudować
    dowód na to, że <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> zachodzi dla dowolnego <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Ten sposób rozumowania możemy zrealizować w Coqu przy pomocy
    taktyki <span class="inlinecode"><span class="id" title="tactic">induction</span></span>. Działa ona podobnie do <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, czyli
    rozbija podany term na konstruktory, ale w przypadku konstruktorów
    rekurencyjnych robi coś jeszcze — daje nam założenie indukcyjne,
    które mówi, że dowodzone przez nas twierdzenie zachodzi dla
    rekurencyjnych argumentów konstruktora. Właśnie tego było nam
    trzeba: założenie indukcyjne pozwala nam dokończyć dowód. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.plus_comm"><span class="id" title="lemma">plus_comm</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.plus"><span class="id" title="definition">plus</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#NatOps.plus"><span class="id" title="definition">plus</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="R2.html#NatOps.plus_n_O"><span class="id" title="lemma">plus_n_O</span></a>. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="R2.html#NatOps.plus_n_O"><span class="id" title="lemma">plus_n_O</span></a>. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn'</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHm'</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pojedyncza indukcja nie zawsze wystarcza, co obrazuje powyższy przypadek.
    Zauważmy, że przed użyciem <span class="inlinecode"><span class="id" title="tactic">induction</span></span> nie musimy wprowadzać zmiennych
    do kontekstu — taktyka ta robi to sama, podobnie jak <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>.
    Również podobnie jak <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, możemy przekazać jej wzorzec, którym
    nadajemy nazwy argumentom konstruktorów, na które rozbijany jest term.

<div class="paragraph"> </div>

    W ogólności wzorzec ma postać <span class="inlinecode">[<span class="id" title="var">a11</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">a1n</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">am1</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">amk</span>]</span>. Pionowa
    kreska oddziela argumenty poszczególnych konstruktorów: <span class="inlinecode"><span class="id" title="var">a11</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">a1n</span></span>
    to argumenty pierwszego konstruktora, zaś <span class="inlinecode"><span class="id" title="var">am1</span></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">amk</span></span> to argumenty
    m-tego konstruktora. <span class="inlinecode"><span class="id" title="var">nat</span></span> ma dwa konstruktory, z czego pierwszy nie
    bierze argumentów, a drugi bierze jeden, więc nasz wzorzec ma postać
    <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" title="var">n'</span>]</span>. Dzięki temu nie musimy polegać na domyślnych nazwach nadawanych
    argumentom przez Coqa, które często wprowadzają zamęt.

<div class="paragraph"> </div>

    Jeżeli damy taktyce <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> nazwę hipotezy lub twierdzenia, którego
    konkluzją jest <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>, to zamienia ona w obecnym podcelu wszystkie
    wystąpienia <span class="inlinecode"><span class="id" title="var">a</span></span> na <span class="inlinecode"><span class="id" title="var">b</span></span> oraz generuje tyle podcelów, ile przesłanek ma
    użyta hipoteza lub twierdzenie. W naszym przypadku użyliśmy udowodnionego
    uprzednio twierdzenia <span class="inlinecode"><span class="id" title="var">plus_n_O</span></span>, które nie ma przesłanek, czego efektem
    było po prostu przepisanie <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">0</span> na <span class="inlinecode"><span class="id" title="var">m</span></span>.

<div class="paragraph"> </div>

    Przepisywać możemy też w drugą stronę pisząc <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">&lt;-</span>. Wtedy jeżeli
    konkluzją danego <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> twierdzenia lub hipotezy jest <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>, to
    w celu wszystkie <span class="inlinecode"><span class="id" title="var">b</span></span> zostaną zastąpione przez <span class="inlinecode"><span class="id" title="var">a</span></span>. 
<div class="paragraph"> </div>

<a name="lab71"></a><h4 class="section">Ćwiczenie. Zdefiniuj mnożenie i udowodnij jego właściwości.</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.mult_0_l"><span class="id" title="lemma">mult_0_l</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.mult"><span class="id" title="definition">mult</span></a> 0 <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.mult_0_r"><span class="id" title="lemma">mult_0_r</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.mult"><span class="id" title="definition">mult</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.mult_1_l"><span class="id" title="lemma">mult_1_l</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.mult"><span class="id" title="definition">mult</span></a> 1 <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.mult_1_r"><span class="id" title="lemma">mult_1_r</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.mult"><span class="id" title="definition">mult</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
</div>

<div class="doc">
Jeżeli ćwiczenie było za proste i czytałeś podrozdział o kombinatorach
    taktyk, to spróbuj udowodnić:
<ul class="doclist">
<li> dwa pierwsze twierdzenia używając nie więcej niż 2 taktyk

</li>
<li> trzecie bez użycia indukcji, używając nie więcej niż 4 taktyk

</li>
<li> czwarte używając nie więcej niż 4 taktyk 
</li>
</ul>

<div class="paragraph"> </div>

 Wszystkie dowody powinny być nie dłuższe niż pół linijki. 
<div class="paragraph"> </div>

<a name="lab72"></a><h4 class="section">Ćwiczenie.</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="NatOps.plus'"><span class="id" title="definition">plus'</span></a> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">m'</span> =&gt; <a class="idref" href="R2.html#plus'"><span class="id" title="definition">plus'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="var">m'</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.plus'_n_0"><span class="id" title="lemma">plus'_n_0</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.plus'_S"><span class="id" title="lemma">plus'_S</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.plus'"><span class="id" title="definition">plus'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>) <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="R2.html#NatOps.plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.plus'_0_n"><span class="id" title="lemma">plus'_0_n</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.plus'"><span class="id" title="definition">plus'</span></a> 0 <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.plus'_comm"><span class="id" title="lemma">plus'_comm</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#NatOps.plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="NatOps.plus'_is_plus"><span class="id" title="lemma">plus'_is_plus</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#NatOps.plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#NatOps.plus"><span class="id" title="definition">plus</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#NatOps"><span class="id" title="module">NatOps</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab73"></a><h2 class="section">Typy polimorficzne i właściwości konstruktorów</h2>

<div class="paragraph"> </div>

 Przy pomocy komendy <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> możemy definiować nie tylko typy
    induktywne, ale także rodziny typów induktywnych. Jeżeli taka
    rodzina parametryzowana jest typem, to mamy do czynienia z
    polimorfizmem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="option"><span class="id" title="inductive">option</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Some"><span class="id" title="constructor">Some</span></a> : <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#option"><span class="id" title="inductive">option</span></a> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="None"><span class="id" title="constructor">None</span></a> : <a class="idref" href="R2.html#option"><span class="id" title="inductive">option</span></a> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">option</span></span> jest rodziną typów, zaś samo <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> dla ustalonego <span class="inlinecode"><span class="id" title="var">A</span></span>
    jest typem, który reprezentuje możliwość istnienia wartości typu <span class="inlinecode"><span class="id" title="var">A</span></span>
    (konstruktor <span class="inlinecode"><span class="id" title="var">Some</span></span>) albo i nie (konstruktor <span class="inlinecode"><span class="id" title="var">None</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> 5.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;nat&nbsp;5&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#None"><span class="id" title="constructor">None</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;None&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> [<span class="id" title="var">A</span>] <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="R2.html#None"><span class="id" title="constructor">None</span></a> [<span class="id" title="var">A</span>].<br/>

<br/>
</div>

<div class="doc">
Jak widać typ <span class="inlinecode"><span class="id" title="var">A</span></span>, będący parametrem <span class="inlinecode"><span class="id" title="var">option</span></span>, jest też pierwszym
    argumentem każdego z konstruktorów.
    Pisanie go bywa uciążliwe, ale na szczęście Coq może sam wywnioskować
    jego wartość, jeżeli mu każemy. Komenda <span class="inlinecode"><span class="id" title="var">Arguments</span></span> pozwala nam
    określić, które argumenty mają być domyślne — chcemy, aby argument <span class="inlinecode"><span class="id" title="var">A</span></span>
    był domyślny, gdyż w przypadku konstruktura <span class="inlinecode"><span class="id" title="var">Some</span></span> może być wywnioskowany
    z drugiego argumentu, a w przypadku <span class="inlinecode"><span class="id" title="var">None</span></span> — zazwyczaj z kontekstu.

<div class="paragraph"> </div>

    Konstruktory typów induktywnych mają kilka właściwości, o którch
    warto wiedzieć. Po pierwsze, wartości zrobione za pomocą różnych
    konstruktorów są różne. Jest to konieczne, gdyż za pomocą pattern
    machingu możemy rozróżnić różne konstruktory — gdyby były one
    równe, uzyskalibyśmy sprzeczność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="isSome"><span class="id" title="definition">isSome</span></a> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <a class="idref" href="R2.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="R2.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">_</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="R2.html#None"><span class="id" title="constructor">None</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Pomocnicza funkcja <span class="inlinecode"><span class="id" title="var">isSome</span></span> ma za zadanie sprawdzić, którym
    konstruktorem zrobiono wartość typu <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Zapis <span class="inlinecode">{<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>}</span>
    oznacza, że <span class="inlinecode"><span class="id" title="var">A</span></span> jest argumentem domyślnym funkcji — Coq może go
    wywnioskować, gdyż zna typ argumentu <span class="inlinecode"><span class="id" title="var">a</span></span> (jest nim <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>).
    Zauważ też, że funkcja ta zwraca zdania logiczne, a nie wartości
    boolowskie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="some_not_none"><span class="id" title="lemma">some_not_none</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="R2.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="R2.html#None"><span class="id" title="constructor">None</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a>; <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">change</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <span class="id" title="keyword">with</span> (<a class="idref" href="R2.html#isSome"><span class="id" title="definition">isSome</span></a> (@<a class="idref" href="R2.html#None"><span class="id" title="constructor">None</span></a> <span class="id" title="var">A</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Możemy użyć tej pomocniczej funkcji, aby udowodnić, że konstruktory
    <span class="inlinecode"><span class="id" title="var">Some</span></span> i <span class="inlinecode"><span class="id" title="var">None</span></span> tworzą różne wartości. Taktyka <span class="inlinecode"><span class="id" title="tactic">change</span></span> <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">t2</span></span>
    pozwala nam zamienić term <span class="inlinecode"><span class="id" title="var">t1</span></span> na <span class="inlinecode"><span class="id" title="var">t2</span></span> pod warunkiem, że są one
    konwertowalne (czyli jeden z nich redukuje się do drugiego). W naszym
    wypadku chcemy zastąpić <span class="inlinecode"><span class="id" title="var">False</span></span> przez <span class="inlinecode"><span class="id" title="var">isSome</span></span> <span class="inlinecode">(@<span class="id" title="var">None</span></span> <span class="inlinecode"><span class="id" title="var">A</span>)</span>, który
    redukuje się do <span class="inlinecode"><span class="id" title="var">False</span></span> (spróbuj zredukować to wyrażenie ręcznie).

<div class="paragraph"> </div>

    Użycie symbolu <span class="inlinecode">@</span> pozwala nam dla danego wyrażenia zrezygnować z
    próby automatycznego wywnioskowania argumentów domyślnych — w tym
    przypadku Coq nie potrafiłby wywnioskować argumentu dla konstruktora
    <span class="inlinecode"><span class="id" title="var">None</span></span>, więc musimy podać ten argument ręcznie. 

<div class="paragraph"> </div>

    Następnie możemy skorzystać z równania <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span>, żeby
    uzyskać cel postaci <span class="inlinecode"><span class="id" title="var">isSome</span></span> <span class="inlinecode">(<span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span>)</span>. Cel ten redukuje się
    do <span class="inlinecode"><span class="id" title="var">True</span></span>, którego udowodnienie jest trywialne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="some_not_none'"><span class="id" title="lemma">some_not_none'</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="R2.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="R2.html#None"><span class="id" title="constructor">None</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> 1.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Cała procedura jest dość skomplikowana — w szczególności wymaga
    napisania funkcji pomocniczej. Na szczęście Coq jest w stanie
    sam wywnioskować, że konstruktory są różne. Możemy zrobić to
    przy pomocy znanej nam z poprzedniego rozdziału taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>.
    Zapis <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode">1</span> oznacza: wprowadź zmienne związane przez
    kwantyfikację uniwersaną do kontekstu i użyj taktyki <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>
    na pierwszej przesłance implikacji. W naszym przypadku implikacja
    jest ukryta w definicji negacji: <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">None</span></span> to tak naprawdę
    <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">False</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="some_inj"><span class="id" title="lemma">some_inj</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="R2.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#y"><span class="id" title="variable">y</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">injection</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejną właściwością konstruktorów jest fakt, że są one injekcjami,
    tzn. jeżeli dwa termy zrobione tymi samymi konstruktorami są równe,
    to argumenty tych konstruktorów też są równe.

<div class="paragraph"> </div>

    Aby skorzystać z tej właściwości w dowodzie, możemy użyć taktyki
    <span class="inlinecode"><span class="id" title="tactic">injection</span></span>, podając jej jako argument nazwę hipotezy. Jeżeli
    hipoteza jest postaci <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">yn</span></span>, to nasz cel <span class="inlinecode"><span class="id" title="var">G</span></span>
    zostanie zastąpiony przez implikację <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">yn</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">G</span></span>.
    Po wprowadzeniu hipotez do kontekstu możemy użyć ich do udowodnienia
    <span class="inlinecode"><span class="id" title="var">G</span></span>, zazwyczaj przy pomocy taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.

<div class="paragraph"> </div>

    W naszym przypadku <span class="inlinecode"><span class="id" title="var">H</span></span> miało postać <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>, a cel <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    więc <span class="inlinecode"><span class="id" title="tactic">injection</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> przekształciło cel do postaci <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    który jest trywialny. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="some_inj'"><span class="id" title="lemma">some_inj'</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="R2.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#y"><span class="id" title="variable">y</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> 1. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> może nam pomóc również wtedy, kiedy chcemy skorzystać
    z injektywności konstruktorów. W zasadzie jest ona nawet bardziej
    przydatna — działa ona tak jak <span class="inlinecode"><span class="id" title="tactic">injection</span></span>, ale zamiast zostawiać cel w
    postaci <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">G</span></span>, wprowadza ona wygenerowane hipotezy do
    kontekstu, a następnie przepisuje w celu wszystkie, których przepisanie
    jest możliwe. W ten sposób oszczędza nam ona nieco pisania.

<div class="paragraph"> </div>

    W naszym przypadku <span class="inlinecode"><span class="id" title="var">inverson</span></span> <span class="inlinecode">1</span> dodała do kontekstu hipotezę <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>,
    a następnie przepisała ją w celu (który miał postać <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>), dając
    cel postaci <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="some_inj''"><span class="id" title="lemma">some_inj''</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="R2.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#y"><span class="id" title="variable">y</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">injection</span> 1. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyką ułatwiającą pracę z <span class="inlinecode"><span class="id" title="tactic">injection</span></span> oraz <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> jest <span class="inlinecode"><span class="id" title="tactic">subst</span></span>.
    Taktyka ta wyszukuje w kontekście hipotezy postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>,
    przepisuje je we wszystkich hipotezach w kontekście i celu, w których
    jest to możliwe, a następnie usuwa. Szczególnie często spotykana
    jest kombinacja <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode"><span class="id" title="var">H</span>;</span> <span class="inlinecode"><span class="id" title="tactic">subst</span></span>, gdyż <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> często
    generuje sporą ilość hipotez postaci <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span>, które <span class="inlinecode"><span class="id" title="tactic">subst</span></span> następnie
    "sprząta".

<div class="paragraph"> </div>

    W naszym przypadku hipoteza <span class="inlinecode"><span class="id" title="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> została przepisana nie tylko
    w celu, dając <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>, ale także w hipotezie <span class="inlinecode"><span class="id" title="var">H</span></span>, dając
    <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
<div class="paragraph"> </div>

<a name="lab74"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <a name="zero_not_one"><span class="id" title="lemma">zero_not_one</span></a> : 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> 1.<br/>

<br/>
</div>

<div class="doc">
Dwie opisane właściwości, choć pozornie niewinne, a nawet przydatne,
    mają bardzo istotne i daleko idące konsekwencje. Powoduję one na
    przykład, że nie istnieją typy ilorazowe. Dokładne znaczenie tego
    faktu omówimy później, zaś teraz musimy zadowolić się jedynie
    prostym przykładem w formie ćwiczenia. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="rational"><span class="id" title="module">rational</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="rational.rational"><span class="id" title="inductive">rational</span></a> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="rational.mk_rational"><span class="id" title="constructor">mk_rational</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">sign</span> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">numerator</span> <span class="id" title="var">denominator</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#denominator"><span class="id" title="variable">denominator</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#rational"><span class="id" title="inductive">rational</span></a>.<br/>

<br/>
<span class="id" title="keyword">Axiom</span> <a name="rational.rational_eq"><span class="id" title="axiom">rational_eq</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">p</span> <span class="id" title="var">p'</span> <span class="id" title="var">q</span> <span class="id" title="var">q'</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H</span> : <a class="idref" href="R2.html#q"><span class="id" title="variable">q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> 0) (<span class="id" title="var">H'</span> : <a class="idref" href="R2.html#q'"><span class="id" title="variable">q'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> 0), <a class="idref" href="R2.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="R2.html#q'"><span class="id" title="variable">q'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#p'"><span class="id" title="variable">p'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="R2.html#q"><span class="id" title="variable">q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#rational.mk_rational"><span class="id" title="constructor">mk_rational</span></a> <a class="idref" href="R2.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="R2.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="R2.html#q"><span class="id" title="variable">q</span></a> <a class="idref" href="R2.html#H"><span class="id" title="variable">H</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#rational.mk_rational"><span class="id" title="constructor">mk_rational</span></a> <a class="idref" href="R2.html#s'"><span class="id" title="variable">s'</span></a> <a class="idref" href="R2.html#p'"><span class="id" title="variable">p'</span></a> <a class="idref" href="R2.html#q'"><span class="id" title="variable">q'</span></a> <a class="idref" href="R2.html#H'"><span class="id" title="variable">H'</span></a>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">rational</span></span> ma reprezentować liczby wymierne. Znak jest typu
    <span class="inlinecode"><span class="id" title="var">bool</span></span> — możemy interpretować, że <span class="inlinecode"><span class="id" title="var">true</span></span> oznacza obecność znaku
    minus, a <span class="inlinecode"><span class="id" title="var">false</span></span> brak znaku. Dwie liczby naturalne będą oznaczać
    kolejno licznik i mianownik, a na końcu żądamy jeszcze dowodu na
    to, że mianownik nie jest zerem.

<div class="paragraph"> </div>

    Oczywiście typ ten sam w sobie niewiele ma wspólnego z liczbami
    wymiernymi — jest to po prostu trójka elementów o typach <span class="inlinecode"><span class="id" title="var">bool</span>,</span>
    <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, z których ostatni nie jest zerem. Żeby rzeczywiście
    reprezentował liczby wymierne musimy zapewnić, że termy, które
    reprezentują te same wartości, są równe, np. 1/2 musi być równa
    2/4.

<div class="paragraph"> </div>

    W tym celu postulujemy aksjomat, który zapewni nam pożądane
    właściwości relacji równości. Komenda <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> pozwala nam
    wymusić istnienie termu pożądanego typu i nadać mu nazwę,
    jednak jest szalenie niebezpieczna — jeżeli zapostulujemy
    aksjomat, który jest sprzeczny, jesteśmy zgubieni.

<div class="paragraph"> </div>

    W takiej sytuacji całe nasze dowodzenie idzie na marne, gdyż
    ze sprzecznego aksjomatu możemy wywnioskować <span class="inlinecode"><span class="id" title="var">False</span></span>, z
    <span class="inlinecode"><span class="id" title="var">False</span></span> zaś możemy wywnioskować cokolwiek, o czym przekonaliśmy
    się w rozdziale pierwszym. Tak też jest w tym przypadku —
    aksjomat <span class="inlinecode"><span class="id" title="var">rational_eq</span></span> jest sprzeczny, gdyż łamie zasadę
    injektywności konstruktorów. 
<div class="paragraph"> </div>

<a name="lab75"></a><h4 class="section">Ćwiczenie.</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <a name="rational.rational_eq_inconsistent"><span class="id" title="lemma">rational_eq_inconsistent</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#rational"><span class="id" title="module">rational</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab76"></a><h2 class="section">Typy induktywne — pełna moc</h2>

<div class="paragraph"> </div>

 Połączenie funkcji zależnych, konstruktorów rekurencyjnych i
    polimorfizmu pozwala nam na opisywanie (prawie) dowolnych typów.
    Jednym z najbardziej podstawowych i najbardziej przydatnych
    narzędzi w programowaniu funkcyjnym (i w ogóle w życiu) są listy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="MyList"><span class="id" title="module">MyList</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="MyList.list"><span class="id" title="inductive">list</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MyList.nil"><span class="id" title="constructor">nil</span></a> : <a class="idref" href="R2.html#list"><span class="id" title="inductive">list</span></a> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MyList.cons"><span class="id" title="constructor">cons</span></a> : <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#list"><span class="id" title="inductive">list</span></a> <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#list"><span class="id" title="inductive">list</span></a> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
Lista przechowuje wartości pewnego ustalonego typu <span class="inlinecode"><span class="id" title="var">A</span></span> (a więc nie
    można np. trzymać w jednej liście jednocześnie wartości typu <span class="inlinecode"><span class="id" title="var">bool</span></span> i
    <span class="inlinecode"><span class="id" title="var">nat</span></span>) i może mieć jedną z dwóch postaci: może być pusta (konstruktor
    <span class="inlinecode"><span class="id" title="var">nil</span></span>) albo składać się z głowy i ogona (konstruktor <span class="inlinecode"><span class="id" title="var">cons</span></span>). Głowa
    listy to wartość typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś jej ogon to inna lista przechowująca
    wartości typu <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#MyList.nil"><span class="id" title="constructor">nil</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nil&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;list&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#MyList.cons"><span class="id" title="constructor">cons</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;cons&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="R2.html#MyList.nil"><span class="id" title="constructor">nil</span></a> [<span class="id" title="var">A</span>].<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="R2.html#MyList.cons"><span class="id" title="constructor">cons</span></a> [<span class="id" title="var">A</span>] <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Jak już wspomnieliśmy, jeżeli typ induktywny ma argument (w naszym
    przypadku <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>), to argument ten jest też pierwszym argumentem
    każdego z konstruktorów. W przypadku konstruktora <span class="inlinecode"><span class="id" title="var">cons</span></span> podawanie
    argumentu <span class="inlinecode"><span class="id" title="var">A</span></span> jest zbędne, gdyż kolejnym jego argumentem jest wartość
    tego typu. Wobec tego Coq może sam go wywnioskować, jeżeli mu każemy.

<div class="paragraph"> </div>

    Robimy to za pomocą komendy <span class="inlinecode"><span class="id" title="var">Arguments</span></span> <span class="inlinecode"><span class="id" title="var">konstruktor</span></span> <span class="inlinecode"><span class="id" title="var">argumenty</span></span>.
    Argumenty w nawiasach kwadratowych Coq będzie traktował jako domyślne,
    a te oznaczone podkreślnikiem trzeba będzie zawsze podawać ręcznie.
    Nazwa argumentu domyślnego musi być taka sama jak w definicji typu
    (w naszym przypadku w definicji <span class="inlinecode"><span class="id" title="var">list</span></span> argumentem nazywa się <span class="inlinecode"><span class="id" title="var">A</span></span>,
    więc tak też musimy go nazwać w komendzie arguments). Musimy wypisać
    wszystkie argumenty danego konstruktora — ich ilość możemy sprawdzić
    np. komendą <span class="inlinecode"><span class="id" title="keyword">Check</span></span>.

<div class="paragraph"> </div>

    Warto w tym momencie zauważyć, że Coq zna typy wszystkich termów,
    które zostały skonstruowane — gdyby tak nie było, nie mógłby
    sam uzupełniać argumentów domyślnych, a komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span> nie mogłaby
    działać. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="e2077f25f3bc1fccde3ffd7db4751925"><span class="id" title="notation">&quot;</span></a>[]" := <a class="idref" href="R2.html#MyList.nil"><span class="id" title="constructor">nil</span></a>.<br/>
<span class="id" title="keyword">Infix</span> <a name="81fbff7f45c08723c3bf91650063b65f"><span class="id" title="notation">&quot;</span></a>::" := (<a class="idref" href="R2.html#MyList.cons"><span class="id" title="constructor">cons</span></a>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span> ).<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#e2077f25f3bc1fccde3ffd7db4751925"><span class="id" title="notation">[]</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[]</span>&nbsp;:&nbsp;list&nbsp;?254&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> 0 <a class="idref" href="R2.html#81fbff7f45c08723c3bf91650063b65f"><span class="id" title="notation">::</span></a> 1 <a class="idref" href="R2.html#81fbff7f45c08723c3bf91650063b65f"><span class="id" title="notation">::</span></a> 2 <a class="idref" href="R2.html#81fbff7f45c08723c3bf91650063b65f"><span class="id" title="notation">::</span></a> <a class="idref" href="R2.html#MyList.nil"><span class="id" title="constructor">nil</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[0;</span> <span class="inlinecode">1;</span> <span class="inlinecode">2]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Nazwy <span class="inlinecode"><span class="id" title="var">nil</span></span> i <span class="inlinecode"><span class="id" title="var">cons</span></span> są zdecydowanie za długie w porównaniu do swej
    częstości występowania. Dzięki powyższym eleganckim notacjom
    zaoszczędzimy sobie trochę pisania. Jeżeli jednak notacje utrudniają
    nam np. odczytanie celu, który mamy udowodnić, możemy je wyłączyć
    odznaczając w CoqIDE View &gt; Display Notations.

<div class="paragraph"> </div>

    Wynik <span class="inlinecode">[]</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode">?254</span> (lub podobny) wyświetlony przez Coqa dla <span class="inlinecode">[]</span>
    mówi nam, że <span class="inlinecode">[]</span> jest listą pewnego ustalonego typu, ale Coq jeszcze
    nie wie, jakiego (bo ma za mało informacji, bo wywnioskować argument
    domyślny konstruktora <span class="inlinecode"><span class="id" title="var">nil</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="578168ce7c5e36069beaa0859586d5fc"><span class="id" title="notation">&quot;</span></a>[ x ]" := (<a class="idref" href="R2.html#MyList.cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">x</span> <a class="idref" href="R2.html#MyList.nil"><span class="id" title="constructor">nil</span></a>).<br/>
<span class="id" title="keyword">Notation</span> <a name="060450c47def8808643430b79a64b15c"><span class="id" title="notation">&quot;</span></a>[ x ; y ; .. ; z ]" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="R2.html#MyList.cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">x</span> (<a class="idref" href="R2.html#MyList.cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">y</span> .. (<a class="idref" href="R2.html#MyList.cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">z</span> <a class="idref" href="R2.html#MyList.nil"><span class="id" title="constructor">nil</span></a>) .. )).<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#578168ce7c5e36069beaa0859586d5fc"><span class="id" title="notation">[</span></a>5<a class="idref" href="R2.html#578168ce7c5e36069beaa0859586d5fc"><span class="id" title="notation">]</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[5]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">[</span></a>0<a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">;</span></a> 1<a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">;</span></a> 2<a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">;</span></a> 3<a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">]</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[0;</span> <span class="inlinecode">1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Zauważ, że system notacji Coqa jest bardzo silny — ostatnia notacja
    (ta zawierająca <span class="inlinecode">..</span>) jest rekurencyjna. W innych językach tego typu
    notacje są zazwyczaj wbudowane w język i ograniczają się do podstawowych
    typów, takich jak listy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="MyList.app"><span class="id" title="definition">app</span></a> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <a class="idref" href="R2.html#MyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="R2.html#MyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="R2.html#l1"><span class="id" title="variable">l1</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="R2.html#e2077f25f3bc1fccde3ffd7db4751925"><span class="id" title="notation">[]</span></a> =&gt; <a class="idref" href="R2.html#l2"><span class="id" title="variable">l2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> <a class="idref" href="R2.html#81fbff7f45c08723c3bf91650063b65f"><span class="id" title="notation">::</span></a> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">h</span> <a class="idref" href="R2.html#81fbff7f45c08723c3bf91650063b65f"><span class="id" title="notation">::</span></a> <a class="idref" href="R2.html#app"><span class="id" title="definition">app</span></a> <span class="id" title="var">t</span> <a class="idref" href="R2.html#l2"><span class="id" title="variable">l2</span></a><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="8e405436b89090288ae324379680afc6"><span class="id" title="notation">&quot;</span></a>l1 ++ l2" := (<a class="idref" href="R2.html#MyList.app"><span class="id" title="definition">app</span></a> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>
</div>

<div class="doc">
Funkcje na listach możemy definiować analogicznie do funkcji na
    liczbach naturalnych. Zaczniemy od słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>,
    gdyż będziemy potrzebować rekurencji. Pierwszym argumentem naszej
    funkcji będzie typ <span class="inlinecode"><span class="id" title="var">A</span></span> — musimy go wymienić, bo inaczej nie będziemy
    mogli mieć argumentów typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> (pamiętaj, że samo <span class="inlinecode"><span class="id" title="var">list</span></span>
    jest rodziną typów, a nie typem). Zapis <span class="inlinecode">{<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>}</span> oznacza,
    że Coq ma traktować <span class="inlinecode"><span class="id" title="var">A</span></span> jako argument domyślny — jest to szybszy
    sposób, niż użycie komendy <span class="inlinecode"><span class="id" title="var">Arguments</span></span>.

<div class="paragraph"> </div>

    Nasz funkcja ma za zadanie dokleić na końcu (ang. append) pierwszej
    listy drugą listę. Definicja jest dość intuicyjna: doklejenie jakiejś
    listy na koniec listy pustej daje pierwszą listę, a doklejenie listy
    na koniec listy mającej głowę i ogon jest doklejeniem jej na koniec
    ogona. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">[</span></a>1<a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">;</span></a> 2<a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">;</span></a> 3<a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">]</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">++</span></a> <a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">[</span></a>4<a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">;</span></a> 5<a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">;</span></a> 6<a class="idref" href="R2.html#060450c47def8808643430b79a64b15c"><span class="id" title="notation">]</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Wynik działania naszej funkcji wygląda poprawnie, ale niech cię
    nie zwiodą ładne oczka — jedynym sposobem ustalenia poprawności
    naszego kodu jest udowodnienie, że posiada on pożądane przez
    nas właściwości. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyList.app_nil_l"><span class="id" title="lemma">app_nil_l</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <a class="idref" href="R2.html#MyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#e2077f25f3bc1fccde3ffd7db4751925"><span class="id" title="notation">[]</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">++</span></a> <a class="idref" href="R2.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#l"><span class="id" title="variable">l</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyList.app_nil_r"><span class="id" title="lemma">app_nil_r</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <a class="idref" href="R2.html#MyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">++</span></a> <a class="idref" href="R2.html#e2077f25f3bc1fccde3ffd7db4751925"><span class="id" title="notation">[]</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#l"><span class="id" title="variable">l</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">h</span> <span class="id" title="var">t</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHt</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Sposoby dowodzenia są analogiczne jak w przypadku liczb naturalnych.
    Pierwsze twierdzenie zachodzi na mocy samej definicji funkcji <span class="inlinecode"><span class="id" title="var">app</span></span>
    i dowód sprowadza się do wykonania programu za pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">simpl</span></span>.
    Drugie jest analogiczne do twierdzenia <span class="inlinecode"><span class="id" title="var">plus_n_0</span></span>, z tą różnicą, że
    w drugim celu zamiast <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> posłużyliśmy się taktyką <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>.

<div class="paragraph"> </div>

    Zauważ też, że zmianie uległa postać wzorca przekazanego taktyce
    <span class="inlinecode"><span class="id" title="tactic">induction</span></span> — teraz ma on postać <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span>]</span>, gdyż <span class="inlinecode"><span class="id" title="var">list</span></span> ma 2
    konstruktory, z których pierwszy, <span class="inlinecode"><span class="id" title="var">nil</span></span>, nie bierze argumentów
    (argumenty domyślne nie są wymieniane we wzorcach), zaś drugi, <span class="inlinecode"><span class="id" title="var">cons</span></span>,
    ma dwa argumenty — głowę, tutaj nazwaną <span class="inlinecode"><span class="id" title="var">h</span></span> (jako skrót od ang. head)
    oraz ogon, tutaj nazwany <span class="inlinecode"><span class="id" title="var">t</span></span> (jako skrót od ang. tail). 
<div class="paragraph"> </div>

<a name="lab77"></a><h4 class="section">Ćwiczenie</h4>
 Pokaż, że <span class="inlinecode"><span class="id" title="var">app</span></span> jest łączne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyList.app_assoc"><span class="id" title="lemma">app_assoc</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> : <a class="idref" href="R2.html#MyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#l1"><span class="id" title="variable">l1</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">++</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">(</span></a><a class="idref" href="R2.html#l2"><span class="id" title="variable">l2</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">++</span></a> <a class="idref" href="R2.html#l3"><span class="id" title="variable">l3</span></a><a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">(</span></a><a class="idref" href="R2.html#l1"><span class="id" title="variable">l1</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">++</span></a> <a class="idref" href="R2.html#l2"><span class="id" title="variable">l2</span></a><a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">)</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">++</span></a> <a class="idref" href="R2.html#l3"><span class="id" title="variable">l3</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab78"></a><h4 class="section">Ćwiczenie</h4>
 Pokaż, że <span class="inlinecode"><span class="id" title="var">app</span></span> nie jest przemienne. Wskazówka: może ci się
    przydać taktyka <span class="inlinecode"><span class="id" title="tactic">specialize</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyList.app_not_comm"><span class="id" title="lemma">app_not_comm</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <a class="idref" href="R2.html#MyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#l1"><span class="id" title="variable">l1</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">++</span></a> <a class="idref" href="R2.html#l2"><span class="id" title="variable">l2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#l2"><span class="id" title="variable">l2</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">++</span></a> <a class="idref" href="R2.html#l1"><span class="id" title="variable">l1</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab79"></a><h4 class="section">Ćwiczenie</h4>
 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">length</span></span>, która oblicza długość listy. Jaki
    powinien być jej typ? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab80"></a><h4 class="section">Ćwiczenie</h4>
 Udowodnij poprawność swojej implementacji funkcji <span class="inlinecode"><span class="id" title="var">length</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyList.length_nil"><span class="id" title="lemma">length_nil</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#MyList.length"><span class="id" title="definition">length</span></a> (@<a class="idref" href="R2.html#MyList.nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyList.length_cons"><span class="id" title="lemma">length_cons</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">h</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">t</span> : <a class="idref" href="R2.html#MyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#MyList.length"><span class="id" title="definition">length</span></a> (<a class="idref" href="R2.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="R2.html#81fbff7f45c08723c3bf91650063b65f"><span class="id" title="notation">::</span></a> <a class="idref" href="R2.html#t"><span class="id" title="variable">t</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyList.app_length"><span class="id" title="lemma">app_length</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <a class="idref" href="R2.html#MyList.list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#MyList.length"><span class="id" title="definition">length</span></a> (<a class="idref" href="R2.html#l1"><span class="id" title="variable">l1</span></a> <a class="idref" href="R2.html#8e405436b89090288ae324379680afc6"><span class="id" title="notation">++</span></a> <a class="idref" href="R2.html#l2"><span class="id" title="variable">l2</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#MyList.length"><span class="id" title="definition">length</span></a> <a class="idref" href="R2.html#l1"><span class="id" title="variable">l1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#MyList.length"><span class="id" title="definition">length</span></a> <a class="idref" href="R2.html#l2"><span class="id" title="variable">l2</span></a>.<br/>

<br/>
</div>

<div class="doc">
Do list jeszcze wrócimy — planuję prędzej czy później dodać masywny
    zestaw ćwiczeń, polegający w zasadzie na reimplementacji biblioteki
    standardowej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#MyList"><span class="id" title="module">MyList</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab81"></a><h2 class="section">Rekordy</h2>
 W wielu językach programowania występują typy rekordów (ang. record
    types). Charakteryzują się one tym, że mają z góry określoną ilość
    pól o potencjalnie różnych typach. W językach imperatywnych rekordy
    wyewoluowały zaś w obiekty, które różnią się od rekordów tym, że mogą
    zawierać również funkcje, których dziedziną jest obiekt, w którym
    funkcja się znajduje.

<div class="paragraph"> </div>

    W Coqu mamy do dyspozycji rekordy, ale nie obiekty. Trzeba tu po raz
    kolejny pochwalić siłę systemu typów Coqa — o ile w większości języków
    rekordy są osobnym konstruktem językowym, o tyle w Coqu mogą być one z
    łatwością reprezentowane przez typy induktywne z jednym konstruktorem
    (wraz z odpowiednimi projekcjami, które dekonstruują rekord). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="rational2"><span class="id" title="module">rational2</span></a>.<br/>

<br/>
<span class="id" title="keyword">Record</span> <a name="rational2.rational"><span class="id" title="record">rational</span></a> : <span class="id" title="keyword">Set</span> :=<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="rational2.sign"><span class="id" title="projection">sign</span></a> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="rational2.numerator"><span class="id" title="projection">numerator</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="rational2.denominator"><span class="id" title="projection">denominator</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="rational2.denominator_not_zero"><span class="id" title="projection">denominator_not_zero</span></a> : <a class="idref" href="R2.html#denominator"><span class="id" title="method">denominator</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> 0<br/>
}.<br/>

<br/>
</div>

<div class="doc">
Z typem induktywnym o jednym konstruktorze już się zetknęliśmy,
    próbując zdefiniować liczby wymierne. Powyższa definicja używająca
    rekordu ma drobną przewagę nad poprzednią, w której słowo kluczowe
    <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> pada explicité:
<ul class="doclist">
<li> wygląda ładniej

</li>
<li> ma projekcje 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#rational2.sign"><span class="id" title="projection">sign</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;sign&nbsp;:&nbsp;rational&nbsp;-&gt;&nbsp;bool&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#rational2.denominator_not_zero"><span class="id" title="projection">denominator_not_zero</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;denominator_not_zero<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;r&nbsp;:&nbsp;rational,&nbsp;denominator&nbsp;r&nbsp;&lt;&gt;&nbsp;0&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Dzięki projekcjom mamy dostęp do poszczególnych pól rekordu bez
    konieczności jego dekonstruowania — nie musimy używać konstruktu
    <span class="inlinecode"><span class="id" title="keyword">match</span></span> ani taktyki <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, jeżeli nie chcemy. Często bywa to
    bardzo wygodne.

<div class="paragraph"> </div>

    Projekcję <span class="inlinecode"><span class="id" title="var">sign</span></span> możemy interpretować jako funkcję, która bierze
    liczbę wymierną <span class="inlinecode"><span class="id" title="var">r</span></span> i zwraca jej znak, zaś projekcja
    <span class="inlinecode"><span class="id" title="var">denominator_not_zero</span></span> mówi nam, że mianownik żadnej liczb wymiernej
    nie jest zerem.

<div class="paragraph"> </div>

    Pozwa tymi wizualno-praktycznymi drobnostkami, obie definicje są
    równoważne (w szczególności, powyższa definicja, podobnie jak
    poprzednia, nie jest dobrą reprezentacją liczb wymiernych). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#rational2"><span class="id" title="module">rational2</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab82"></a><h4 class="section">Ćwiczenie</h4>
 Zdefiniuj typ induktywny reprezentujący datę i napisz ręcznie
    wszystkie projekcje. Następnie zdefiniuj rekord reprezentujący
    datę i zachwyć się tym, ile czasu i głupiego pisania zaoszczędziłbyś,
    gdybyś od razu użył rekordu... 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab83"></a><h2 class="section">Klasy</h2>
 Mechanizmem ułatwiającym życie jeszcze bardziej niż rekordy są klasy.
    Niech nie zmyli cię ta nazwa — nie mają one nic wspólnego z klasami
    znanymi z języków imperatywnych. Bliżej im raczej do interfejsów,
    od których są zresztą dużo silniejsze.

<div class="paragraph"> </div>

    W językach imperatywnych interfejs możemy zaimplementować zazwyczaj
    definiując nowy typ. W Coqu możemy uczynić typ instancją klasy w
    dowolnym miejscu — nawet jeżeli to nie my go zdefiniowaliśmy. Co
    więcej, instancjami klas mogą być nie tylko typy, ale dowolne termy.
    Klasy są w Coqu pełnoprawnym tworem — mogą mieć argumenty, zawierać
    inne klasy, być przekazywane jako argumenty do funkcji etc. Używa się
    ich zazwyczaj dwojako:
<ul class="doclist">
<li> zamiast rekordów (zwiększa to nieco czytelność)

</li>
<li> jako interfejsy 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Class</span> <a name="EqDec"><span class="id" title="record">EqDec</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="eq_dec"><span class="id" title="projection">eq_dec</span></a> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="eq_dec_spec"><span class="id" title="projection">eq_dec_spec</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="R2.html#eq_dec"><span class="id" title="method">eq_dec</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="R2.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#y"><span class="id" title="variable">y</span></a><br/>
}.<br/>

<br/>
</div>

<div class="doc">
Nie będziemy po raz trzeci powtarzać (kulawej) definicji liczb
    wymiernych — użycie do tego klas zamiast rekordów sprowadza się
    do zamienienia słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">Record</span></span> na <span class="inlinecode"><span class="id" title="keyword">Class</span></span> w poprzedniej
    definicji.

<div class="paragraph"> </div>

    Przyjrzyjmmy się za to wykorzystaniu klasy w roli interfejsu.
    Argument <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> po nazwie klasy mówi nam, że nasz interfejs
    będą mogły implementować typy. Dalej zapis <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> mówi nam, że
    nasza klasa jest typem — klasy, jako ulepszone rekordy, są typami
    induktywnymi z jednym konstruktorem.

<div class="paragraph"> </div>

    Nasza klasa ma dwa pola, które będzie musiał podać użytkownik chcący
    uczynić swój typ jej instancją: funkcję <span class="inlinecode"><span class="id" title="var">eq_dec</span></span> oraz jej specyfikację,
    która mówi nam, że <span class="inlinecode"><span class="id" title="var">eq_dec</span></span> zwraca <span class="inlinecode"><span class="id" title="var">true</span></span> wtedy i tylko wtedy, gdy jej
    argumenty są równe.

<div class="paragraph"> </div>

    Wobec tego typy będące instancjami <span class="inlinecode"><span class="id" title="var">EqDec</span></span> można interpretować jako
    typy, dla których równość elementów można sprawdzić za pomocą jakiegoś
    algorytmu. Nie wszystkie typy posiadają tę własność — problematyczne
    są szczególnie te, których elementy są w jakiś sposób "nieskończone". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Instance</span> <a name="EqDec_bool"><span class="id" title="instance">EqDec_bool</span></a> : <a class="idref" href="R2.html#EqDec"><span class="id" title="class">EqDec</span></a> <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#eq_dec"><span class="id" title="method">eq_dec</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> <span class="id" title="var">b'</span> : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="R2.html#b"><span class="id" title="variable">b</span></a>, <a class="idref" href="R2.html#b'"><span class="id" title="variable">b'</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a>, <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a> =&gt; <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="R2.html#false"><span class="id" title="constructor">false</span></a>, <a class="idref" href="R2.html#false"><span class="id" title="constructor">false</span></a> =&gt; <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> =&gt; <a class="idref" href="R2.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>, <span class="id" title="var">y</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">trivial</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Instancje klas definiujemy przy pomocy słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>.
    Jeżeli używamy klasy jako interfejsu, który implementować mogą typy,
    to zazwyczaj będziemy potrzebować tylko jednej instancji, więc jej
    nazwa będzie niemal identyczna jak jej typ (dzięki temu łatwo będzie
    ją zapamiętać).

<div class="paragraph"> </div>

    Po symbolu <span class="inlinecode">:=</span> w nawiasach klamrowych definiujemy pola, które
    nie są dowodami. Całość, jako komenda, musi kończyć się kropką. Gdy
    klasa nie zawiera żadnych pól będących dowodami, definicja jest
    zakończona. W przeciwnym przypadku Coq przechodzi w tryb dowodzenia,
    w którym każdemu polu będącemu dowodem odpowiada jeden podcel. Po
    rozwiązaniu wszystkich podcelów instancja jest zdefiniowana.

<div class="paragraph"> </div>

    W naszym przypadku klasa ma dwa pola — funkcję i dowód na to, że
    funkcja spełnia specyfikację — więc w nawiasach klamrowych musimy
    podać jedynie funkcję. Zauważmy, że nie musimy koniecznie definiować
    jej właśnie w tym miejscu — możemy zrobić to wcześniej, np. za pomocą
    komendy <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> albo <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>, a tutaj odnieść się do niej
    używając jej nazwy. W przypadku bardziej skomplikowanych definicji
    jest to nawet lepsze wyjście, gdyż zyskujemy dzięki niemu kontrolę
    nad tym, w którym miejscu rozwinąć definicję, dzięki czemu kontekst
    i cel stają się czytelniejsze.

<div class="paragraph"> </div>

    Ponieważ nasza klasa ma pole, które jest dowodem, Coq przechodzi w tryb
    dowodzenia. Dowód, mimo iż wymaga rozpatrzenia ośmiu przypadków, mieści
    się w jednej linijce — widać tutaj moc automatyzacji. Prześledźmy, co
    się w nim dzieje.

<div class="paragraph"> </div>

    Najpierw rozbijamy wartości boolowskie <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span>. Nie musimy wcześniej
    wprowadzać ich do kontekstu taktyką <span class="inlinecode"><span class="id" title="tactic">intros</span></span>, gdyż <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> sam potrafi
    to zrobić. W wyniku tego dostajemy cztere podcele. W każdym z nich
    taktyką <span class="inlinecode"><span class="id" title="tactic">split</span></span> rozbijamy równoważność na dwie implikacje. Sześć z nich
    ma postać <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>, więc radzi sobie z nimi taktyka <span class="inlinecode"><span class="id" title="tactic">trivial</span></span>. Dwie
    pozostałe mają przesłanki postaci <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> albo <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span>,
    które są sprzeczne na mocy omówionych wcześniej właściwości konstruktorów.
    Taktyką <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode">1</span> wskazujemy, że pierwsza przesłanka implikacji
    zawiera taką właśnie sprzeczną równość termów zrobionych różnymi
    konstruktorami, a Coq załatwia za nas resztę.

<div class="paragraph"> </div>

    Jeżeli masz problem z odczytaniem tego dowodu, koniecznie przeczytaj
    ponownie fragment rozdziału pierwszego dotyczący kombinatorów taktyk.
    Jeżeli nie potrafisz wyobrazić sobie podcelów generowanych przez
    kolejne taktyki, zastąp chwilowo średniki kropkami, a jeżeli to nie
    pomaga, udowodnij całe twierdzenie bez automatyzacji.

<div class="paragraph"> </div>

    Dzięki takim ćwiczeniom prędzej czy później oswoisz się z tym sposobem
    dowodzenia, choć nie jest to sztuka prosta — czytanie cudzych dowodów
    jest równie trudne jak czytanie cudzych programów.

<div class="paragraph"> </div>

    Prawie nigdy zresztą nowopowstałe dowody nie są od razu zautomatyzowane
    aż w takim stopniu — najpierw są przeprowadzone w części lub w całości
    ręcznie. Automatyzacja jest wynikiem dostrzeżenia w dowodzie pewnych
    powtarzających się wzorców. Proces ten przypomina trochę
    refaktoryzację kodu — gdy dostrzeżemy powtarzające się fragmenty kodu,
    przenosimy je do osobnych procedur. Analogicznie, gdy dostrzegamy
    powtarzające się fragmenty dowodu, łączymy je kombinatorami taktyk
    lub piszemy własne, zupełnie nowe taktyki (temat pisania własnych
    taktyk poruszę prędzej czy później).

<div class="paragraph"> </div>

    Od teraz będę zakładał, że nie masz problemów ze zrozumieniem takich
    dowodów i kolejne przykładowe dowody będę pisał w bardziej zwratej
    formie.

<div class="paragraph"> </div>

    Zauważ, że definicję instancji kończymy komendą <span class="inlinecode"><span class="id" title="keyword">Defined</span></span>, a nie <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>,
    jak to było w przypadku dowodów twierdzeń. Wynika to z faktu, że Coq
    inaczej traktuje specyfikacje i programy, a inaczej zdania i dowody.
    W przypadku dowodu liczy się sam fakt jego istnienia, a nie jego treść,
    więc komenda <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> każe Coqowi zapamiętać jedynie, że twierdzenie
    udowodniono, a zapomnieć, jak dokładnie wyglądał proofterm. W przypadku
    programów takie zachowanie jest niedopuszczalne, więc <span class="inlinecode"><span class="id" title="keyword">Defined</span></span> każe
    Coqowi zapamiętać term ze wszystkimi szczegółami. Jeżeli nie wiesz,
    której z tych dwóch komend użyć, użyj <span class="inlinecode"><span class="id" title="keyword">Defined</span></span>. 
<div class="paragraph"> </div>

<a name="lab84"></a><h4 class="section">Ćwiczenie</h4>
 Zdefiniuj instancje klasy <span class="inlinecode"><span class="id" title="var">EqDec</span></span> dla typów <span class="inlinecode"><span class="id" title="var">unit</span></span> oraz <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab85"></a><h4 class="section">Ćwiczenie</h4>
 Czy możliwe jest zdefiniowanie instancji klasy <span class="inlinecode"><span class="id" title="var">EqDec</span></span> dla typu:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Jeżeli tak, udowodnij w Coqu. Jeżeli nie, zaargumentuj słownie. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Instance</span> <a name="EqDec_option"><span class="id" title="instance">EqDec_option</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">_</span> : <a class="idref" href="R2.html#EqDec"><span class="id" title="class">EqDec</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="R2.html#EqDec"><span class="id" title="class">EqDec</span></a> (<a class="idref" href="R2.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>) :=<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#eq_dec"><span class="id" title="method">eq_dec</span></a> := <span class="id" title="keyword">fun</span> <span class="id" title="var">opt1</span> <span class="id" title="var">opt2</span> : <a class="idref" href="R2.html#option"><span class="id" title="inductive">option</span></a> <span class="id" title="var">A</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="R2.html#opt1"><span class="id" title="variable">opt1</span></a>, <a class="idref" href="R2.html#opt2"><span class="id" title="variable">opt2</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">a</span>, <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">a'</span> =&gt; <a class="idref" href="R2.html#eq_dec"><span class="id" title="method">eq_dec</span></a> <span class="id" title="var">a</span> <span class="id" title="var">a'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="R2.html#None"><span class="id" title="constructor">None</span></a>, <a class="idref" href="R2.html#None"><span class="id" title="constructor">None</span></a> =&gt; <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> =&gt; <a class="idref" href="R2.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>, <span class="id" title="var">y</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">trivial</span>; <span class="id" title="tactic">try</span> (<span class="id" title="tactic">inversion</span> 1; <span class="id" title="tactic">fail</span>); <span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="R2.html#eq_dec_spec"><span class="id" title="method">eq_dec_spec</span></a> <span class="id" title="var">a</span> <span class="id" title="var">a0</span>) <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="R2.html#eq_dec_spec"><span class="id" title="method">eq_dec_spec</span></a> <span class="id" title="var">a</span> <span class="id" title="var">a0</span>). <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Instancje klas mogą przyjmować argumenty, w tym również instancje innych
    klas albo inne instancje tej samej klasy. Dzięki temu możemy wyrazić
    ideę interfejsów warunkowych.

<div class="paragraph"> </div>

    W naszym przypadku typ <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> może być instancją klasy <span class="inlinecode"><span class="id" title="var">EqDec</span></span>
    jedynie pod warunkiem, że jego argument również jest instancją tej
    klasy. Jest to konieczne, gdyż porównywanie termów typu <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    sprowadza się do porównywania termów typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

<div class="paragraph"> </div>

    Zauważ, że kod <span class="inlinecode"><span class="id" title="var">eq_dec</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">a'</span></span> nie odwołuje się do definiowanej właśnie
    funkcji <span class="inlinecode"><span class="id" title="var">eq_dec</span></span> dla typu <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> — odnosi się do funkcji <span class="inlinecode"><span class="id" title="var">eq_dec</span></span>,
    której dostarcza nam instancja <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">EqDec</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Jak widać, nie musimy
    nawet nadawać jej nazwy — Coqa interesuje tylko jej obecność.

<div class="paragraph"> </div>

    Na podstawie typów termów <span class="inlinecode"><span class="id" title="var">a</span></span> i <span class="inlinecode"><span class="id" title="var">a'</span></span>, które są Coqowi znane, potrafi
    on wywnioskować, że <span class="inlinecode"><span class="id" title="var">eq_dec</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">a'</span></span> nie jest wywołaniem rekurencyjnym,
    lecz odnosi się do instancji innej niż obecnie definiowana. Coq może
    ją znaleźć i odnosić się do niej, mimo że my nie możemy (gdybyśmy
    chcieli odnosić się do tej instancji, musielibyśmy zmienić nazwę z
    <span class="inlinecode"><span class="id" title="var">_</span></span> na coś innego). 
<div class="paragraph"> </div>

<a name="lab86"></a><h3 class="section">Przydatne komendy</h3>
 Ponieważ w następnym zadaniu pojawia się stwierdzenie "znajdź",
    czas, aby opisać kilka przydatnych komend. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;unit&nbsp;:&nbsp;Set&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;unit&nbsp;:&nbsp;Set&nbsp;:=&nbsp;tt&nbsp;:&nbsp;unit&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Przypomnijmy, że komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span> wyświetla typ danego jej termu,
    a <span class="inlinecode"><span class="id" title="keyword">Print</span></span> wypisuje jego definicję. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">Search</span></span> wyświetla wszystkie obiekty, które zawierają podaną nazwę.
    W naszym przypadku pokazały się wszystkie funkcje, w których
    sygnaturze występuje typ <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">SearchAbout</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span> wyświetla wszystkie obiekty, które mają jakiś związek
    z daną nazwą. Zazwyczaj wskaże on nam dużo więcej obiektów, niż zwykłe
    <span class="inlinecode"><span class="id" title="keyword">Search</span></span>, np. poza funkcjami, w których sygnaturze występuje <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    pokazuje też twierdzenia dotyczące ich właściwości. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span><span class="id" title="var">Pattern</span> (<span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">SearchPattern</span></span> jako argument bierze wzorzec i wyświetla wszystkie
    obiekty, które zawierają podterm pasujący do danego wzorca. W naszym
    przypadku pokazały się twierdzenia, w których występuje podterm
    mający po lewej dodawanie, a po prawej cokolwiek.

<div class="paragraph"> </div>

    Dokładny opis wszystkich komend znajdziesz tutaj:
    https://coq.inria.fr/refman/command-index.html 
<div class="paragraph"> </div>

<a name="lab87"></a><h4 class="section">Ćwiczenie</h4>
 Zdefiniuj instancję klasy <span class="inlinecode"><span class="id" title="var">EqDec</span></span> dla typu <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Wskazówka:
    znajdź w bibliotece standardowej moduł, który zawiera twierdzenia
    o właściwościach funkcji <span class="inlinecode"><span class="id" title="var">andb</span></span>. Jedna z nich przyda ci się.

<div class="paragraph"> </div>

    Spis modułów biblioteki standardowej jest tu:
    https://coq.inria.fr/library/ 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab88"></a><h4 class="section">Ćwiczenie</h4>
 Niech <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> będą dowolnymi typami. Zastanów się, kiedy możliwe
    jest zdefiniowanie instancji klasy <span class="inlinecode"><span class="id" title="var">EqDec</span></span> dla <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>. 
<div class="paragraph"> </div>

<a name="lab89"></a><h2 class="section">Ważne typy induktywne</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="ImportantTypes"><span class="id" title="module">ImportantTypes</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab90"></a><h3 class="section">Typ pusty</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="ImportantTypes.Empty_set"><span class="id" title="inductive">Empty_set</span></a> : <span class="id" title="keyword">Set</span> := .<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Empty_set</span></span> jest, jak sama nazwa wskazuje, typem pustym. Żaden term
    nie jest tego typu. Innymi słowy: jeżeli jakiś term jest typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>,
    to mamy sprzeczność. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="ImportantTypes.create"><span class="id" title="definition">create</span></a> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <a class="idref" href="R2.html#ImportantTypes.Empty_set"><span class="id" title="inductive">Empty_set</span></a>) : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Jeżeli mamy term typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, to możemy w sposób niemal magiczny
    wyczarować term dowolnego typu <span class="inlinecode"><span class="id" title="var">A</span></span>, używając pattern matchingu z
    pustym wzorcem. 
<div class="paragraph"> </div>

<a name="lab91"></a><h4 class="section">Ćwiczenie</h4>
 Udowodnij, że powyższa funkcja jest unikalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ImportantTypes.create_unique"><span class="id" title="lemma">create_unique</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="R2.html#ImportantTypes.Empty_set"><span class="id" title="inductive">Empty_set</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <a class="idref" href="R2.html#ImportantTypes.Empty_set"><span class="id" title="inductive">Empty_set</span></a>, <a class="idref" href="R2.html#ImportantTypes.create"><span class="id" title="definition">create</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab92"></a><h4 class="section">Ćwiczenie</h4>
 Pokaż, że nie istnieją funkcje z typu niepustego w pusty. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ImportantTypes.no_fun_from_nonempty_to_empty"><span class="id" title="lemma">no_fun_from_nonempty_to_empty</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#ImportantTypes.Empty_set"><span class="id" title="inductive">Empty_set</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab93"></a><h3 class="section">Singleton</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="ImportantTypes.unit"><span class="id" title="inductive">unit</span></a> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="ImportantTypes.tt"><span class="id" title="constructor">tt</span></a> : <a class="idref" href="R2.html#unit"><span class="id" title="inductive">unit</span></a>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">unit</span></span> jest typem, który ma tylko jeden term, zwany <span class="inlinecode"><span class="id" title="var">tt</span></span> (nazwa ta
    jest wzięta z sufitu). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="ImportantTypes.delete"><span class="id" title="definition">delete</span></a> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="R2.html#ImportantTypes.unit"><span class="id" title="inductive">unit</span></a> := <a class="idref" href="R2.html#ImportantTypes.tt"><span class="id" title="constructor">tt</span></a>.<br/>

<br/>
</div>

<div class="doc">
Funkcja <span class="inlinecode"><span class="id" title="var">delete</span></span> jest w pewien sposób "dualna" do napotkanej przez
    nas wcześniej funkcji <span class="inlinecode"><span class="id" title="var">create</span></span>. Mając term typu <span class="inlinecode"><span class="id" title="var">Empty_set</span></span> mogliśmy
    stworzyć term dowolnego innego typu, zaś mając term dowolnego typu
    <span class="inlinecode"><span class="id" title="var">A</span></span>, możemy "zapomnieć o nim" albo "skasować go", wysyłając go
    funkcją <span class="inlinecode"><span class="id" title="var">delete</span></span> w jedyny term typu <span class="inlinecode"><span class="id" title="var">unit</span></span>, czyli <span class="inlinecode"><span class="id" title="var">tt</span></span>.

<div class="paragraph"> </div>

    Uwaga: określenie "skasować" nie ma nic wspólnego z fizycznym
    niszczeniem albo dealokacją pamięci. Jest to tylko metafora. 
<div class="paragraph"> </div>

<a name="lab94"></a><h4 class="section">Ćwiczenie</h4>
 Pokaż, że funkcja <span class="inlinecode"><span class="id" title="var">delete</span></span> jest unikalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ImportantTypes.delete_unique"><span class="id" title="lemma">delete_unique</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#ImportantTypes.unit"><span class="id" title="inductive">unit</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="R2.html#ImportantTypes.delete"><span class="id" title="definition">delete</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab95"></a><h3 class="section">Produkt</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="ImportantTypes.prod"><span class="id" title="inductive">prod</span></a> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="ImportantTypes.pair"><span class="id" title="constructor">pair</span></a> : <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="var">B</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#prod"><span class="id" title="inductive">prod</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="R2.html#ImportantTypes.pair"><span class="id" title="constructor">pair</span></a> [<span class="id" title="var">A</span>] [<span class="id" title="var">B</span>] <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Produkt typów <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> to typ, którego termami są pary. Pierwszy
    element pary to term typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a drugi to term typu <span class="inlinecode"><span class="id" title="var">B</span></span>. Tym, co
    charakteryzuje produkt, są projekcje:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">fst</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> wyciąga z pary jej
      pierwszy element

</li>
<li> <span class="inlinecode"><span class="id" title="var">snd</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> wyciąga z pary jej
      drugi element 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab96"></a><h4 class="section">Ćwiczenie</h4>
 Zdefiniuj projekcje i udowodnij poprawność swojej definicji. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ImportantTypes.proj_spec"><span class="id" title="lemma">proj_spec</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">p</span> : <a class="idref" href="R2.html#ImportantTypes.prod"><span class="id" title="inductive">prod</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="R2.html#B"><span class="id" title="variable">B</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#ImportantTypes.pair"><span class="id" title="constructor">pair</span></a> (<a class="idref" href="R2.html#ImportantTypes.fst"><span class="id" title="definition">fst</span></a> <a class="idref" href="R2.html#p"><span class="id" title="variable">p</span></a>) (<a class="idref" href="R2.html#ImportantTypes.snd"><span class="id" title="definition">snd</span></a> <a class="idref" href="R2.html#p"><span class="id" title="variable">p</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab97"></a><h3 class="section">Suma</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="ImportantTypes.sum"><span class="id" title="inductive">sum</span></a> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="ImportantTypes.inl"><span class="id" title="constructor">inl</span></a> : <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#sum"><span class="id" title="inductive">sum</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="ImportantTypes.inr"><span class="id" title="constructor">inr</span></a> : <span class="id" title="var">B</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#sum"><span class="id" title="inductive">sum</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="R2.html#ImportantTypes.inl"><span class="id" title="constructor">inl</span></a> [<span class="id" title="var">A</span>] [<span class="id" title="var">B</span>] <span class="id" title="var">_</span>.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="R2.html#ImportantTypes.inr"><span class="id" title="constructor">inr</span></a> [<span class="id" title="var">A</span>] [<span class="id" title="var">B</span>] <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Suma <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> to typ, którego termy są albo termami typu <span class="inlinecode"><span class="id" title="var">A</span></span>,
    zawiniętymi w konstruktor <span class="inlinecode"><span class="id" title="var">inl</span></span>, albo termami typu <span class="inlinecode"><span class="id" title="var">B</span></span>, zawiniętymi
    w konstruktor <span class="inlinecode"><span class="id" title="var">inr</span></span>. Suma, w przeciwieństwie do produktu, zdecydowanie
    nie ma projekcji. 
<div class="paragraph"> </div>

<a name="lab98"></a><h4 class="section">Ćwiczenie</h4>
 Pokaż, że suma nie ma projekcji. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ImportantTypes.sum_no_fst"><span class="id" title="lemma">sum_no_fst</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">proj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <a class="idref" href="R2.html#ImportantTypes.sum"><span class="id" title="inductive">sum</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="R2.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ImportantTypes.sum_no_snd"><span class="id" title="lemma">sum_no_snd</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">proj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <a class="idref" href="R2.html#ImportantTypes.sum"><span class="id" title="inductive">sum</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="R2.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#B"><span class="id" title="variable">B</span></a>), <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#ImportantTypes"><span class="id" title="module">ImportantTypes</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab99"></a><h2 class="section">Typy puste</h2>

<div class="paragraph"> </div>

 Typy puste to typy, które nie mają żadnych elementów. Z jednym z nich
    już się spotkaliśmy — był to <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, który jest pusty, gdyż nie
    ma żadnych konstruktorów. Czy wszystkie typy puste to typy, które
    nie mają konstruktorów? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Empty"><span class="id" title="inductive">Empty</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="c"><span class="id" title="constructor">c</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Empty_set"><span class="id" title="inductive">Empty_set</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#Empty"><span class="id" title="inductive">Empty</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Empty_is_empty"><span class="id" title="lemma">Empty_is_empty</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">empty</span> : <a class="idref" href="R2.html#Empty"><span class="id" title="inductive">Empty</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">empty</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">e</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Okazuje się, że nie. Pustość i niepustość jest kwestią czegoś więcej,
    niż tylko ilości konstruktorów. Powyższy przykład pokazuje dobitnie,
    że ważne są też typy argumentów konstruktorów. Jeżeli typ któregoś z
    argumentów konstruktora jest pusty, to nie można użyć go do zrobienia
    żadnego termu. Jeżeli każdy konstruktor typu <span class="inlinecode"><span class="id" title="var">T</span></span> ma argument, którego
    typ jest pusty, to sam typ <span class="inlinecode"><span class="id" title="var">T</span></span> również jest pusty.

<div class="paragraph"> </div>

    Wobec powyższych rozważań możemy sformułować następujące kryterium:
    typ <span class="inlinecode"><span class="id" title="var">T</span></span> jest niepusty, jeżeli ma co najmniej jeden konstruktor, który
    nie bierze argumentów, których typy są puste. Jakkolwiek jest to bardzo
    dobre kryterium, to jednak nie rozwiewa ono niestety wszystkich możliwych
    wątpliwości. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="InfiniteList"><span class="id" title="inductive">InfiniteList</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="InfiniteCons"><span class="id" title="constructor">InfiniteCons</span></a> : <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#InfiniteList"><span class="id" title="inductive">InfiniteList</span></a> <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#InfiniteList"><span class="id" title="inductive">InfiniteList</span></a> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
Czy typ <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest niepusty? Skorzystajmy z naszego kryterium:
    ma on jeden konstruktor biorący dwa argumenty, jeden typu <span class="inlinecode"><span class="id" title="var">A</span></span> oraz drugi
    typu <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>. W zależności od tego, czym jest <span class="inlinecode"><span class="id" title="var">A</span></span>, może on być
    pusty lub nie — przyjmijmy, że <span class="inlinecode"><span class="id" title="var">A</span></span> jest niepusty. W przypadku drugiego
    argumentu napotykamy jednak na problem: to, czy <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest
    niepusty zależy od tego, czy typ argumentu jego konstruktora, również
    <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, jest niepusty. Sytuacja jest więc beznadziejna — mamy
    błędne koło.

<div class="paragraph"> </div>

    Powyższy przykład pokazuje, że nasze kryterium może nie poradzić sobie
    z rekurencją. Jak zatem rozstrzygnąć, czy typ ten jest niepusty? Musimy
    odwołać się bezpośrednio do definicji i zastanowić się, czy możliwe jest
    skonstruowanie jakichś jego termów. W tym celu przypomnijmy, czym są typy
    induktywne:
<ul class="doclist">
<li> Typ induktywny to rodzaj planu, który pokazuje, w jaki sposób można
      konstruować jego termy, które są drzewami.

</li>
<li> Konstruktory to węzły drzewa. Ich nazwy oraz ilość i typy argumentów
      nadają drzewu kształt i znaczenie.

</li>
<li> Konstruktory nierekurencyjne to liście drzewa.

</li>
<li> Konstruktory rekurencyjne to węzły wewnętrzne drzewa. 
</li>
</ul>

<div class="paragraph"> </div>

 Kluczowym faktem jest rozmiar termów: o ile rozgałęzienia mogą być
    potencjalnie nieskończone, o tyle wszystkie gałęzie muszą mieć
    skończoną długość. Pociąga to za sobą bardzo istotny fakt: typy
    mające jedynie konstruktory rekurencyjne są puste, gdyż bez użycia
    konstruktorów nierekurencyjnych możemy konstruować jedynie drzewa
    nieskończone (i to tylko przy nierealnym założeniu, że możliwe jest
    zakończenie konstrukcji liczącej sobie nieskończoność kroków). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="InfiniteList_is_empty"><span class="id" title="lemma">InfiniteList_is_empty</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#InfiniteList"><span class="id" title="inductive">InfiniteList</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">h</span> <span class="id" title="var">t</span>]. <span class="id" title="tactic">exact</span> <span class="id" title="var">IHt</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pokazanie, że <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest pusty, jest bardzo proste —
    wystarczy posłużyć się indukcją. Indukcja po <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    daje nam hipotezę indukcyjną <span class="inlinecode"><span class="id" title="var">IHt</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">False</span></span>, której możemy użyć,
    aby natychmiast zakończyć dowód.

<div class="paragraph"> </div>

    Zaraz, co właściwie się stało? Dlaczego dostaliśmy zupełnie za darmo
    hipotezę <span class="inlinecode"><span class="id" title="var">IHt</span></span>, która jest szukanym przez nas dowodem? W ten właśnie
    sposób przeprowadza się dowody indukcyjne: zakładamy, że hipoteza <span class="inlinecode"><span class="id" title="var">P</span></span>
    zachodzi dla termu <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">InfiniteList</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a następnie musimy pokazać,
    że <span class="inlinecode"><span class="id" title="var">P</span></span> zachodzi także dla termu <span class="inlinecode"><span class="id" title="var">InfiniteCons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>. Zazwyczaj <span class="inlinecode"><span class="id" title="var">P</span></span> jest
    predykatem i wykonanie kroku indukcyjnego jest nietrywialne, w naszym
    przypadku jest jednak inaczej — postać <span class="inlinecode"><span class="id" title="var">P</span></span> jest taka sama dla <span class="inlinecode"><span class="id" title="var">t</span></span> oraz
    dla <span class="inlinecode"><span class="id" title="var">InfiniteCons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> i jest nią <span class="inlinecode"><span class="id" title="var">False</span></span>.

<div class="paragraph"> </div>

    Czy ten konfundujący fakt nie oznacza jednak, że <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>, czyli typ
    zwykłych list, również jest pusty? Spróbujmy pokazać, że tak jest. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="list_empty"><span class="id" title="lemma">list_empty</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>), <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">h</span> <span class="id" title="var">t</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Focus</span> 2. <span class="id" title="tactic">exact</span> <span class="id" title="var">IHt</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Pokazanie, że typ <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest pusty, jest rzecz jasna niemożliwe,
    gdyż typ ten zdecydowanie pusty nie jest — w jego definicji stoi
    jak byk napisane, że dla dowolnego typu <span class="inlinecode"><span class="id" title="var">A</span></span> istnieje lista termów
    typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Jest nią oczywiście <span class="inlinecode">@<span class="id" title="var">nil</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>.

<div class="paragraph"> </div>

    Przyjrzyjmy się naszej próbie dowodu. Próbujemy posłużyć się indukcją
    w ten sam sposób co poprzednio. Taktyka <span class="inlinecode"><span class="id" title="tactic">induction</span></span> generuje nam dwa
    podcele, gdyż <span class="inlinecode"><span class="id" title="var">list</span></span> ma dwa konstruktory — pierwszy podcel dla <span class="inlinecode"><span class="id" title="var">nil</span></span>,
    a drugi dla <span class="inlinecode"><span class="id" title="var">cons</span></span>. Komenda <span class="inlinecode"><span class="id" title="var">Focus</span></span> pozwala nam przełączyć się do
    wybranego celu, w tym przypadku celu nr 2, czyli gdy <span class="inlinecode"><span class="id" title="var">l</span></span> jest postaci
    <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>.

<div class="paragraph"> </div>

    Sprawa wygląda identycznie jak poprzednio — za darmo dostajemy hipotezę
    <span class="inlinecode"><span class="id" title="var">IHt</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">False</span></span>, której używamy do natychmiastowego rozwiązania naszego
    celu. Tym, co stanowi przeszkodę nie do pokonania, jest cel nr 1, czyli
    gdy <span class="inlinecode"><span class="id" title="var">l</span></span> zrobiono za pomocą konstruktora <span class="inlinecode"><span class="id" title="var">nil</span></span>. Ten konstruktor nie jest
    rekurencyjny, więc nie dostajemy żadnej hipotezy indukcyjnej. Lista <span class="inlinecode"><span class="id" title="var">l</span></span>
    zostaje w każdym miejscu, w którym występuje, zastąpiona przez <span class="inlinecode">[]</span>, a
    ponieważ nie występuje nigdzie — znika. Musimy teraz udowodnić fałsz
    wiedząc jedynie, że <span class="inlinecode"><span class="id" title="var">A</span></span> jest typem, co jest niemożliwe. 
<div class="paragraph"> </div>

<a name="lab100"></a><h1 class="section">Induktywne zdania i predykaty</h1>

<div class="paragraph"> </div>

 Wiemy, że słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> pozwala nam definiować nowe typy
    (a nawet rodziny typów, jak w przypadku <span class="inlinecode"><span class="id" title="var">option</span></span>). Wiemy też, że zdania
    są typami. Wobec tego nie powinno nas dziwić, że induktywnie możemy
    definiować także zdania, spójniki logiczne, predykaty oraz relacje. 
<div class="paragraph"> </div>

<a name="lab101"></a><h2 class="section">Induktywne zdania</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="false_prop"><span class="id" title="inductive">false_prop</span></a> : <span class="id" title="keyword">Prop</span> := .<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="true_prop"><span class="id" title="inductive">true_prop</span></a> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="obvious_proof"><span class="id" title="constructor">obvious_proof</span></a> : <a class="idref" href="R2.html#true_prop"><span class="id" title="inductive">true_prop</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="tricky_proof"><span class="id" title="constructor">tricky_proof</span></a> : <a class="idref" href="R2.html#true_prop"><span class="id" title="inductive">true_prop</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="weird_proof"><span class="id" title="constructor">weird_proof</span></a> : <a class="idref" href="R2.html#true_prop"><span class="id" title="inductive">true_prop</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="magical_proof"><span class="id" title="constructor">magical_proof</span></a> : <a class="idref" href="R2.html#true_prop"><span class="id" title="inductive">true_prop</span></a>.<br/>

<br/>
</div>

<div class="doc">
Induktywne definicje zdań nie są zbyt ciekawe, gdyż pozwalają definiować
    jedynie zdania fałszywe (zero konstruktorów) lub prawdziwe (jeden lub
    więcej konstruktorów). Pierwsze z naszych zdań jest fałszywe (a więc
    rónoważne z <span class="inlinecode"><span class="id" title="var">False</span></span>), drugie zaś jest prawdziwe (czyli równoważne z <span class="inlinecode"><span class="id" title="var">True</span></span>)
    i to na cztery sposoby! 
<div class="paragraph"> </div>

<a name="lab102"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <a name="false_prop_iff_False"><span class="id" title="lemma">false_prop_iff_False</span></a> : <a class="idref" href="R2.html#false_prop"><span class="id" title="inductive">false_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="true_prop_iff_True"><span class="id" title="lemma">true_prop_iff_True</span></a> : <a class="idref" href="R2.html#true_prop"><span class="id" title="inductive">true_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab103"></a><h2 class="section">Induktywne predykaty</h2>

<div class="paragraph"> </div>

 Przypomnijmy, że predykaty to funkcje, których przeciwdziedziną jest
    sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, czyli funkcje zwracające zdania logiczne. Predykat
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> można rozumieć jako właściwość, którą mogą posiadać
    termy typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś dla konkretnego <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> zapis <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> interpretować
    można "term <span class="inlinecode"><span class="id" title="var">x</span></span> posiada właściwóść <span class="inlinecode"><span class="id" title="var">P</span></span>".

<div class="paragraph"> </div>

    O ile istnieją tylko dwa rodzaje induktwynych zdań (prawdziwe i fałszywe),
    o tyle induktywnie zdefiniowane predykaty są dużo bardziej ciekawe i
    użyteczne, gdyż dla jednych termów mogą być prawdziwe, a dla innych nie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="even"><span class="id" title="inductive">even</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="even0"><span class="id" title="constructor">even0</span></a> : <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="evenSS"><span class="id" title="constructor">evenSS</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>)).<br/>

<br/>
</div>

<div class="doc">
Predykat <span class="inlinecode"><span class="id" title="var">even</span></span> ma oznaczać właściwość "bycia liczbą parzystą". Jego
    definicję można zinterpretować tak:
<ul class="doclist">
<li> "<span class="inlinecode">0</span> jest liczbą przystą"

</li>
<li> "jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest liczbą parzystą, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> również jest
       liczbą parzystą" 
</li>
</ul>

<div class="paragraph"> </div>

 Jak widać, induktywna definicja parzystości różni się od powszechnie
    używanej definicji, która głosi, że "liczba jest parzysta, gdy
    dzieli się bez reszty przez 2". Różnica jest natury filozoficznej:
    definicja induktywna mówi, jak konstruować liczby parzyste, podczas
    gdy druga, "klasyczna" definicja mówi, jak sprawdzić, czy liczba
    jest parzysta.

<div class="paragraph"> </div>

    Przez wzgląd na swą konstruktywność, w Coqu induktywne definicje
    predykatów czy relacji są często dużo bardziej użyteczne od tych
    nieinduktywnych, choć nie wszystko można zdefiniować induktywnie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="zero_is_even"><span class="id" title="lemma">zero_is_even</span></a> : <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="R2.html#even0"><span class="id" title="constructor">even0</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak możemy udowodnić, że <span class="inlinecode">0</span> jest liczbą parzystą? Posłuży nam
    do tego konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>, który wprost głosi, że <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>.
    Nie daj się zwieść: <span class="inlinecode"><span class="id" title="var">even0</span></span>, pisane bez spacji, jest nazwą
    konstruktora, podczas gdy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>, ze spacją, jest zdaniem
    (czyli termem typu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>), które można interpretować jako
    "<span class="inlinecode">0</span> jest liczbą parzystą". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="two_is_even"><span class="id" title="lemma">two_is_even</span></a> : <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> 2.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="R2.html#evenSS"><span class="id" title="constructor">evenSS</span></a>. <span class="id" title="tactic">apply</span> <a class="idref" href="R2.html#even0"><span class="id" title="constructor">even0</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak możemy udowodnić, że <span class="inlinecode">2</span> jest parzyste? Konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>
    nam nie pomoże, gdyż jego postać (<span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span>) nie pasuje do postaci
    naszego twierdzenia (<span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">2</span>). Pozostaje nam jednak konstruktor
    <span class="inlinecode"><span class="id" title="var">evenSS</span></span>.

<div class="paragraph"> </div>

    Jeżeli przypomnimy sobie, że <span class="inlinecode">2</span> to tak naprawdę <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span>,
    natychmiast dostrzeżemy, że jego konkluzja pasuje do postaci naszego
    twierdzenia. Możemy go więc zaaplikować (pamiętaj, że konstruktory są
    jak zwykłe funkcje, tylko że niczego nie obliczają — nadają one typom
    ich kształty). Teraz wystarczy pokazać, że <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">0</span> zachodzi, co już
    potrafimy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="four_is_even"><span class="id" title="lemma">four_is_even</span></a> : <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> 4.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak pokazać, że <span class="inlinecode">4</span> jest parzyste? Tą samą metodą, która pokazaliśmy,
    że <span class="inlinecode">2</span> jest parzyste. <span class="inlinecode">4</span> to <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)))</span>, więc możemy użyć
    konstruktora <span class="inlinecode"><span class="id" title="var">evenSS</span></span>. Zamiast jednak pisać <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, możemy
    użyć taktyki <span class="inlinecode"><span class="id" title="tactic">constructor</span></span>. Taktyka ta działa na celach, w których
    chcemy skonstruować wartość jakiegoś typu induktywnego (a więc także
    gdy dowodzimy twierdzeń o induktywnych predykatach). Szuka ona
    konstruktora, który może zaaplikować na celu, i jeżeli znajdzie, to
    aplikuje go, a gdy nie — zawodzi.

<div class="paragraph"> </div>

    W naszym przypadku pierwsze dwa użycia <span class="inlinecode"><span class="id" title="tactic">constructor</span></span> aplikują
    konstruktor <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, a trzecie — konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="the_answer_is_even"><span class="id" title="lemma">the_answer_is_even</span></a> : <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A co, gdy chcemy pokazać, że <span class="inlinecode">42</span> jest parzyste? Czy musimy 22 razy
    napisać <span class="inlinecode"><span class="id" title="tactic">constructor</span></span>? Na szczęście nie — wystarczy posłużyć się
    kombinatorem <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> (jeżeli nie pamiętasz, jak działa, zajrzyj do
    rozdziału 1). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="one_not_even_failed"><span class="id" title="lemma">one_not_even_failed</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="one_not_even"><span class="id" title="lemma">one_not_even</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A jak pokazać, że <span class="inlinecode">1</span> nie jest parzyste? Mając w kontekście dowód
    na to, że <span class="inlinecode">1</span> jest parzyste (<span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">1</span>), możemy zastantowić się,
    w jaki sposób dowód ten został zrobiony. Nie mógł zostać zrobiony
    konstruktorem <span class="inlinecode"><span class="id" title="var">even0</span></span>, gdyż ten dowodzi, że <span class="inlinecode">0</span> jest parzyste, a
    przecież przekonaliśmy się już, że <span class="inlinecode">0</span> to nie <span class="inlinecode">1</span>. Nie mógł też
    zostać zrobiony konstruktorem <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, gdyż ten ma w konkluzji
    <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>, podczas gdy <span class="inlinecode">1</span> jest postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span> — nie pasuje
    on do konkluzji <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, gdyż "ma za mało <span class="inlinecode"><span class="id" title="var">S</span></span>ów".

<div class="paragraph"> </div>

    Nasze rozumowanie prowadzi do wniosku, że za pomocą <span class="inlinecode"><span class="id" title="var">even0</span></span> i <span class="inlinecode"><span class="id" title="var">evenSS</span></span>,
    które są jedynymi konstruktorami <span class="inlinecode"><span class="id" title="var">even</span></span>, nie można skonstruować <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">1</span>,
    więc <span class="inlinecode">1</span> nie może być parzyste. Na podstawie wcześniejszych doświadczeń
    mogłoby się nam wydawać, że <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> załatwi sprawę, jednak tak nie
    jest — taktyka ta jest w tym przypadku upośledzona i nie potrafi nam
    pomóc. Zamiast tego możemy się posłużyć taktyką <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>. Działa ona
    dokładnie w sposób opisany w poprzednim akapicie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="three_not_even"><span class="id" title="lemma">three_not_even</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> 3.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H1</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jak pokazać, że <span class="inlinecode">3</span> nie jest parzyste? Pomoże nam w tym, jak poprzednio,
    inwersja. Tym razem jednak nie załatwia ona sprawy od razu. Jeżeli
    zastanowimy się, jak można pokazać <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">3</span>, to dojdziemy do wniosku,
    że można to zrobić konstruktorem <span class="inlinecode"><span class="id" title="var">evenSS</span></span>, gdyż <span class="inlinecode">3</span> to tak naprawdę
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">1)</span>. To właśnie robi pierwsza inwersja: mówi nam, że <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">3</span>
    można uzyskać z zaaplikowania <span class="inlinecode"><span class="id" title="var">evenSS</span></span> do <span class="inlinecode">1</span>, jeżeli tylko mamy dowód
    <span class="inlinecode"><span class="id" title="var">H1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">1</span> na to, że <span class="inlinecode">1</span> jest parzyste. Jak pokazać, że <span class="inlinecode">1</span> nie
    jest parzyste, już wiemy. 
<div class="paragraph"> </div>

<a name="lab104"></a><h4 class="section">Ćwiczenie.</h4>
 Zdefiniuj induktywny predykat <span class="inlinecode"><span class="id" title="var">odd</span></span>, który ma oznaczać "bycie liczbą
    nieparzystą" i udowodnij, że zachowuje się on jak należy. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="one_odd"><span class="id" title="lemma">one_odd</span></a> : <a class="idref" href="R2.html#odd"><span class="id" title="inductive">odd</span></a> 1.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="seven_odd"><span class="id" title="lemma">seven_odd</span></a> : <a class="idref" href="R2.html#odd"><span class="id" title="inductive">odd</span></a> 7.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="zero_not_odd"><span class="id" title="lemma">zero_not_odd</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="R2.html#odd"><span class="id" title="inductive">odd</span></a> 0.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="two_not_odd"><span class="id" title="lemma">two_not_odd</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="R2.html#odd"><span class="id" title="inductive">odd</span></a> 2.<br/>

<br/>
</div>

<div class="doc">
<a name="lab105"></a><h4 class="section">Ćwiczenie (chyba trudne).</h4>
 To ćwiczenie dotyczy bardziej kombinatorów taktyk i automatyzacji,
    niż definicji induktywnych. Przydać mogą ci się następujące taktyki,
    których dotąd nie omawialiśmy:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="tactic">clear</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> usuwa <span class="inlinecode"><span class="id" title="var">x</span></span> z kontekstu (jeżeli mieliśmy w kontekście <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>,
      to teraz już go nie ma) lub zawodzi, gdy <span class="inlinecode"><span class="id" title="var">x</span></span> nie ma w kontekście

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">rename</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">into</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> zmienia nazwę <span class="inlinecode"><span class="id" title="var">x</span></span> na <span class="inlinecode"><span class="id" title="var">y</span></span> (jeżeli mieliśmy w
      kontekście <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, to teraz zamiast tego będziemy mieli <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>)
      lub zawodzi, gdy <span class="inlinecode"><span class="id" title="var">x</span></span> nie ma w kontekście albo nazwa <span class="inlinecode"><span class="id" title="var">y</span></span> jest już
      zajęta 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="satans_neighbour_not_even"><span class="id" title="lemma">satans_neighbour_not_even</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> 667.<br/>

<br/>
</div>

<div class="doc">
<a name="lab106"></a><h2 class="section">Indukcja po dowodzie</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Arith.html#"><span class="id" title="library">Arith</span></a>.<br/>

<br/>
</div>

<div class="doc">
Biblioteka <span class="inlinecode"><span class="id" title="var">Arith</span></span> zawiera różne definicje i twierdzenia dotyczące
    arytmetyki. Będzie nam ona potrzebna w tym podrozdziale.

<div class="paragraph"> </div>

    Jak udowodnić, że suma liczb parzystych jest parzysta? Być może
    właśnie pomyślałeś o indukcji. Spróbujmy zatem: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="even_sum_failed1"><span class="id" title="lemma">even_sum_failed1</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> (<a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>]; <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Plus.html#plus_comm"><span class="id" title="abbreviation">plus_comm</span></a>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Plus.html#plus_comm"><span class="id" title="abbreviation">plus_comm</span></a>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHn'</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Próbując jednak indukcji po <span class="inlinecode"><span class="id" title="var">n</span></span>, a potem po <span class="inlinecode"><span class="id" title="var">m</span></span>, docieramy do martwego
    punktu. Musimy udowodnić <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>, podczas gdy zachodzi <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>
    (czyli <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> jest fałszywe). Wynika to z faktu, że przy indukcji
    <span class="inlinecode"><span class="id" title="var">n</span></span> zwiększa się o 1 (<span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>), podczas gdy w definicji
    <span class="inlinecode"><span class="id" title="var">even</span></span> mamy konstruktor głoszący, że (<span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>).

<div class="paragraph"> </div>

    Być może w drugiej kolejności pomyślałeś o taktyce <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>: jeżeli
    sprawdzimy, w jaki sposób udowodniono <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, to przy okazji dowiemy
    się też, że <span class="inlinecode"><span class="id" title="var">n</span></span> może być jedynie postaci <span class="inlinecode">0</span> lub <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>. Dzięki
    temu powinniśmy uniknąć problemu z poprzedniej próby. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="even_sum_failed2"><span class="id" title="lemma">even_sum_failed2</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> (<a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">Hn</span> <span class="id" title="var">Hm</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">Hn</span>, <span class="id" title="var">Hm</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Plus.html#plus_comm"><span class="id" title="abbreviation">plus_comm</span></a>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Plus.html#plus_comm"><span class="id" title="abbreviation">plus_comm</span></a>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Niestety, taktyka <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> okazała się za słaba. Predykat <span class="inlinecode"><span class="id" title="var">even</span></span> jest
    induktywny, a zatem bez indukcji się nie obędzie. Rozwiązaniem naszych
    problemów nie będzie jednak indukcja po <span class="inlinecode"><span class="id" title="var">n</span></span> lub <span class="inlinecode"><span class="id" title="var">m</span></span>, lecz po dowodzie na
    to, że <span class="inlinecode"><span class="id" title="var">n</span></span> jest parzyste. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="even_sum"><span class="id" title="lemma">even_sum</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> (<a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">Hn</span> <span class="id" title="var">Hm</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">Hn</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span> <span class="id" title="var">Hn'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Indukcja po dowodzie działa dokładnie tak samo, jak indukcja, z którą
    zetknęliśmy się dotychczas. Różni się od niej jedynie tym, że aż do
    teraz robiliśmy indukcję jedynie po termach, których typy były sortu
    <span class="inlinecode"><span class="id" title="keyword">Set</span></span> lub <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Indukcja po dowodzie to indukcja po termie, którego
    typ jest sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

    W naszym przypadku użycie <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">Hn</span></span> ma następujący skutek:
<ul class="doclist">
<li> W pierwszym przypadku <span class="inlinecode"><span class="id" title="var">Hn</span></span> to po prostu konstruktor <span class="inlinecode"><span class="id" title="var">even0</span></span>, a 
      zatem <span class="inlinecode"><span class="id" title="var">n</span></span> jest zerem.

</li>
<li> W drugim przypadku <span class="inlinecode"><span class="id" title="var">Hn</span></span> to <span class="inlinecode"><span class="id" title="var">evenSS</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="var">Hn'</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">n</span></span> jest postaci
      <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>, zaś <span class="inlinecode"><span class="id" title="var">Hn'</span></span> jest dowodem na to, że <span class="inlinecode"><span class="id" title="var">n'</span></span> jest parzyste. 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab107"></a><h3 class="section">Taktyki <span class="inlinecode"><span class="id" title="tactic">replace</span></span> i <span class="inlinecode"><span class="id" title="tactic">assert</span></span>.</h3>
 Przy następnych ćwiczeniach mogą przydać ci się taktyki <span class="inlinecode"><span class="id" title="tactic">replace</span></span>
    oraz <span class="inlinecode"><span class="id" title="tactic">assert</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="stupid_example_replace"><span class="id" title="lemma">stupid_example_replace</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">replace</span> (<span class="id" title="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 0) <span class="id" title="keyword">with</span> (0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Plus.html#plus_comm"><span class="id" title="abbreviation">plus_comm</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">replace</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">t'</span></span> pozwala nam zastąpić w celu każde
    wystąpienie termu <span class="inlinecode"><span class="id" title="var">t</span></span> termem <span class="inlinecode"><span class="id" title="var">t'</span></span>. Jeżeli <span class="inlinecode"><span class="id" title="var">t</span></span> nie ma w celu, to
    taktyka zawodzi, a w przeciwnym wypadku dodaje nam jeden podcel,
    w którym musimy udowodnić, że <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">t'</span></span>. Można też zastosować ją
    w hipotezie, pisząc <span class="inlinecode"><span class="id" title="tactic">replace</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">t'</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="stupid_example_assert"><span class="id" title="lemma">stupid_example_assert</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Plus.html#plus_0_r"><span class="id" title="abbreviation">plus_0_r</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">assert</span></span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> dodaje do kontekstu term <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span> oraz
    generuje jeden dodatkowy podcel, w którym musimy skonstruować <span class="inlinecode"><span class="id" title="var">x</span></span>.
    Zawodzi ona, jeżeli nazwa <span class="inlinecode"><span class="id" title="var">x</span></span> jest już zajęta. 
<div class="paragraph"> </div>

<a name="lab108"></a><h4 class="section">Ćwiczenie</h4>
 Udowodnij poniższe twierdzenia. Zanim zaczniesz, zastanów się, po czym
    należy przeprowadzić indukcję: po wartości, czy po dowodzie? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="double_is_even"><span class="id" title="lemma">double_is_even</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> (2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="even_is_double"><span class="id" title="lemma">even_is_double</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="R2.html#k"><span class="id" title="variable">k</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab109"></a><h2 class="section">Definicje stałych i spójników logicznych</h2>

<div class="paragraph"> </div>

 W rozdziale pierwszym dowiedzieliśmy się, że produkt zależny (typ,
    którego termami są funkcje zależne), a więc i implikacja, jest
    typem podstawowym/wbudowanym oraz że negacja jest zdefiniowana jako
    implikowanie fałszu. Teraz, gdy wiemy już co nieco o typach induktywnych,
    nadszedł czas by zapoznać się z definicjami spójników logicznych (i nie
    tylko). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="MyConnectives"><span class="id" title="module">MyConnectives</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab110"></a><h3 class="section">Prawda i fałsz</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="MyConnectives.False"><span class="id" title="inductive">False</span></a> : <span class="id" title="keyword">Prop</span> := .<br/>

<br/>
</div>

<div class="doc">
Fałsz nie ma żadnych konstruktorów, a zatem nie może zostać w żaden
    sposób skonstruowany, czyli udowodniony. Jego definicja jest bliźniaczo
    podobna do czegoś, co już kiedyś widzieliśmy — tym czymś był <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>,
    czyli typ pusty. Nie jest to wcale przypadek. Natknęliśmy się (znowu) na
    przykład korespondencji Curry'ego-Howarda.

<div class="paragraph"> </div>

    Przypomnijmy, że głosi ona (w sporym uproszczeniu), iż sorty <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>
    i <span class="inlinecode"><span class="id" title="keyword">Set</span></span>/<span class="inlinecode"><span class="id" title="keyword">Type</span></span> są do siebie bardzo podobne. Jednym z tych podobieństw
    było to, że dowody implikacji są funkcjami. Kolejnym jest fakt, że
    <span class="inlinecode"><span class="id" title="var">False</span></span> jest odpowiednikiem <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, od którego różni się tym, że
    żyje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a nie w <span class="inlinecode"><span class="id" title="keyword">Set</span></span>.

<div class="paragraph"> </div>

    Ta definicja rzuca też trochę światła na sposób wnioskowania "ex falso
    quodlibet" (z fałszu wynika wszystko), który poznaliśmy w rozdziale
    pierwszym.

<div class="paragraph"> </div>

    Użycie taktyki <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> lub <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> na termie dowolnego typu
    induktywnego to sprawdzenie, którym konstruktorem term ten został
    zrobiony — generują one dokładnie tyle podcelów, ile jest możliwych
    konstruktorów. Użycie ich na termie typu <span class="inlinecode"><span class="id" title="var">False</span></span> generuje zero
    podcelów, co ma efekt natychmiastowego zakończenia dowodu. Dzięki
    temu mając dowód <span class="inlinecode"><span class="id" title="var">False</span></span> możemy udowodnić cokolwiek. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="MyConnectives.True"><span class="id" title="inductive">True</span></a> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MyConnectives.I"><span class="id" title="constructor">I</span></a> : <a class="idref" href="R2.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">True</span></span> jest odpowiednikiem <span class="inlinecode"><span class="id" title="var">unit</span></span>, od którego różni się tym, że żyje
    w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a nie w <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Ma dokładnie jeden dowód, który w Coqu
    nazwano, z zupełnie nieznanych powodów (zapewne dla hecy), <span class="inlinecode"><span class="id" title="var">I</span></span>. 
<div class="paragraph"> </div>

<a name="lab111"></a><h3 class="section">Koniunkcja i dysjunkcja</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="MyConnectives.and"><span class="id" title="inductive">and</span></a> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MyConnectives.conj"><span class="id" title="constructor">conj</span></a> : <span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#and"><span class="id" title="inductive">and</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód koniunkcji zdań <span class="inlinecode"><span class="id" title="var">P</span></span> i <span class="inlinecode"><span class="id" title="var">Q</span></span> to para dowodów: pierwszy element
    pary jest dowodem <span class="inlinecode"><span class="id" title="var">P</span></span>, zaś drugi dowodem <span class="inlinecode"><span class="id" title="var">Q</span></span>. Koniunkcja jest
    odpowiednkiem produktu, od którego różni się tym, że żyje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>,
    a nie w <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="MyConnectives.or"><span class="id" title="inductive">or</span></a> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MyConnectives.or_introl"><span class="id" title="constructor">or_introl</span></a> : <span class="id" title="var">P</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#or"><span class="id" title="inductive">or</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MyConnectives.or_intror"><span class="id" title="constructor">or_intror</span></a> : <span class="id" title="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#or"><span class="id" title="inductive">or</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>.<br/>

<br/>
</div>

<div class="doc">
Dowód dysjunkcji zdań <span class="inlinecode"><span class="id" title="var">P</span></span> i <span class="inlinecode"><span class="id" title="var">Q</span></span> to dowód <span class="inlinecode"><span class="id" title="var">P</span></span> albo dowód <span class="inlinecode"><span class="id" title="var">Q</span></span> wraz ze
    wskazaniem, którego zdania jest to dowód. Dysjunkcja jest odpowiednikiem
    sumy, od której różni się tym, że żyje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a nie w <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#MyConnectives"><span class="id" title="module">MyConnectives</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab112"></a><h2 class="section">Równość</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="MyEq"><span class="id" title="module">MyEq</span></a>.<br/>

<br/>
</div>

<div class="doc">
Czym jest równość? To pytanie stawiało sobie wielu filozofów,
    szczególnie politycznych, a także ekonomistów. Odpowiedź na
    nie jest jednym z największych osiągnięć matematyki w dziejach:
    równość to jeden z typów induktywnych, które możemy zdefiniować
    w Coqu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="MyEq.eq"><span class="id" title="inductive">eq</span></a> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>) : <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MyEq.eq_refl"><span class="id" title="constructor">eq_refl</span></a> : <a class="idref" href="R2.html#eq"><span class="id" title="inductive">eq</span></a> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Spróbujmy przeczytać tę definicję: dla danego typu <span class="inlinecode"><span class="id" title="var">A</span></span> oraz termu
    <span class="inlinecode"><span class="id" title="var">x</span></span> tego typu, <span class="inlinecode"><span class="id" title="var">eq</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> jest predykatem, który ma jeden konstruktor
    głoszący, że <span class="inlinecode"><span class="id" title="var">eq</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> zachodzi. Choć definicja taka brzmi obco i
    dziwacznie, ma ona swoje uzasadnienie (które niestety poznamy
    dopiero w przyszłości). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyEq.eq_refl_trivial"><span class="id" title="lemma">eq_refl_trivial</span></a> : <a class="idref" href="R2.html#MyEq.eq"><span class="id" title="inductive">eq</span></a> 42 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="R2.html#MyEq.eq_refl"><span class="id" title="constructor">eq_refl</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Poznane przez nas dotychczas taktyki potrafiące udowadniać proste
    równości, jak <span class="inlinecode"><span class="id" title="tactic">trivial</span></span> czy <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> działają w ten sposób,
    że po prostu aplikują na celu <span class="inlinecode"><span class="id" title="var">eq_refl</span></span>. Nazwa <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> to skrót
    od ang. "reflexivity of equality", czyli "zwrotność równości" —
    jest to najważniejsza cecha równości, która oznacza, że każdy term
    jest równy samemu sobie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyEq.eq_refl_nontrivial"><span class="id" title="lemma">eq_refl_nontrivial</span></a> : <a class="idref" href="R2.html#MyEq.eq"><span class="id" title="inductive">eq</span></a> (1 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 41) 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Mogłoby wydawać się, że zwrotność nie wystarcza do udowadniania
    "nietrywialnych" równości pokroju <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">41</span> <span class="inlinecode">=</span> <span class="inlinecode">42</span>, jednak tak nie jest.
    Dlaczego <span class="inlinecode"><span class="id" title="var">eq_refl</span></span> odnosi na tym celu sukces skoro <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">41</span> oraz <span class="inlinecode">42</span>
    zdecydowanie różnią się postacią? Odpowiedź jest prosta: typ <span class="inlinecode"><span class="id" title="var">eq</span></span> w
    rzeczywistości owija jedynie równość pierwotną, wbudowaną w samo jądro
    Coqa, którą jest konwertowalność. 

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyEq.eq_refl_alpha"><span class="id" title="lemma">eq_refl_alpha</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#MyEq.eq"><span class="id" title="inductive">eq</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> =&gt; <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> =&gt; <a class="idref" href="R2.html#y"><span class="id" title="variable">y</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">change</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="keyword">with</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <a class="idref" href="R2.html#y"><span class="id" title="variable">y</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="R2.html#MyEq.eq_refl"><span class="id" title="constructor">eq_refl</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyEq.eq_refl_beta"><span class="id" title="lemma">eq_refl_beta</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#MyEq.eq"><span class="id" title="inductive">eq</span></a> ((<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>) <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>) (<a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="R2.html#MyEq.eq_refl"><span class="id" title="constructor">eq_refl</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="MyEq.ultimate_answer"><span class="id" title="definition">ultimate_answer</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> := 42.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyEq.eq_refl_delta"><span class="id" title="lemma">eq_refl_delta</span></a> : <a class="idref" href="R2.html#MyEq.eq"><span class="id" title="inductive">eq</span></a> <a class="idref" href="R2.html#MyEq.ultimate_answer"><span class="id" title="definition">ultimate_answer</span></a> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="R2.html#MyEq.ultimate_answer"><span class="id" title="definition">ultimate_answer</span></a>. <span class="id" title="tactic">apply</span> <a class="idref" href="R2.html#MyEq.eq_refl"><span class="id" title="constructor">eq_refl</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MyEq.eq_refl_iota"><span class="id" title="lemma">eq_refl_iota</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R2.html#MyEq.eq"><span class="id" title="inductive">eq</span></a> 42 (<span class="id" title="keyword">match</span> 0 <span class="id" title="keyword">with</span> | 0 =&gt; 42 | <span class="id" title="var">_</span> =&gt; 13 <span class="id" title="keyword">end</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="R2.html#MyEq.eq_refl"><span class="id" title="constructor">eq_refl</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Przypomnijmy, co już wiemy o redukcjach:
<ul class="doclist">
<li> konwersja alfa pozwala nam zmienić nazwę zmiennej związanej w
      funkcji anonimowej nową, jeżeli ta nie jest jeszcze używana.
      W naszym przykładzie zamieniamy <span class="inlinecode"><span class="id" title="var">x</span></span> w <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> na <span class="inlinecode"><span class="id" title="var">y</span></span>,
      otrzymując <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">y</span></span> — konwersja jest legalna. Jednak
      w funkcji <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">x</span></span> nie możemy użyć konwersji
      alfa, żeby zmienić nazwę <span class="inlinecode"><span class="id" title="var">x</span></span> na <span class="inlinecode"><span class="id" title="var">y</span></span>, bo <span class="inlinecode"><span class="id" title="var">y</span></span> jest już używana
      (tak nazywa się drugi argument).

</li>
<li> Redukcja beta zastępuje argumentem każde wystąpienie zmiennej
      związanej w funkcji anonimowej. W naszym przypadku redukcja
      ta zamienia <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="var">m</span></span> na <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> — w miejsce
      <span class="inlinecode"><span class="id" title="var">n</span></span> wstawiamy <span class="inlinecode"><span class="id" title="var">m</span></span>.

</li>
<li> Redukcja delta odwija definicje. W naszym przypadku zdefiniowaliśmy,
      że <span class="inlinecode"><span class="id" title="var">ultimate_answer</span></span> oznacza <span class="inlinecode">42</span>, więc redukcja delta w miejsce
      <span class="inlinecode"><span class="id" title="var">ultimate_answer</span></span> wstawia <span class="inlinecode">42</span>.

</li>
<li> Redukcja jota wykonuje pattern matching. W naszym przypadku <span class="inlinecode">0</span>
      jest termem, który postać jest znana (został on skonstruowany
      konstruktorem <span class="inlinecode">0</span>) i który pasuje do wzorca <span class="inlinecode">|</span> <span class="inlinecode">0</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">42</span>, a zatem
      redukcja jota zamienia całe wyrażenie od <span class="inlinecode"><span class="id" title="keyword">match</span></span> aż do <span class="inlinecode"><span class="id" title="keyword">end</span></span>
      na <span class="inlinecode">42</span>. 
</li>
</ul>

<div class="paragraph"> </div>

 Termy <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> są konwertowalne, gdy za pomocą konwersji alfa oraz
    redukcji beta, delta i jota można zredukować <span class="inlinecode"><span class="id" title="var">x</span></span> do <span class="inlinecode"><span class="id" title="var">y</span></span> lub <span class="inlinecode"><span class="id" title="var">y</span></span> do <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

    Uważny czytelnik zada sobie w tym momencie pytanie: skoro równość to
    konwertowalność, to jakim cudem równe są termy <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span>,
    które przecież nie są konwertowalne?

<div class="paragraph"> </div>

    TODO: udzielić odpowiedzi na to pytanie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#MyEq"><span class="id" title="module">MyEq</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab113"></a><h2 class="section">Indukcja wzajemna</h2>

<div class="paragraph"> </div>

 Jest jeszcze jeden rodzaj indukcji, o którym dotychczas nie mówiliśmy:
    indukcja wzajemna (ang. mutual induction). Bez zbędnego teoretyzowania
    zbadajmy sprawę na przykładzie klasyków polskiej literatury: 
<div class="paragraph"> </div>

 <i>Smok to wysuszony zmok</i> 
<div class="paragraph"> </div>

 <i>Zmok to zmoczony smok</i> 
<div class="paragraph"> </div>

 Stanisław Lem 
<div class="paragraph"> </div>

 Idea stojąca za indukcją wzajemną jest prosta: chcemy przez indukcję
    zdefiniować jednocześnie dwa obiekty, które mogą się nawzajem do siebie
    odwoływać.

<div class="paragraph"> </div>

    W owym definiowaniu nie mamy rzecz jasna pełnej swobody — obowiązują te
    same kryteria co w przypadku zwykłych, "pojedynczych" definicji typów
    induktywnych. Wobec tego zauważyć należy, że definicja słowa "smok"
    podana przez Lema jest według Coqowych standardów nieakceptowalna, gdyż
    jeżeli w definicji <i>smoka</i> rozwiniemy definicję <i>zmoka</i>, to otrzymamy

<div class="paragraph"> </div>

    <i>Smok ty wysuszony zmoczony smok</i> 
<div class="paragraph"> </div>

 Widać gołym okiem, iż próba zredukowania (czyli obliczenia) obieku
    <i>smok</i> nigdy się nie skończy. Jak już wiemy, niekończące się obliczenia
    w logice odpowiadają sprzeczności, a zatem ani <i>smoki</i>, ani <i>zmoki</i> w
    Coqowym świecie nie istnieją.

<div class="paragraph"> </div>

    Nie znaczy to bynajmniej, że wszystkie definicje przez indukcję
    wzajemną są w Coqu niepoprawne, choć należy przyznać, że są dość
    rzadko używane. Czas jednak abyśmy ujrzeli pierwszy prawdziwy przkład
    indukcji wzajemnej. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="MutInd"><span class="id" title="module">MutInd</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="MutInd.even"><span class="id" title="inductive">even</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MutInd.even0"><span class="id" title="constructor">even0</span></a> : <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MutInd.evenS"><span class="id" title="constructor">evenS</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#odd"><span class="id" title="inductive">odd</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>)<br/>
<br/>
<span class="id" title="keyword">with</span> <a name="MutInd.odd"><span class="id" title="inductive">odd</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MutInd.oddS"><span class="id" title="constructor">oddS</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#odd"><span class="id" title="inductive">odd</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>).<br/>

<br/>
</div>

<div class="doc">
Aby zrozumieć tę definicję, zestawmy ją z naszą definicją parzystości
    z sekcji <i>Induktywne predykaty</i>.

<div class="paragraph"> </div>

    Zdefiniowaliśmy tam predykat bycia liczbą parzystą tak:
<ul class="doclist">
<li> <span class="inlinecode">0</span> jest parzyste

</li>
<li> jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest parzyste, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> też jest parzyste 
</li>
</ul>

<div class="paragraph"> </div>

 Tym razem jednak nie definiujemy jedynie predykatu "jest liczbą parzystą".
    Definiujemy jednocześnie dwa predykaty: "jest liczbą parzystą" oraz
    "jest liczbą nieparzystą", które odwołują się do siebi nawzajm. Definicja
    brzmi tak:
<ul class="doclist">
<li> <span class="inlinecode">0</span> jest parzyste

</li>
<li> jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest nieparzyste, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> jest parzyste

</li>
<li> jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> jest parzyste, to <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> jest nieparzyste 
</li>
</ul>

<div class="paragraph"> </div>

 Czy definicja taka rzeczywiście ma sens? Sprawdźmy to:
<ul class="doclist">
<li> <span class="inlinecode">0</span> jest parzyste na mocy definicji

</li>
<li> jeżeli <span class="inlinecode">0</span> jest parzyste (a jest), to <span class="inlinecode">1</span> jest nieparzyste

</li>
<li> jeżeli <span class="inlinecode">1</span> jest nieparzyste (a jest), to <span class="inlinecode">2</span> jest parzyste

</li>
<li> i tak dalej, ad infiitum

</li>
</ul>

<div class="paragraph"> </div>

 Jak widać, za pomocą naszej wzajemnie induktywnej definicji <span class="inlinecode"><span class="id" title="var">even</span></span> można
    wygenerować wszystkie liczby parzyste (i tylko je), tak więc nowe <span class="inlinecode"><span class="id" title="var">even</span></span>
    jest równoważne staremu <span class="inlinecode"><span class="id" title="var">even</span></span> z sekcji <i>Induktywne predykaty</i>. Podobnie
    <span class="inlinecode"><span class="id" title="var">odd</span></span> może wygenerować wszystkie liczby nieparzyste i tylko je. 
<div class="paragraph"> </div>

<a name="lab114"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Upewnij się, że powyższy akapit nie kłamie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.even_0"><span class="id" title="lemma">even_0</span></a> : <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> 0.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.odd_1"><span class="id" title="lemma">odd_1</span></a> : <a class="idref" href="R2.html#MutInd.odd"><span class="id" title="inductive">odd</span></a> 1.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.even_2"><span class="id" title="lemma">even_2</span></a> : <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> 2.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.even_42"><span class="id" title="lemma">even_42</span></a> : <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> 42.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.not_odd_0"><span class="id" title="lemma">not_odd_0</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="R2.html#MutInd.odd"><span class="id" title="inductive">odd</span></a> 0.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.not_even_1"><span class="id" title="lemma">not_even_1</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> 1.<br/>

<br/>
</div>

<div class="doc">
<a name="lab115"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij podstawowe właściwości <span class="inlinecode"><span class="id" title="var">even</span></span> i <span class="inlinecode"><span class="id" title="var">odd</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.even_SS"><span class="id" title="lemma">even_SS</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.odd_SS"><span class="id" title="lemma">odd_SS</span></a> : <br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#MutInd.odd"><span class="id" title="inductive">odd</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.odd"><span class="id" title="inductive">odd</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.even_plus"><span class="id" title="lemma">even_plus</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> (<a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>).<br/>

<br/>
</div>

<div class="doc">
Jeśli poległeś przy ostatnim zadaniu — nie przejmuj się. Specjalnie
    dobrałem złośliwy przykład.

<div class="paragraph"> </div>

    W tym momencie należy sobie zadać pytanie: jak dowodzić właściwości
    typów wzajemnie induktywnych? Aby udzielić odpowiedzi, spróbujmy
    udowodnić <span class="inlinecode"><span class="id" title="var">even_plus</span></span> za pomocą indukcji po <span class="inlinecode"><span class="id" title="var">n</span></span>, a potem prześledźmy,
    co poszło nie tak. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.even_plus_failed_1"><span class="id" title="lemma">even_plus_failed_1</span></a> : <br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> (<a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Nasza indukcja po <span class="inlinecode"><span class="id" title="var">n</span></span> zawiodła, gdyż nasza hipoteza indukcyjna ma w
    konkluzji <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, podczas gdy nasz cel jest postaci
    <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>. Zauważmy, że teoretycznie cel powinno dać się udowodnić,
    jako że mamy hipotezy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> oraz <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, a suma liczby parzystej i
    nieparzystej jest nieparzysta.

<div class="paragraph"> </div>

    Nie zrażajmy się jednak i spróbujmy indukcji po dowodzie <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.even_plus_failed_2"><span class="id" title="lemma">even_plus_failed_2</span></a> : <br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> (<a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Nasza indukcja po dowodzie hipotezy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> zawiodła, i to z kretesem,
    gdyż w kontekście nie mamy nawet żadnej hipotezy indukcyjnej! Co właściwie
    się stało? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#MutInd.even_ind"><span class="id" title="definition">even_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;-&gt;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;odd&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;even&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, w naszej hipotezie "indukcyjnej" wygenerowanej przez Coqa w
    ogóle nie ma żadnej indukcji. Jest tam jedynie odwołanie do predykatu
    <span class="inlinecode"><span class="id" title="var">odd</span></span>...

<div class="paragraph"> </div>

    Zauważmy jednak, że naszym celem znów było <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, a hipotezy
    <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> sprawiają, że w teorii powinno dać się ten cel
    udowodnić, gdyż suma liczby parzystej i nieparzystej jest nieparzysta.

<div class="paragraph"> </div>

    Mogłoby się zdawać, że cierpimy na niedopasowanie (próba 1) lub brak
    (próba 2) hipotez indukcyjnych. Wydaje się też, że skoro w obydwu
    próbach zatrzymaliśmy się na celu <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, to pomocne mogłoby
    okazać się poniższe twierdzenie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="MutInd.odd_even_plus_failed"><span class="id" title="lemma">odd_even_plus_failed</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#MutInd.odd"><span class="id" title="inductive">odd</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.odd"><span class="id" title="inductive">odd</span></a> (<a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Niestety — nie dla psa kiełbasa, gdyż natykamy się na problemy bliźniaczo
    podobne do tych, które napotkaliśmy w poprzednim twierdzeniu: nasza
    hipoteza indukcyjna ma w konkluzji <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>, podczas gdy nasz cel
    jest postaci <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span>.

<div class="paragraph"> </div>

    Próba przepchnięcia lematu za pomocą indukcji po dowodzie hipotezy
    <span class="inlinecode"><span class="id" title="var">odd</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> także nie zadziała, z tych samych powodów dla których indukcja
    po <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> nie pozwoliła nam udowodnić <span class="inlinecode"><span class="id" title="var">even_plus</span></span>. Zauważmy jednak, że
    cel jest udowadnialny, gdyż jako hipotezy mamy <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>,
    a suma dwóch liczb parzystych jest parzysta.

<div class="paragraph"> </div>

    Wydaje się, że wpadliśmy w błędne koło i jesteśmy w matni, bez wyjścia,
    bez nadziei, bez krzty szans na powodzenie: w dowodzie <span class="inlinecode"><span class="id" title="var">even_plus</span></span>
    potrzebujemy lematu <span class="inlinecode"><span class="id" title="var">odd_even_plus</span></span>, ale nie możemy go udowodnić, gdyż
    w dowodzie <span class="inlinecode"><span class="id" title="var">odd_even_plus</span></span> wymagane jest użycie lematu <span class="inlinecode"><span class="id" title="var">even_plus</span></span>.
    Ehhh, gdybyśmy tak mogli udowodnić oba te twierdzenia na raz...

<div class="paragraph"> </div>

    Eureka!

<div class="paragraph"> </div>

    Zauważ, że w naszych dotychczasowych dowodach przez indukcję posługiwaliśmy
    się zwykłą, "pojedynczą" indukcją. Była ona wystarczająca, gdyż mieliśmy do
    czynienia jedynie ze zwykłymi typami induktywnymi. Tym razem jednak jest
    inaczej: w ostatnich trzech dowodach chcieliśmy użyć "pojedynczej" indukcji
    do udowodnienia czegoś na temat predykatów wzajemnie induktywnych.

<div class="paragraph"> </div>

    Jest to ogromny zgrzyt. Do dowodzenia właściwości typów wzajemnie
    induktywnych powinniśmy użyć... o zgrozo, jak mogliśmy to przeoczyć,
    przecież to takie oczywiste... indukcji wzajemnej!

<div class="paragraph"> </div>

    Najprostszy sposób przeprowadzenia tego dowodu wygląda tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MutInd.even_plus"><span class="id" title="lemma">even_plus</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> (<a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>)<br/>
<span class="id" title="keyword">with</span> <a name="MutInd.odd_even_plus"><span class="id" title="lemma">odd_even_plus</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#MutInd.odd"><span class="id" title="inductive">odd</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#MutInd.odd"><span class="id" title="inductive">odd</span></a> (<a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>. <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">odd_even_plus</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">even_plus</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Co tu się właściwie stało? Pierwsze dwie linijki są takie same jak
    poprzednio: stwierdzamy, że będziemy dowodzić twierdzenia o podanej
    nazwie i postaci. Następnie mamy słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">with</span></span>, które pełni
    tu rolę podobną jak w definicjach przez indukcję wzajemną: podając po
    nim nazwę i postać twierdzenia mówimy Coqowi, że chcemy dowodzić tego
    twierdzenia (<span class="inlinecode"><span class="id" title="var">odd_even_plus</span></span>) jednocześnie z poprzednim (<span class="inlinecode"><span class="id" title="var">even_plus</span></span>).

<div class="paragraph"> </div>

    Dotychczas po rozpoczęciu dowodu ukazywał nam się jeden cel. Tym razem,
    jako że dowodzimy dwóch twierdzeń jednocześnie, mamy przed sobą dwa cele.
    W kontekście mamy też od razu dwie hipotezy indukcyjne. Musimy na nie
    bardzo uważać: dotychczas hipotezy indukcyjne pojawiały się dopiero w
    kroku indukcyjnym i sposób ich użycia był oczywisty. Tym razem jest
    inaczej — jako, że mamy je od samego początku, możemy natychmiast użyć
    ich do "udowodnienia" naszych twierdzeń.

<div class="paragraph"> </div>

    Niestety, takie "udowodnienie" odpowiada wywołaniu rekurencyjnemu na
    argumencie, który nie jest strukturalnie mniejszy (coś jak <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>).
    Fakt ten obrazuje wiadomość o błędzie, jaką Coq daje nam po tej próbie: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Error:&nbsp;Cannot&nbsp;guess&nbsp;decreasing&nbsp;argument&nbsp;of&nbsp;fix.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Zaczynamy dowód od nowa, tym razem już bez oszukiwania. Musimy udowodnić
    każdy z naszych celów osobno, ale możemy korzystać z obydwu hipotez
    indukcyjnych. W obydwu celach zaczynamy od analizy przypadków, czyli
    rozbicia <span class="inlinecode"><span class="id" title="var">n</span></span>, i rozwiązania przypadku bazowego. Rozbicie <span class="inlinecode"><span class="id" title="var">n</span></span> dało nam
    <span class="inlinecode"><span class="id" title="var">n'</span></span>, które jest strukturalnie mniejsze od <span class="inlinecode"><span class="id" title="var">n</span></span>, a zatem możemy bez obaw
    użyć naszej hipotezy indukcyjnej. Reszta jest trywialna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="MutInd.even_double"><span class="id" title="lemma">even_double</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#MutInd.even"><span class="id" title="inductive">even</span></a> (2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> *; <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#plus_n_O"><span class="id" title="lemma">plus_n_O</span></a> <span class="id" title="keyword">in</span> *. <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Plus.html#plus_comm"><span class="id" title="abbreviation">plus_comm</span></a>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#MutInd"><span class="id" title="module">MutInd</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab116"></a><h1 class="section">Różne</h1>

<div class="paragraph"> </div>

<a name="lab117"></a><h2 class="section">Parametryczność</h2>

<div class="paragraph"> </div>

 Niech <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Zadajmy sobie następujące pytanie: ile jest funkcji
    typu <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>? Żeby ułatwić sobie zadanie, ograniczmy się jedynie do
    typów, które mają skończoną ilość elementów.

<div class="paragraph"> </div>

    Nietrudno przekonać się, że ich ilość to |B|^|A|, gdzie ^ oznacza
    potęgowanie, zaś |T| to ilość elementów typu <span class="inlinecode"><span class="id" title="var">T</span></span> (ta notacja nie ma
    nic wspólnego z Coqiem — zaadaptowałem ją z teorii zbiorów jedynie
    na potrzeby tego podrozdziału).

<div class="paragraph"> </div>

    Udowodnić ten fakt możesz (choć póki co nie w Coqu) posługując się
    indukcją po ilości elementów typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Jeżeli <span class="inlinecode"><span class="id" title="var">A</span></span> jest pusty, to
    jest tylko jedna taka funkcja, o czym przekonałeś się już podczas
    ćwiczeń w podrozdziale o typie <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>. 
<div class="paragraph"> </div>

<a name="lab118"></a><h4 class="section">Ćwiczenie</h4>
 Udowodnij (nieformalnie, na papierze), że w powyższym akapicie nie
    okłamałem cię. 
<div class="paragraph"> </div>

<a name="lab119"></a><h4 class="section">Ćwiczenie</h4>
 Zdefiniuj wszystkie możliwe funkcje typu <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span>, <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    i <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
<div class="paragraph"> </div>

 Postawmy sobie teraz trudniejsze pytanie: ile jest funkcji typu
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>? W udzieleniu odpowiedzi pomoże nam
    parametryczność — jedna z właściwości Coqowego polimorfizmu.

<div class="paragraph"> </div>

    Stwierdzenie, że polimorfizm w Coqu jest parametryczny, oznacza, że
    funkcja biorąca typ jako jeden z argumentów działa w taki sam sposób
    niezależnie od tego, jaki typ przekażemy jej jako argument.

<div class="paragraph"> </div>

    Konsekwencją tego jest, że funkcje polimorficzne nie wiedzą (i nie
    mogą wiedzieć), na wartościach jakiego typu operują. Wobec tego
    elementem typu <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> nie może być funkcja, która
    np. dla typu <span class="inlinecode"><span class="id" title="var">nat</span></span> stale zwraca <span class="inlinecode">42</span>, a dla innych typów po prostu
    zwraca przekazany jej argument.

<div class="paragraph"> </div>

    Stąd konkludujemy, że typ <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> ma tylko jeden
    element, a mianowicie polimorficzną funkcję identycznościową. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="id'"><span class="id" title="definition">id'</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Set</span>, <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Set</span>) (<span class="id" title="var">x</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>) =&gt; <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab120"></a><h4 class="section">Ćwiczenie</h4>
 Zdefiniuj wszystkie elementy następujących typów lub udowodnij, że
    istnienie choć jednego elementu prowadzi do sprzeczności:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">sum</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">C</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab121"></a><h2 class="section">Ścisła pozytywność</h2>

<div class="paragraph"> </div>

 Poznana przez nas dotychczas definicja typów induktywnych jest niepełna,
    gdyż pominęliśmy kryterium ścisłej pozytywności. Rozważmy następujący
    typ: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <a name="wut"><span class="id" title="inductive">wut</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="C"><span class="id" title="constructor">C</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="R2.html#wut"><span class="id" title="inductive">wut</span></a> <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="var">A</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#wut"><span class="id" title="inductive">wut</span></a> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
Uwaga: poprzedzenie komendą <span class="inlinecode"><span class="id" title="var">Fail</span></span> innej komendy oznajmia Coqowi, że
    spodziewamy się, iż komenda zawiedzie. Coq akceptuje komendę <span class="inlinecode"><span class="id" title="var">Fail</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span>,
    jeżeli komenda <span class="inlinecode"><span class="id" title="var">c</span></span> zawodzi, i wypisuje komunikat o błędzie. Jeżeli
    komenda <span class="inlinecode"><span class="id" title="var">c</span></span> zakończy się sukcesem, komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> zwróci błąd.

<div class="paragraph"> </div>

    Komenda <span class="inlinecode"><span class="id" title="var">Fail</span></span> jest przydatna w sytuacjach takich jak obecna, gdy
    chcemy zilustrować fakt, że jakaś komenda zawodzi. 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Error:&nbsp;Non&nbsp;strictly&nbsp;positive&nbsp;occurrence&nbsp;of&nbsp;"wut"<br/>
&nbsp;&nbsp;&nbsp;in&nbsp;"(wut&nbsp;A&nbsp;-&gt;&nbsp;A)&nbsp;-&gt;&nbsp;wut&nbsp;A".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Żeby zrozumieć ten komunikat o błędzie, musimy najpierw przypomnieć sobie
    składnię konstruktorów. Konstruktory typu induktywnego <span class="inlinecode"><span class="id" title="var">T</span></span> będą mieć (w
    dość sporym uproszczeniu) postać <span class="inlinecode"><span class="id" title="var">arg1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">argN</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> — są to funkcje
    biorące pewną (być może zerową) ilość argumentów, a ich przeciwdziedziną
    jest definiowany typ <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    Jeżeli definiowany typ <span class="inlinecode"><span class="id" title="var">T</span></span> nie występuje nigdzie w typach argumentów
    <span class="inlinecode"><span class="id" title="var">arg1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">argN</span></span>, sytuacja jest klarowna i wszystko jest w porządku.
    W przeciwnym wypadku, w zależności od postaci typów argumentów, mogą
    pojawić się problemy.

<div class="paragraph"> </div>

    Jeżeli typ któregoś z argumentów jest równy <span class="inlinecode"><span class="id" title="var">T</span></span>, nie ma problemu — jest
    to po prostu argument rekurencyjny. Jeżeli jest on postaci <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> dla
    dowolnego typu <span class="inlinecode"><span class="id" title="var">A</span></span>, również nie ma problemu — dzięki argumentom o takich
    typach możemy reprezentować np. drzewa o nieskończonym współczynniku
    rozgałęzienia. Mówimy, że w <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> typ <span class="inlinecode"><span class="id" title="var">T</span></span> występuje w pozycji (ściśle)
    pozytywnej.

<div class="paragraph"> </div>

    Problem pojawia się dopiero, gdy typ argumentu jest postaci <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>
    lub podobnej (np. <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> etc.). W takich
    przypadkach mówimy, że typ <span class="inlinecode"><span class="id" title="var">T</span></span> występuje na pozycji negatywnej (albo
    "nie-ściśle-pozytywnej").

<div class="paragraph"> </div>

    Pierwszym, stosunkowo błahym problemem jest fakt, że typy łamiące
    kryterium ścisłej pozytywności nie mają modeli teoriozbiorowych —
    znaczy to po prostu, że nie można reprezentować ich w teorii zbiorów
    za pomocą żadnych zbiorów. Dla wielu matematyków stanowi to problem
    natury praktycznej (są przyzwyczajeni do teorii zbiorów) lub
    filozoficznej.

<div class="paragraph"> </div>

    Problem ten wynika z faktu, że konstruktory typów induktywnych są
    injekcjami, zaś typy argumentów, w których definiowany typ występuje
    na pozycji negatywnej, są "za duże". Np. w przypadku typu <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    konstruktor <span class="inlinecode"><span class="id" title="var">C</span></span> jest injekcją z <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> w <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>.
    Gdybyśmy chcieli interpretować typy jako zbiory, to zbiór
    <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> jest "za duży", by można było go wstrzyknąć do
    <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, gdyż jest w bijekcji ze zbiorem potęgowym <span class="inlinecode"><span class="id" title="var">wut</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, a
    w teorii zbiorów powszechnie wiadomo, że nie ma injekcji ze zbioru
    potęgowego jakiegoś zbioru do niego samego.

<div class="paragraph"> </div>

    Nie przejmuj się, jeżeli nie rozumiesz powyższego paragrafu — nie
    jest to główny powód obowiązywania kryterium ścisłej pozytywności,
    wszak jako buntownicy zajmujący się teorią typów nie powinniśmy
    zbytnio przejmować się teorią zbiorów.

<div class="paragraph"> </div>

    Prawdziwy powód jest inny: dopuszczenie typów łamiących kryterium
    ścisłej pozytywności prowadzi do sprzeczności. Gdyby były one
    legalne, legalna byłaby również poniższa definicja: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <a name="y"><span class="id" title="definition">y</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">f</span> := (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">wut</span> <span class="id" title="var">A</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">x</span> <span class="id" title="keyword">with</span> | <span class="id" title="var">C</span> <span class="id" title="var">f'</span> =&gt; <span class="id" title="var">f'</span> <span class="id" title="var">x</span> <span class="id" title="keyword">end</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span> <span class="id" title="var">f</span> (<span class="id" title="var">C</span> <span class="id" title="var">f</span>).<br/>

<br/>
</div>

<div class="doc">
Jak widać, gdyby definicja typu <span class="inlinecode"><span class="id" title="var">wut</span></span> została dopuszczona,
    moglibyśmy uzyskać zapętlający się program umożliwiający nam
    stworzenie elementu dowolnego typu i to bez użycia słowa
    kluczowego <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> (program ten jest nazywany zazwyczaj
    kombinatorem Y, ang. Y combinator). Stąd już niedaleko do
    popadnięcia w zupełną sprzeczność: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Definition</span> <a name="santa_is_a_pedophile"><span class="id" title="definition">santa_is_a_pedophile</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> := <span class="id" title="var">y</span> <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab122"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Inductive&nbsp;T&nbsp;:&nbsp;Type&nbsp;:=&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Rozstrzygnij, czy typ posiadający jeden z następujących konstruktorów
    spełnia kryterium ścisłej pozytywności. Następnie sprawdź w Coqu, czy
    udzieliłeś poprawnej odpowiedzi.
<ul class="doclist">
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C3</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C4</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C5</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C6</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C7</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C8</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode">(<span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C9</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C10</span></span> <span class="inlinecode">:</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>),</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span>

</li>
<li> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">C11</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">T</span></span> 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab123"></a><h2 class="section">Rodziny typów induktywnych</h2>

<div class="paragraph"> </div>

 Słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> pozwala nam definiować nie tylko typy
    induktywne, ale także rodziny typów induktywnych — i to nawet na
    dwa sposoby. W tym podrozdziale przyjrzymy się obu z nich oraz
    różnicom między nimi, a także ich wadom i zaletom. Przyjrzyjmy się
    raz jeszcze typowi <span class="inlinecode"><span class="id" title="var">option</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="R2.html#option"><span class="id" title="inductive">option</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;option&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Some&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;None&nbsp;:&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#Some"><span class="id" title="constructor">Some</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> @<a class="idref" href="R2.html#None"><span class="id" title="constructor">None</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;@None&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Definiując rodzinę typów <span class="inlinecode"><span class="id" title="var">option</span></span>, umieściliśmy argument będący typem
    w nawiasach okrągłych tuż po nazwie definiowanego typu, a przed <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.
    Definiując konstruktory, nie napisaliśmy nigdzie <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode">...</span>,
    a mimo tego komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span> jasno pokazuje, że typy obydwu konstruktorów
    zaczynają się od takiej właśnie kwantyfikacji.

<div class="paragraph"> </div>

    (Przypomnijmy, że w przypadku <span class="inlinecode"><span class="id" title="var">None</span></span> argument <span class="inlinecode"><span class="id" title="var">A</span></span> jest domyślny, więc
    wyświetlenie pełnego typu tego konstruktora wymagało użycia symbolu <span class="inlinecode">@</span>,
    który oznacza "wyświetl wszystkie argumenty domyślne").

<div class="paragraph"> </div>

    W ogólności, definiowanie rodziny typów <span class="inlinecode"><span class="id" title="var">T</span></span> jako <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">(<span class="id" title="var">x1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A1</span>)</span> <span class="inlinecode">...</span> <span class="inlinecode">(<span class="id" title="var">xN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">AN</span>)</span>
    ma następujący efekt:
<ul class="doclist">
<li> kwantyfikacja <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">x1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A1</span>)</span> <span class="inlinecode">...</span> <span class="inlinecode">(<span class="id" title="var">xN</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">AN</span>)</span> jest dodawana na
      początek każdego konstruktora

</li>
<li> w konkluzji konstruktora <span class="inlinecode"><span class="id" title="var">T</span></span> musi wystąpić zaaplikowany do tych
      argumentów, czyli jako <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">xN</span></span> — wstawienie innych argumentów
      jest błędem 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Inductive</span> <a name="option'"><span class="id" title="inductive">option'</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Some'"><span class="id" title="constructor">Some'</span></a> : <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#option'"><span class="id" title="inductive">option'</span></a> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="None'"><span class="id" title="constructor">None'</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <a class="idref" href="R2.html#option'"><span class="id" title="inductive">option'</span></a> <a class="idref" href="R2.html#B"><span class="id" title="variable">B</span></a>.<br/>

<br/>
</div>

<div class="doc">
Próba zdefiniowania typu <span class="inlinecode"><span class="id" title="var">option'</span></span> kończy się następującym komunikatem
    o błędzie: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Error:&nbsp;Last&nbsp;occurrence&nbsp;of&nbsp;"option'"&nbsp;must&nbsp;have&nbsp;"A"&nbsp;as&nbsp;1st&nbsp;argument&nbsp;in&nbsp;<br/>
&nbsp;&nbsp;&nbsp;"forall&nbsp;B&nbsp;:&nbsp;Type,&nbsp;option'&nbsp;B".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Drugi sposób zdefiniowania rodziny typów <span class="inlinecode"><span class="id" title="var">option</span></span> przedstawiono
    poniżej. Tym razem zamiast umieszczać argument <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> po
    nazwie definiowanego typu, deklarujemy, że typem <span class="inlinecode"><span class="id" title="var">option'</span></span> jest
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="option'"><span class="id" title="inductive">option'</span></a> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Some'"><span class="id" title="constructor">Some'</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#option'"><span class="id" title="inductive">option'</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="None'"><span class="id" title="constructor">None'</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>, <a class="idref" href="R2.html#option'"><span class="id" title="inductive">option'</span></a> <a class="idref" href="R2.html#B"><span class="id" title="variable">B</span></a>.<br/>

<br/>
</div>

<div class="doc">
Taki zabiego daje nam większą swobodę: w każdym konstruktorze
    z osobna musimy explicité umieścić kwantyfikację po argumencie
    sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, dzięki czemu różne konstruktory mogą w konkluzji
    mieć <span class="inlinecode"><span class="id" title="var">option'</span></span> zaaplikowany do różnych argumentów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#Some'"><span class="id" title="constructor">Some'</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Some'&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;option'&nbsp;A&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#None'"><span class="id" title="constructor">None'</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;None'&nbsp;:&nbsp;forall&nbsp;B&nbsp;:&nbsp;Type,&nbsp;option'&nbsp;B&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Zauważmy jednak, że definicje <span class="inlinecode"><span class="id" title="var">option</span></span> i <span class="inlinecode"><span class="id" title="var">option'</span></span> są równoważne
    — typ konstruktora <span class="inlinecode"><span class="id" title="var">None'</span></span> różni się od typu <span class="inlinecode"><span class="id" title="var">None</span></span> jedynie nazwą
    argumentu (<span class="inlinecode"><span class="id" title="var">A</span></span> dla <span class="inlinecode"><span class="id" title="var">None</span></span>, <span class="inlinecode"><span class="id" title="var">B</span></span> dla <span class="inlinecode"><span class="id" title="var">None'</span></span>).

<div class="paragraph"> </div>

    Jak zatem rozstrzygnąć, który sposób definiowania jest "lepszy"?
    W naszym przypadku lepszy jest sposób pierwszy, odpowiadający
    typowi <span class="inlinecode"><span class="id" title="var">option</span></span>, gdyż jest bardziej zwięzły. Nie jest to jednak
    jedyne kryterium. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#option_ind"><span class="id" title="definition">option_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;option_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(P&nbsp;:&nbsp;option&nbsp;A&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;a&nbsp;:&nbsp;A,&nbsp;P&nbsp;(Some&nbsp;a))&nbsp;-&gt;&nbsp;P&nbsp;None&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;o&nbsp;:&nbsp;option&nbsp;A,&nbsp;P&nbsp;o&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="R2.html#option'_ind"><span class="id" title="definition">option'_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;option'_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;forall&nbsp;T&nbsp;:&nbsp;Type,&nbsp;option'&nbsp;T&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(a&nbsp;:&nbsp;A),&nbsp;P&nbsp;A&nbsp;(Some'&nbsp;A&nbsp;a))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;B&nbsp;:&nbsp;Type,&nbsp;P&nbsp;B&nbsp;(None'&nbsp;B))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(T&nbsp;:&nbsp;Type)&nbsp;(o&nbsp;:&nbsp;option'&nbsp;T),&nbsp;P&nbsp;T&nbsp;o&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Dwa powyższe termy to reguły indukcyjne, wygenerowane automatycznie
    przez Coqa dla typów <span class="inlinecode"><span class="id" title="var">option</span></span> oraz <span class="inlinecode"><span class="id" title="var">option'</span></span>. Reguła dla <span class="inlinecode"><span class="id" title="var">option</span></span>
    jest wizualnie krótsza, co, jak dowiemy się w przyszłości, oznacza
    zapewne, że jest prostsza, zaś prostsza reguła indukcyjna oznacza
    łatwiejsze dowodzenie przez indukcję. Jest to w zasadzie najmocniejszy
    argument przemawiający za pierwszym sposobem zdefiniowania <span class="inlinecode"><span class="id" title="var">option</span></span>.

<div class="paragraph"> </div>

    Powyższe rozważania nie oznaczają jednak, że sposób pierwszy jest
    zawsze lepszy — sposób drugi jest bardziej ogólny i istnieją rodziny
    typów, których zdefiniowanie sposobem pierwszym jest niemożliwe.
    Klasycznym przykładem jest rodzina typów <span class="inlinecode"><span class="id" title="var">vec</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="vec"><span class="id" title="inductive">vec</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="vnil"><span class="id" title="constructor">vnil</span></a> : <a class="idref" href="R2.html#vec"><span class="id" title="inductive">vec</span></a> <span class="id" title="var">A</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="vcons"><span class="id" title="constructor">vcons</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#vec"><span class="id" title="inductive">vec</span></a> <span class="id" title="var">A</span> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#vec"><span class="id" title="inductive">vec</span></a> <span class="id" title="var">A</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a>).<br/>

<br/>
</div>

<div class="doc">
Konstruktor <span class="inlinecode"><span class="id" title="var">vnil</span></span> reprezentuje listę pustą, której długość wynosi
    rzecz jasna <span class="inlinecode">0</span>, zaś <span class="inlinecode"><span class="id" title="var">vcons</span></span> reprezentuje listę składająca się z
    głowy i ogona o długości <span class="inlinecode"><span class="id" title="var">n</span></span>, której długość wynosi oczywiście <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">vec</span></span> reprezetuje listy o długości znanej statycznie (tzn. Coq zna
    długość takiej listy już w trakcie sprawdzania typów), dzięki czemu
    możemy obliczać ich długość w czasie stałym (po prostu odczytując ją
    z typu danej listy).

<div class="paragraph"> </div>

    Zauważ, że w obu konstruktorach argumenty typu <span class="inlinecode"><span class="id" title="var">nat</span></span> są różne, a zatem
    zdefiniowanie tego typu jako <span class="inlinecode"><span class="id" title="var">vec</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">...</span> byłoby
    niemożliwe.

<div class="paragraph"> </div>

    Przykład ten pokazuje nam również, że przy definiowaniu rodzin typów
    możemy dowolnie mieszać sposoby pierwszy i drugi — w naszym przypadku
    argument <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> jest wspólny dla wszystkich konstruktorów, więc
    umieszczamy go przed ostatnim <span class="inlinecode">:</span>, zaś argument typu <span class="inlinecode"><span class="id" title="var">nat</span></span> różni się
    w zależności od konstruktora, a zatem umieszczamy go po ostatnim <span class="inlinecode">:</span>. 
<div class="paragraph"> </div>

<a name="lab124"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj następujące typy (zadbaj o to, żeby wygenerowana reguła
    indukcyjna była jak najkrótsza):
<ul class="doclist">
<li> typ drzew binarnych przechowujących elementy typu <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> typ drzew binarnych przechowujących elementy typu <span class="inlinecode"><span class="id" title="var">A</span></span>,
      których wysokość jest znana statycznie

</li>
<li> typ heterogenicznych drzew binarnych (mogą one
      przechowywać elementy różnych typów)

</li>
<li> typ heterogenicznych drzew binarnych, których wysokość
      jest znana statycznie 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab125"></a><h2 class="section">Sumy zależne i podtypy</h2>

<div class="paragraph"> </div>

 W Coqu, w przeciwieństwie do wielu języków imperatywnych, nie ma
    mechanizmu subtypowania, a każde dwa typy są ze sobą rozłączne.
    Nie jest to problemem, gdyż subtypowanie możemy zasymulować za
    pomocą sum zależnych, a te zdefiniować możemy induktywnie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="sigT"><span class="id" title="inductive">sigT</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="existT"><span class="id" title="constructor">existT</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#sigT"><span class="id" title="inductive">sigT</span></a> <span class="id" title="var">A</span> <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">sigT</span></span> reprezentuje sumę zależną, której elementami są pary zależne.
    Pierwszym elementem pary jest <span class="inlinecode"><span class="id" title="var">x</span></span>, który jest typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś drugim
    elementem pary jest term typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Suma zależna jest wobec tego pewnym
    uogólnieniem produktu.

<div class="paragraph"> </div>

    Niech cię nie zmyli nazewnictwo:
<ul class="doclist">
<li> Suma jest reprezentowana przez typ <span class="inlinecode"><span class="id" title="var">sum</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jej elementami są
      elementy <span class="inlinecode"><span class="id" title="var">A</span></span> zawinięte w konstruktor <span class="inlinecode"><span class="id" title="var">inl</span></span> oraz elementy <span class="inlinecode"><span class="id" title="var">B</span></span>
      zawinięte w konstruktor <span class="inlinecode"><span class="id" title="var">inr</span></span>. Reprezentuje ideę "lub/albo".
      Typ <span class="inlinecode"><span class="id" title="var">B</span></span> nie może zależeć od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Produkt jest reprezentowany przez typ <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jego elementami
      są pary elementów <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span>. Reprezentuje on ideę "i/oraz". Typ
      <span class="inlinecode"><span class="id" title="var">B</span></span> nie może zależeć od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Uogólnieniem produktu jest suma zależna. Jest ona reprezentowana
      przez typ <span class="inlinecode"><span class="id" title="var">sigT</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Jej elementami są pary zależne elementów
      <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest pierwszym elementem pary.
      Reprezentuje ona ideę "i/oraz", gdzie typ <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> może zależeć od
      elementu <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Typ funkcji jest reprezentowany przez <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Jego elementami
      są termy postaci <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">...</span>. Reprezentują ideę "daj mi
      coś typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a ja oddam ci coś typu <span class="inlinecode"><span class="id" title="var">B</span></span>". Typ <span class="inlinecode"><span class="id" title="var">B</span></span> nie może
      zależeć od typu <span class="inlinecode"><span class="id" title="var">A</span></span>.

</li>
<li> Uogólnieniem typu funkcji jest produkt zależny <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.
      Jego elementami są termu postaci <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">...</span>. Reprezentuje
      on ideę "daj mi <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a ja oddam ci coś typu <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>". Typ
      <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> może zależeć od typu elementu <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">sigT</span></span> jest najogólniejszą postacią pary zależnej — <span class="inlinecode"><span class="id" title="var">A</span></span> jest typem,
    a <span class="inlinecode"><span class="id" title="var">P</span></span> rodziną typów. Mimo swej ogólności jest używany dość rzadko,
    gdyż najbardziej przydatną postacią sumy zależnej jest typ <span class="inlinecode"><span class="id" title="var">sig</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="sig"><span class="id" title="inductive">sig</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="exist"><span class="id" title="constructor">exist</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#sig"><span class="id" title="inductive">sig</span></a> <span class="id" title="var">A</span> <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="R2.html#exist"><span class="id" title="constructor">exist</span></a> [<span class="id" title="var">A</span>] [<span class="id" title="var">P</span>] <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> można interpretować jako typ składający się z tych
    elementów <span class="inlinecode"><span class="id" title="var">A</span></span>, które spełniają predykat <span class="inlinecode"><span class="id" title="var">P</span></span>. Formalnie jest to
    para zależna, której pierwszym elementem jest term typu <span class="inlinecode"><span class="id" title="var">A</span></span>, zaś
    drugim dowód na to, że spełnia on predykat <span class="inlinecode"><span class="id" title="var">P</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="even_nat"><span class="id" title="definition">even_nat</span></a> : <span class="id" title="keyword">Type</span> := <a class="idref" href="R2.html#sig"><span class="id" title="inductive">sig</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="even_four"><span class="id" title="definition">even_four</span></a> : <a class="idref" href="R2.html#even_nat"><span class="id" title="definition">even_nat</span></a> := <a class="idref" href="R2.html#exist"><span class="id" title="constructor">exist</span></a> 4 <a class="idref" href="R2.html#four_is_even"><span class="id" title="lemma">four_is_even</span></a>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">even_nat</span></span> reprezentuje parzyste liczby naturalne, zaś term
    <span class="inlinecode"><span class="id" title="var">even_four</span></span> to liczba <span class="inlinecode">4</span> wraz z załączonym dowodem faktu, że <span class="inlinecode">4</span>
    jest parzyste.

<div class="paragraph"> </div>

    Interpretacja typu <span class="inlinecode"><span class="id" title="var">sig</span></span> sprawia, że jest on wykorzystywany bardzo
    często do podawania specyfikacji programów — pozwala on dodać do
    wyniku zwracanego przez funkcję informację o jego właściwościach.
    W przypadku argumentów raczej nie jest używany, gdyż prościej jest
    po prostu wymagać dowodów żądanych właściwości w osobnych argumentach
    niż pakować je w <span class="inlinecode"><span class="id" title="var">sig</span></span> po to, żeby i tak zostały później odpakowane. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="even_42"><span class="id" title="definition">even_42</span></a> : <a class="idref" href="R2.html#sig"><span class="id" title="inductive">sig</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="R2.html#even"><span class="id" title="inductive">even</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="R2.html#exist"><span class="id" title="constructor">exist</span></a> 42). <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Definiowanie wartości typu <span class="inlinecode"><span class="id" title="var">sig</span></span> jest problematyczne, gdyż zawierają
    one dowody. Napisanie definicji "ręcznie", explicité podając proofterm,
    nie wchodzi w grę. Innym potencjalnym rozwiązaniem jest napisanie dowodu
    na boku, a następnie użycie go we właściwej definicji, ale jest ono
    dłuższe niż to konieczne.

<div class="paragraph"> </div>

    Przypomnijmy sobie, czym są taktyki. Dowody to termy, których typy są
    sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a taktyki służą do konstruowania tych dowodów. Ponieważ
    dowody nie różnią się (prawie) niczym od programów, taktyk można użyć
    także do pisania programów. Taktyki to metaprogramy (napisane w jęzku
    Ltac), które piszą programy (w jęzku termów Coqa, zwanym Gallina).

<div class="paragraph"> </div>

    Wobec tego trybu dowodzenia oraz taktyk możemy używać nie tylko do
    dowodzenia, ale także do definiowania i to właśnie uczyniliśmy w
    powyższym przykładzie. Skonstruowanie termu typu <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>,
    czyli parzystej liczby naturalnej, odbyło się w następujący sposób.

<div class="paragraph"> </div>

    Naszym celem jest początkowo <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>, czyli typ, którego
    element chcemy skonstrować. Używamy konstruktora <span class="inlinecode"><span class="id" title="var">exist</span></span>, który
    w naszym przypadku jest typu <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>.
    Wobec tego <span class="inlinecode"><span class="id" title="var">exist</span></span> <span class="inlinecode">42</span> jest typu <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">42</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode"><span class="id" title="var">even</span></span>, a jego
    zaaplikowanie skutkować będzie zamianą naszego celu na <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode">42</span>.
    Następnie dowodzimy tego faktu, co kończy proces definiowania. 
<div class="paragraph"> </div>

<a name="lab126"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj predykat <span class="inlinecode"><span class="id" title="var">sorted</span></span>, który jest spełniony, gdy jego argument
    jest listą posortowaną. Następnie zdefiniuj typ list liczb naturalnych
    posortowanych według relacji <span class="inlinecode">&lt;=</span> i skonstruuj term tego typu
    odpowiadający liście <span class="inlinecode">[42;</span> <span class="inlinecode">666;</span> <span class="inlinecode">1337]</span>. 
<div class="paragraph"> </div>

<a name="lab127"></a><h2 class="section">Rozstrzygalność</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="excluded_middle"><span class="id" title="lemma">excluded_middle</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="R2.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="R2.html#P"><span class="id" title="variable">P</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">left</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">intro</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Próba udowodnienia tego twierdzenia pokazuje nam zasadniczą różnicę
    między logiką konstruktywną, która jest domyślną logiką Coqa, oraz
    logiką klasyczną, najpowszechniej znanym i używanym rodzajem logiki.

<div class="paragraph"> </div>

    Każde zdanie jest, w pewnym "filozoficznym" sensie, prawdziwe lub
    fałszywe i to właśnie powyższe zdanie oznacza w logice klasycznej.
    Logika konstruktywna jednak, jak już wiemy, nie jest logiką prawdy,
    lecz logiką udowadnialności i ma swoją interpretację obliczeniową.
    Powyższe zdanie w logice konstruktywnej oznacza: program komputerowy
    <span class="inlinecode"><span class="id" title="var">exluded_middle</span></span> rozstrzyga, czy dowolne zdanie jest prawdziwe, czy
    fałszywe.

<div class="paragraph"> </div>

    Skonstruowanie programu o takim typie jest w ogólności niemożliwe,
    gdyż dysponujemy zbyt małą ilością informacji: nie wiemy czym jest
    zdanie <span class="inlinecode"><span class="id" title="var">P</span></span>, a nie posiadamy żadnego ogólnego sposobu dowodzenia lub
    obalania zdań o nieznanej nam postaci. Nie możemy np. użyć indukcji,
    gdyż nie wiemy, czy zdanie <span class="inlinecode"><span class="id" title="var">P</span></span> zostało zdefiniowane induktywnie, czy
    też nie. W Coqu jedynym sposobem uzyskania termu o typie <span class="inlinecode"><span class="id" title="keyword">forall</span></span>
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> jest przyjęcie go jako aksjomat. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="True_dec"><span class="id" title="lemma">True_dec</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">left</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższe dywagacje nie przeszkadzają nam jednak w udowadnianiu,
    że reguła wyłączonego środka zachodzi dla pewnych konkretnych
    zdań. Zdanie takie będziemy nazywać zdaniami rozstrzygalnymi
    (ang. decidable). O pozostałych zdaniach będziemy mówić, że są 
    nierozstrzygalne (ang. undecidable). Ponieważ w Coqu wszystkie
    funkcje są rekurencyjne, a dowody to programy, to możemy powyższą
    definicję rozumieć tak: zdanie jest rozstrzygalne, jeżeli istnieje
    funkcja rekurencyjna o przeciwdzidzinie <span class="inlinecode"><span class="id" title="var">bool</span></span>, która sprawdza, czy
    jest ono prawdziwe, czy fałszywe.

<div class="paragraph"> </div>

    Przykładami zdań, predykatów czy problemów rozstrzygalnych są:
<ul class="doclist">
<li> sprawdzanie, czy lista jest niepusta

</li>
<li> sprawdzanie, czy liczba naturalna jest parzysta

</li>
<li> sprawdzanie, czy dwie liczby naturalne są równe 
</li>
</ul>

<div class="paragraph"> </div>

 Przykładem problemów nierozstrzygalnych są:
<ul class="doclist">
<li> dla funkcji <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> sprawdzenie, czy
      <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> — jest to w ogólności niemożliwe,
      gdyż wymaga wykonania nieskończonej ilości porównań (co nie
      znaczy, że nie da się rozwiązać tego problemu dla niektórych
      funkcji)

</li>
<li> sprawdzenie, czy słowo o nieskończonej długości jest palindromem 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab128"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="eq_nat_dec"><span class="id" title="lemma">eq_nat_dec</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#m"><span class="id" title="variable">m</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab129"></a><h3 class="section">Techniczne apekty rozstrzygalności</h3>

<div class="paragraph"> </div>

 Podsumowując powyższe rozważania, moglibyśmy stwierdzić: zdanie <span class="inlinecode"><span class="id" title="var">P</span></span> jest
    rozstrzygalne, jeżeli istnieje term typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Stwierdzenie takie
    nie zamyka jednak sprawy, gdyż bywa czasem mocno bezużyteczne.

<div class="paragraph"> </div>

    Żeby to zobrazować, spróbujmy użyć twierdzenia <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span> do napisania
    funkcji, która sprawdza, czy liczna naturalna <span class="inlinecode"><span class="id" title="var">n</span></span> występuje na liście
    liczb naturalnych <span class="inlinecode"><span class="id" title="var">l</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <a name="inb_nat"><span class="id" title="definition">inb_nat</span></a> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="R2.html#l"><span class="id" title="variable">l</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> =&gt; <a class="idref" href="R2.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="R2.html#eq_nat_dec"><span class="id" title="lemma">eq_nat_dec</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="var">h</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#or_introl"><span class="id" title="constructor">or_introl</span></a> <span class="id" title="var">_</span> =&gt; <a class="idref" href="R2.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <a class="idref" href="R2.html#inb_nat"><span class="id" title="definition">inb_nat</span></a> <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Coq nie akceptuje powyższego kodu, racząc nas informacją o błędzie: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Error:<br/>
&nbsp;&nbsp;&nbsp;Incorrect&nbsp;elimination&nbsp;of&nbsp;"eq_nat_dec&nbsp;n&nbsp;h0"&nbsp;in&nbsp;the&nbsp;inductive&nbsp;type&nbsp;"or":<br/>
&nbsp;&nbsp;&nbsp;the&nbsp;return&nbsp;type&nbsp;has&nbsp;sort&nbsp;"Set"&nbsp;while&nbsp;it&nbsp;should&nbsp;be&nbsp;"Prop".<br/>
&nbsp;&nbsp;&nbsp;Elimination&nbsp;of&nbsp;an&nbsp;inductive&nbsp;object&nbsp;of&nbsp;sort&nbsp;Prop<br/>
&nbsp;&nbsp;&nbsp;is&nbsp;not&nbsp;allowed&nbsp;on&nbsp;a&nbsp;predicate&nbsp;in&nbsp;sort&nbsp;Set<br/>
&nbsp;&nbsp;&nbsp;because&nbsp;proofs&nbsp;can&nbsp;be&nbsp;eliminated&nbsp;only&nbsp;to&nbsp;build&nbsp;proofs.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Nasza porażka wynika z faktu, że do zdefiniowania funkcji, która
    jest programem (jej dziedzina i przeciwdziedzina są sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>)
    próbowaliśmy użyć termu <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>, który jest dowodem
    (konkluzją <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span> jest równość, która jest sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>).

<div class="paragraph"> </div>

    Mimo korespondencji Curry'ego-Howarda, która odpowiada za olbrzymie
    podobieństwo specyfikacji i zdań, programów i dowodów, sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>
    i sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, są one rozróżniane i niesie to za sobą konsekwencje:
    podczas gdy programów możemy używać wszędzie, dowodów możemy używać
    jedynie do konstruowania innych dowodów.

<div class="paragraph"> </div>

    Praktycznie oznacza to, że mimo iż równość liczb naturalnych jest
    rozstrzygalna, pisząc program nie mamy możliwości jej rozstrzygania
    za pomocą <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span>. To właśnie miałem na myśli pisząc, że termy
    typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> są mocno bezużyteczne.

<div class="paragraph"> </div>

    Uszy do góry: nie wszystko stracone! Jest to tylko drobna przeszkoda,
    którą bardzo łatwo ominąć: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="sumbool"><span class="id" title="inductive">sumbool</span></a> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="left"><span class="id" title="constructor">left</span></a> : <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#sumbool"><span class="id" title="inductive">sumbool</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="right"><span class="id" title="constructor">right</span></a> : <span class="id" title="var">B</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#sumbool"><span class="id" title="inductive">sumbool</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">sumbool</span></span> jest niemal dokładną kopią <span class="inlinecode"><span class="id" title="var">or</span></span>, jednak nie żyje on
    w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, lecz w <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Ta drobna sztuczka, że termy typu
    <span class="inlinecode"><span class="id" title="var">sumbool</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> formalnie są programami, mimo że ich naturalna
    interpretacja jest taka sama jak <span class="inlinecode"><span class="id" title="var">or</span></span>, a więc jako dowodu
    dysjunkcji. 
<div class="paragraph"> </div>

<a name="lab130"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij twierdzenie <span class="inlinecode"><span class="id" title="var">eq_nat_dec'</span></span> o rozstrzygalności <span class="inlinecode">=</span> na
    liczbach naturalnych. Użyj typu <span class="inlinecode"><span class="id" title="var">sumbool</span></span>. Następnie napisz
    funkcję <span class="inlinecode"><span class="id" title="var">inb_nat</span></span>, która sprawdza, czy liczba naturalna <span class="inlinecode"><span class="id" title="var">n</span></span>
    jest obecna na liście <span class="inlinecode"><span class="id" title="var">l</span></span>. 
<div class="paragraph"> </div>

<a name="lab131"></a><h2 class="section">Kwantyfikacja egzystencjalna (alfa)</h2>

<div class="paragraph"> </div>

 Znamy już pary zależne i wiemy, że mogą służyć do reprezentowania
    podtypów, których w Coqu brak. Czas zatem uświadomić sobie kolejny
    fragment korespondencji Curry'ego-Howarda, a mianowicie definicję
    kwantyfikacji egzystencjalnej: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="ex"><span class="id" title="module">ex</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="ex.ex"><span class="id" title="inductive">ex</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="ex.ex_intro"><span class="id" title="constructor">ex_intro</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#ex"><span class="id" title="inductive">ex</span></a> <span class="id" title="var">A</span> <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">ex</span></span> to kolejne wcielenia sumy zależnej. Porównaj dokładnie tę
    definicję z definicją <span class="inlinecode"><span class="id" title="var">sigT</span></span> oraz <span class="inlinecode"><span class="id" title="var">sig</span></span>. <span class="inlinecode"><span class="id" title="var">ex</span></span> jest niemal identyczne
    jak <span class="inlinecode"><span class="id" title="var">sig</span></span>: jest to para zależna, której pierwszym elementem jest
    term <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, a drugim dowód na to, że <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> zachodzi. <span class="inlinecode"><span class="id" title="var">ex</span></span> jednak,
    w przeciwieństwie do <span class="inlinecode"><span class="id" title="var">sig</span></span>, żyje w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, czyli jest zdaniem — nie
    liczą się konkretne postaci jego termów ani ich ilość, a jedynie
    fakt ich istnienia. To sprawia, że <span class="inlinecode"><span class="id" title="var">ex</span></span> jest doskonałym kandydatem
    do reprezentowania kwantyfikacji egzystencjalnej. 
<div class="paragraph"> </div>

<a name="lab132"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, że dla każdej liczby naturalnej n istnieje liczba od niej
    większa. Następnie zastanów się, jak działa taktyka <span class="inlinecode"><span class="id" title="tactic">exists</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="ex.exists_greater"><span class="id" title="lemma">exists_greater</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="R2.html#ex.ex"><span class="id" title="inductive">ex</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="R2.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="R2.html#k"><span class="id" title="variable">k</span></a>).<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#ex"><span class="id" title="module">ex</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab133"></a><h2 class="section">Typy hybrydowe (alfa)</h2>

<div class="paragraph"> </div>

 Ostatnim z typów istotnych z punktu widzenia silnych specyfikacji
    jest typ o wdzięcznej nazwie <span class="inlinecode"><span class="id" title="var">sumor</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="sumor"><span class="id" title="module">sumor</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="sumor.sumor"><span class="id" title="inductive">sumor</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="sumor.inleft"><span class="id" title="constructor">inleft</span></a> : <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#sumor"><span class="id" title="inductive">sumor</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="sumor.inright"><span class="id" title="constructor">inright</span></a> : <span class="id" title="var">B</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#sumor"><span class="id" title="inductive">sumor</span></a> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
Jak sama nazwa wskazuje, <span class="inlinecode"><span class="id" title="var">sumor</span></span> jest hybrydą sumy rozłącznej <span class="inlinecode"><span class="id" title="var">sum</span></span>
    oraz dysjunkcji <span class="inlinecode"><span class="id" title="var">or</span></span>. Możemy go interpretować jako typ, którego
    elementami są elementy <span class="inlinecode"><span class="id" title="var">A</span></span> albo wymówki w stylu "nie mam elementu <span class="inlinecode"><span class="id" title="var">A</span></span>,
    ponieważ zachodzi zdanie <span class="inlinecode"><span class="id" title="var">B</span></span>". <span class="inlinecode"><span class="id" title="var">B</span></span> nie zależy od <span class="inlinecode"><span class="id" title="var">A</span></span>, a więc jest to
    zwykła suma (a nie suma zależna, czyli uogólnienie produktu). <span class="inlinecode"><span class="id" title="var">sumor</span></span>
    żyje w <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, a więc jest to specyfikacja i liczy się konkretna
    postać jego termów, a nie jedynie fakt ich istnienia. 
<div class="paragraph"> </div>

<a name="lab134"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">pred'</span></span>, która przypisuje liczbie naturalnej jej
    poprzednik. Poprzednikiem <span class="inlinecode">0</span> nie powinno być <span class="inlinecode">0</span>. Mogą przydać ci
    się typ <span class="inlinecode"><span class="id" title="var">sumor</span></span> oraz sposób definiowania za pomocą taktyk, omówiony
    w podrozdziale dotyczącym sum zależnych. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#sumor"><span class="id" title="module">sumor</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab135"></a><h2 class="section">Cztery rodzaje reguł</h2>

<div class="paragraph"> </div>

 Być może jeszcze tego nie zauważyłeś, ale większość logiki konstruktywnej
    oraz programowania funkcyjnego kręci się wokół czterech rodzajów reguł.
    Są to reguły:
<ul class="doclist">
<li> formacji (ang. formation rules)

</li>
<li> wprowadzania (ang. introduction rules)

</li>
<li> eliminacji (ang. elimination rules)

</li>
<li> obliczania (ang. computation rules) 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab136"></a><h3 class="section">Reguły formacji</h3>

<div class="paragraph"> </div>

 Reguły formacji mówią nam, jak tworzyć typy (termy sortów <span class="inlinecode"><span class="id" title="keyword">Set</span></span> i <span class="inlinecode"><span class="id" title="keyword">Type</span></span>)
    oraz zdania (termy sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>). Większość z nich pochodzi z nagłówków
    definicji induktywnych. Reguła dla typu <span class="inlinecode"><span class="id" title="var">bool</span></span> wygląda tak: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;----------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;:&nbsp;Set&nbsp;<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Ten mistyczny zapis pochodzi z publikacji dotyczących teorii typów.
    Nad kreską znajdują się przesłanki reguły, a pod kreską znajduje się
    konkluzja reguły.

<div class="paragraph"> </div>

    Regułę tę możemy odczytać: <span class="inlinecode"><span class="id" title="var">bool</span></span> jest typem sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Postać tej
    reguły wynika wprost z definicji typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="R2.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;bool&nbsp;:&nbsp;Set&nbsp;:=&nbsp;&nbsp;true&nbsp;:&nbsp;bool&nbsp;|&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Powyższej regule formacji odpowiada tutaj fragment <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span>,
    który stwierdza po prostu, że <span class="inlinecode"><span class="id" title="var">bool</span></span> jest typem sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>.

<div class="paragraph"> </div>

    Nie zawsze jednak reguły formacji są aż tak proste. Reguła dla produktu
    wygląda tak: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;B&nbsp;:&nbsp;Type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;prod&nbsp;A&nbsp;B&nbsp;:&nbsp;Type<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguła formacji dla <span class="inlinecode"><span class="id" title="var">prod</span></span> głosi: jeżeli <span class="inlinecode"><span class="id" title="var">A</span></span> jest typem sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    oraz <span class="inlinecode"><span class="id" title="var">B</span></span> jest typem sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, to <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest typem sortu
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Jest ona rzecz jasna konsekwencją definicji produktu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#prod"><span class="id" title="inductive">prod</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;prod&nbsp;(A&nbsp;B&nbsp;:&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pair&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;*&nbsp;B&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Regule odpowiada fragment <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. To,
    co w regule jest nad kreską (<span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>), tutaj występuje
    przed dwukropkiem, po prostu jako argumentu typu <span class="inlinecode"><span class="id" title="var">prod</span></span>. Jak widać,
    nagłówek typu induktywnego jest po prostu skompresowaną formą reguły
    formacji.

<div class="paragraph"> </div>

    Należy zauważyć, że nie wszystkie reguły formacji pochodzą z definicji
    induktywnych. Tak wygląda reguła formacji dla funkcji (między typami
    sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>): 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;B&nbsp;:&nbsp;Type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;:&nbsp;Type<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguła nie pochodzi z definicji induktywnej, gdyż typ funkcji <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>
    jest typem wbudowanym i nie jest zdefiniowany indukcyjnie. 
<div class="paragraph"> </div>

<a name="lab137"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisz, bez podglądania, jak wyglądają reguły formacji dla <span class="inlinecode"><span class="id" title="var">option</span></span>,
    <span class="inlinecode"><span class="id" title="var">nat</span></span> oraz <span class="inlinecode"><span class="id" title="var">list</span></span>. Następnie zweryfikuj swoje odpowiedzi za pomocą
    komendy <span class="inlinecode"><span class="id" title="keyword">Print</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab138"></a><h3 class="section">Reguły wprowadzania</h3>

<div class="paragraph"> </div>

 Reguły wprowadzania mówią nam, w jaki sposób formować termy danego
    typu. Większość z nich pochodzi od konstruktorów typów induktywnych.
    Dla typu bool reguły wprowadzania wyglądają tak: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-----------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;true&nbsp;:&nbsp;bool<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;false&nbsp;:&nbsp;bool<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguły te stwierdzają po prostu, że <span class="inlinecode"><span class="id" title="var">true</span></span> jest termem typu <span class="inlinecode"><span class="id" title="var">bool</span></span>
    oraz że <span class="inlinecode"><span class="id" title="var">false</span></span> jest termem typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. Wynikają one wprost z
    definicji typu <span class="inlinecode"><span class="id" title="var">bool</span></span> — każda z nich odpowiada jednemu konstruktorowi.

<div class="paragraph"> </div>

    Wobec powyższego nie powinna zaskoczyć cię reguła wprowadzania dla
    produktu: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;B&nbsp;:&nbsp;Type,&nbsp;a&nbsp;:&nbsp;A,&nbsp;b&nbsp;:&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;--------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pair&nbsp;A&nbsp;B&nbsp;a&nbsp;b&nbsp;:&nbsp;prod&nbsp;A&nbsp;B<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Jeżeli jednak zaskoczyła cię obecność w regule <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>,
    przyjrzyj się dokładnie typowi konstruktora <span class="inlinecode"><span class="id" title="var">pair</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> @<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#pair"><span class="id" title="constructor">pair</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;pair&nbsp;:&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;*&nbsp;B&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Widać tutaj jak na dłoni, że <span class="inlinecode"><span class="id" title="var">pair</span></span> jest funkcją zależną biorącą
    cztery argumenty i zwracają wynik, którego typ jest produktem jej
    dwóch pierwszych argumentów.

<div class="paragraph"> </div>

    Podobnie jak w przypadku reguł formacji, nie wszystkie reguły
    wprowadzania pochodzą od konstruktorów typów induktywnych. W
    przypadku funkcji reguła wygląda mniej więcej tak: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Γ&nbsp;|-&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;:&nbsp;Type,&nbsp;Γ;&nbsp;x&nbsp;:&nbsp;T&nbsp;|-&nbsp;y&nbsp;:&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Γ&nbsp;|-&nbsp;fun&nbsp;x&nbsp;=&gt;&nbsp;y&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Pojawiło się tu kilka nowych rzeczy: litera Γ oznacza kontekst,
    zaś zapis Γ |- j, że osąd j zachodzi w kontekście Γ. Zapis Γ; j
    oznacza rozszerzenie kontekstu Γ poprzez dodanie do niego osądu j.

<div class="paragraph"> </div>

    Regułę możemy odczytać tak: jeżeli <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest typem sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    w kontekście Γ i <span class="inlinecode"><span class="id" title="var">y</span></span> jest termem typu <span class="inlinecode"><span class="id" title="var">B</span></span> w kontekście Γ rozszerzonym
    o osąd <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, to <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">y</span></span> jest termem typu <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> w kontekście
    Γ.

<div class="paragraph"> </div>

    Nie przejmuj się, jeżeli nie rozumiesz powyższej reguły. Znajomość
    reguł wprowadzania nie jest nam potrzebna, by skutecznie posługiwać
    się Coqiem.

<div class="paragraph"> </div>

    Należy też dodać, że reguła ta jest nieco uproszczona. Pełniejszy
    opis teoretyczny induktywnego rachunku konstrukcji można znaleźć
    w rozdziałach 4 i 5 manuala: https://coq.inria.fr/refman/toc.html 
<div class="paragraph"> </div>

<a name="lab139"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisz, bez podglądania, jak wyglądają reguły wprowadzania dla
    <span class="inlinecode"><span class="id" title="var">option</span></span>, <span class="inlinecode"><span class="id" title="var">nat</span></span> oraz <span class="inlinecode"><span class="id" title="var">list</span></span>. Następnie zweryfikuj swoje odpowiedzi
    za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Print</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab140"></a><h3 class="section">Reguły eliminacji</h3>

<div class="paragraph"> </div>

 Reguły eliminacji są w pewien sposób dualne do reguł wprowadzania.
    Tak jak reguły wprowadzania dla typu <span class="inlinecode"><span class="id" title="var">T</span></span> służą do konstruowania
    termów typu <span class="inlinecode"><span class="id" title="var">T</span></span> z innych termów, tak reguły eliminacji dla typu <span class="inlinecode"><span class="id" title="var">T</span></span>
    mówią nam, jak z termów typu <span class="inlinecode"><span class="id" title="var">T</span></span> skonstruować termy innych typów.

<div class="paragraph"> </div>

    Zobaczmy, jak wygląda jedna z reguł eliminacji dla typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;x&nbsp;:&nbsp;A,&nbsp;y&nbsp;:&nbsp;A,&nbsp;b&nbsp;:&nbsp;bool<br/>
&nbsp;&nbsp;&nbsp;&nbsp;--------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;b&nbsp;then&nbsp;x&nbsp;else&nbsp;y&nbsp;:&nbsp;A<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguła ta mówi nam, że jeżeli mamy typ <span class="inlinecode"><span class="id" title="var">A</span></span> oraz dwie wartości
    <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a także term <span class="inlinecode"><span class="id" title="var">b</span></span> typu <span class="inlinecode"><span class="id" title="var">bool</span></span>, to możemy
    skonstruować inną wartość typu <span class="inlinecode"><span class="id" title="var">A</span></span>, mianowicie <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>
    <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>.

<div class="paragraph"> </div>

    Reguła ta jest dość prosta. W szczególności nie jest ona zależna,
    tzn. obie gałęzie <span class="inlinecode"><span class="id" title="keyword">if</span></span>a muszą być tego samego typu. Przyjrzyjmy
    się nieco bardziej ogólnej regule. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Type,&nbsp;x&nbsp;:&nbsp;P&nbsp;true,&nbsp;y&nbsp;:&nbsp;P&nbsp;false,&nbsp;b&nbsp;:&nbsp;bool<br/>
&nbsp;&nbsp;&nbsp;&nbsp;----------------------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;bool_rect&nbsp;P&nbsp;x&nbsp;y&nbsp;b&nbsp;:&nbsp;P&nbsp;b<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguła ta mówi nam, że jeżeli mamy rodzinę typów <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    oraz termy <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>, a także term <span class="inlinecode"><span class="id" title="var">b</span></span>
    typu <span class="inlinecode"><span class="id" title="var">bool</span></span>, to możemy skonstruować term <span class="inlinecode"><span class="id" title="var">bool_rect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> typu
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>.

<div class="paragraph"> </div>

    Spójrzmy na tę regułę z nieco innej strony: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Type,&nbsp;x&nbsp;:&nbsp;P&nbsp;true,&nbsp;y&nbsp;:&nbsp;P&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;----------------------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;bool_rect&nbsp;P&nbsp;x&nbsp;y&nbsp;:&nbsp;forall&nbsp;b&nbsp;:&nbsp;bool,&nbsp;P&nbsp;b<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Widzimy, że reguły eliminacji dla typu induktywnego <span class="inlinecode"><span class="id" title="var">T</span></span> służą do
    konstruowania funkcji, których dziedziną jest <span class="inlinecode"><span class="id" title="var">T</span></span>, a więc mówią
    nam, jak "wyeliminować" term typu <span class="inlinecode"><span class="id" title="var">T</span></span>, aby uzyskać term innego typu. 

<div class="paragraph"> </div>

    Reguły eliminacji występują w wielu wariantach:
<ul class="doclist">
<li> zależnym i niezależnym — w zależności od tego, czy służą do definiowania
      funkcji zależnych, czy nie.

</li>
<li> rekurencyjnym i nierekurencyjnym — te druge służą jedynie do
      przeprowadzania rozumowań przez przypadki oraz definiowania funkcji
      przez pattern matching, ale bez rekurencji. Niektóre typy nie mają
      rekurencyjnych reguł eliminacji.

</li>
<li> pierwotne i wtórne — dla typu induktywnego <span class="inlinecode"><span class="id" title="var">T</span></span> Coq generuje regułę
      <span class="inlinecode"><span class="id" title="var">T_rect</span></span>, którą będziemy zwać regułą pierwotną. Jej postać wynika
      wprost z definicji typu <span class="inlinecode"><span class="id" title="var">T</span></span>. Reguły dla typów nieinduktywnych (np.
      funkcji) również będziemy uważać za pierwotne. Jednak nie wszystkie
      reguły są pierwotne — przekonamy się o tym w przyszłości, tworząc
      własne reguły indukcyjne.

</li>
</ul>

<div class="paragraph"> </div>

 Zgodnie z zaprezentowaną klasyfikacją, pierwsza z naszych reguł jest:
<ul class="doclist">
<li> niezależna, gdyż obie gałęzie <span class="inlinecode"><span class="id" title="keyword">if</span></span>a są tego samego typu. Innymi słowy,
      definiujemy term typu <span class="inlinecode"><span class="id" title="var">A</span></span>, który nie jest zależny

</li>
<li> nierekurencyjna, gdyż typ <span class="inlinecode"><span class="id" title="var">bool</span></span> nie jest rekurencyjny i wobec tego
      może posiadać jedynie reguły nierekurencyjne

</li>
<li> wtórna — regułą pierwotną dla <span class="inlinecode"><span class="id" title="var">bool</span></span> jest <span class="inlinecode"><span class="id" title="var">bool_rect</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Druga z naszych reguł jest:
<ul class="doclist">
<li> zależna, gdyż definiujemy term typu zależnego <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>

</li>
<li> nierekurencyjna z tych samych powodów, co reguła pierwsza

</li>
<li> pierwotna — Coq wygenerował ją dla nas automatycznie 
</li>
</ul>

<div class="paragraph"> </div>

 W zależności od kombinacji powyższych cech reguły eliminacji mogą
    występować pod różnymi nazwami:
<ul class="doclist">
<li> reguły indukcyjne są zależne i rekurencyjne. Służą do definiowania
      funkcji, których przeciwdziedzina jest sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a więc do
      dowodzenia zdań przez indukcję

</li>
<li> rekursory to rekurencyjne reguły eliminacji, które służą do definiowania
      funkcji, których przeciwdziedzina jest sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span> lub <span class="inlinecode"><span class="id" title="keyword">Type</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Nie przejmuj się natłokiem nazw ani rozróżnień. Powyższą klasyfikację
    wymyśliłem na poczekaniu i nie ma ona w praktyce żadnego znaczenia.

<div class="paragraph"> </div>

    Zauważmy, że podobnie jak nie wszystkie reguły formacji i wprowadzania
    pochodzą od typów induktywnych, tak i nie wszystkie reguły eliminacji
    od nich pochodzą. Kontrprzykładem niech będzie reguła eliminacji dla
    funkcji (niezależnych): 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;B&nbsp;:&nbsp;Type,&nbsp;f&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B,&nbsp;x&nbsp;:&nbsp;A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;x&nbsp;:&nbsp;B<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguła ta mówi nam, że jeżeli mamy funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> oraz
    argument <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>, to aplikacja funkcji <span class="inlinecode"><span class="id" title="var">f</span></span> do argumentu <span class="inlinecode"><span class="id" title="var">x</span></span>
    jest typu <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

    Zauważmy też, że mimo iż reguły wprowadzania i eliminacji są w pewien
    sposób dualne, to istnieją między nimi różnice.

<div class="paragraph"> </div>

    Przede wszystkim, poza regułami wbudowanymi, obowiązuje prosta zasada:
    jeden konstruktor typu induktywnego — jedna reguła wprowadzania. Innymi
    słowy, reguły wprowadzania dla typów induktywnych pochodzą bezpośrednio
    od konstruktorów i nie możemy w żaden sposób dodać nowych. Są one w
    pewien sposób pierwotne i nie mamy nad nimi (bezpośredniej) kontroli.

<div class="paragraph"> </div>

    Jeżeli chodzi o reguły eliminacji, to są one, poza niewielką ilością
    reguł pierwotnych, w pewnym sensie wtórne —
    możemy budować je z pattern matchingu i rekursji strukturalnej i to
    właśnie te dwie ostatnie idee są w Coqu ideami pierwotnymi. Jeżeli
    chodzi o kontrolę, to możemy swobodnie dodawać nowe reguły eliminacji
    za pomocą twierdzeń lub definiując je bezpośrednio.

<div class="paragraph"> </div>

    Działanie takie jest, w przypadku nieco bardziej zaawansowanych
    twierdzeń niż dotychczas widzieliśmy, bardzo częste. Ba! Częste
    jest także tworzenie reguł eliminacji dla każdej funkcji z osobna,
    perfekcyjnie dopasowanych do kształtu jej rekursji. Jest to nawet
    bardzo wygodne, gdyż Coq potrafi automatycznie wygenerować dla nas
    takie reguły.

<div class="paragraph"> </div>

    Przykładem niestandardowej reguły może być reguła eliminacji dla
    list działająca "od tyłu": 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;P&nbsp;:&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;H&nbsp;:&nbsp;P&nbsp;<span class="inlinecode">[]</span>,&nbsp;H'&nbsp;:&nbsp;forall&nbsp;(h&nbsp;:&nbsp;A)&nbsp;(t&nbsp;:&nbsp;list&nbsp;A),&nbsp;P&nbsp;t&nbsp;-&gt;&nbsp;P&nbsp;(t&nbsp;++&nbsp;<span class="inlinecode"><span class="id" title="var">h</span></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-------------------------------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;l&nbsp;:&nbsp;list&nbsp;A,&nbsp;P&nbsp;l<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Póki co wydaje mi się, że udowodnienie słuszności tej reguły będzie dla
    nas za trudne. W przyszłości na pewno napiszę coś więcej na temat reguł
    eliminacji, gdyż ze względu na swój "otwarty" charakter są one z punktu
    widzenia praktyki najważniejsze.

<div class="paragraph"> </div>

    Tymczasem na otarcie łez zajmijmy się inną, niestandardową regułą dla
    list. 
<div class="paragraph"> </div>

<a name="lab141"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, że reguła dla list "co dwa" jest słuszna. Zauważ, że komenda
    <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> może służyć do podawania definicji rekurencyjnych nie tylko
    "ręcznie", ale także za pomocą taktyk.

<div class="paragraph"> </div>

    Wskazówka: użycie hipotezy indukcyjnej <span class="inlinecode"><span class="id" title="var">list_ind_2</span></span> zbyt wcześnie
    ma podobne skutki co wywołanie rekurencyjne na argumencie, który
    nie jest strukturalnie mniejszy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="EliminationRules"><span class="id" title="module">EliminationRules</span></a>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#"><span class="id" title="library">List</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="EliminationRules.list_ind_2"><span class="id" title="definition">list_ind_2</span></a><br/>
&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">H0</span> : <a class="idref" href="R2.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a>) (<span class="id" title="var">H1</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="R2.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">[</span></a><a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">]</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">H2</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="R2.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="R2.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="R2.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="R2.html#l"><span class="id" title="variable">l</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="R2.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="R2.html#l"><span class="id" title="variable">l</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab142"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisz funkcję <span class="inlinecode"><span class="id" title="tactic">apply</span></span>, odpowiadającą regule eliminacji dla funkcji
    (niezależnych). Udowodnij jej specyfikację.

<div class="paragraph"> </div>

    Uwaga: notacja "$" na oznaczenie aplikacji funkcji pochodzi z języka
    Haskell i jest tam bardzo często stosowana, gdyż pozwala zaoszczędzić
    stawiania zbędnych nawiasów. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="757e2a06176f35664710c45fa45a7e8f"><span class="id" title="notation">&quot;</span></a>f $ x" := (<a class="idref" href="R2.html#EliminationRules.apply"><span class="id" title="definition">apply</span></a> <span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 5).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="EliminationRules.apply_spec"><span class="id" title="lemma">apply_spec</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R2.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">x</span> : <a class="idref" href="R2.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="R2.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="R2.html#757e2a06176f35664710c45fa45a7e8f"><span class="id" title="notation">$</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="R2.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="R2.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R2.html#EliminationRules"><span class="id" title="module">EliminationRules</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab143"></a><h3 class="section">Reguły obliczania</h3>

<div class="paragraph"> </div>

 TODO 
<div class="paragraph"> </div>

<a name="lab144"></a><h1 class="section">Rekursja</h1>

<div class="paragraph"> </div>

 Powinieneś już potrafić całkiem sprawnie posługiwać się prostą rekursją,
    a skoro tak, to czas poznać teoretyczne podstawy jej funkcjonowania.

<div class="paragraph"> </div>

    Ogólnie funkcja rekurencyjna to taka, która w swojej definicji odnosi
    się do samej siebie. Rodzaje rekurencji można podzielić w zależności
    od tego, w jaki sposób to robi:
<ul class="doclist">
<li> Rekursja strukturalna to taka, w której funkcja wywołuje siebie
      na argumentach o coraz mniejszym "rozmiarze".

</li>
<li> Rekursja dobrze ufundowana to taka, w której funkcja wywołuje siebie
      jedynie na argumentach "mniejszych", gdzie o tym, które termy są
      mniejsze, a które większe, decyduje pewna relacja dobrze ufundowana.
      Intuicyjnie relacja dobrze ufundowana to taka, że nie możemy
      w nieskończoność robić wywołań rekurencyjnych na coraz mniejszych
      argumentach, gdyż w końcu trafimy na najmniejszy.

</li>
<li> Funkcje f i g są wzajemnie rekurencyjne, gdy funkcja f wywołuje g,
      a g wywołuje f. To, że f nie wywołuje samej siebie bezpośrednio nie
      oznacza wcale, że nie jest rekurencyjna. Schemat ten można uogólnić
      na dowolną ilość funkcji.

</li>
<li> Rekursja ogólna to taka, w którym funkcja może odwoływać się do
      samej siebie w dowolny sposób. 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab145"></a><h2 class="section">Rekursja ogólna</h2>

<div class="paragraph"> </div>

 W Coqu rekursja ogólna nie jest dozwolona. Powód jest prozaiczny:
    jest ona sprzeczna. W celu zobrazowania spróbujmy zdefiniować za
    pomocą taktyk następującą funkcję rekurencyjną: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="loop"><span class="id" title="definition">loop</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">loop</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Abort</span>. <span class="comment">(*&nbsp;Coq&nbsp;odrzuca&nbsp;komendę&nbsp;<span class="inlinecode"><span class="id" title="keyword">Qed</span>.</span>&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Przyjrzyjmy się uważnie definicji funkcji <span class="inlinecode"><span class="id" title="var">loop</span></span>. Mimo, że udało
    nam się ujrzeć znajomy napis "No more subgoals", próba użycia
    komendy <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> kończy się błędem. Gdyby tak się nie stało, możliwe
    byłoby skonstruowanie dowodu <span class="inlinecode"><span class="id" title="var">False</span></span>: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Definition&nbsp;the_universe_explodes&nbsp;:&nbsp;False&nbsp;:=&nbsp;loop&nbsp;tt.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Aby chronić nas przed tą katastrofą, Coq nakłada na rekurencję
    ograniczenie: argument główny wywołania rekurencyjnego musi być
    strukturalnym podtermem argumentu głównego obecnego wywołania.
    Innymi słowy, dozwolona jest jedynie rekursja strukturalna. 
<div class="paragraph"> </div>

<a name="lab146"></a><h2 class="section">Rekursja strukturalna (todo)</h2>

<div class="paragraph"> </div>

 Przyjrzyjmy się ponownie definicji dodawania: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Nat.html#add"><span class="id" title="definition">plus</span></a>.<br/>
<span class="comment">(*&nbsp;plus&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;&nbsp;fix&nbsp;plus&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;m<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;S&nbsp;(plus&nbsp;p&nbsp;m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Możemy zaobserwować parę rzeczy. Pierwsza, techniczna sprawa: po
    <span class="inlinecode">=</span> widzimy nieznany nam konstrukt <span class="inlinecode"><span class="id" title="keyword">fix</span></span>. Pozwala on tworzyć
    anonimowe funkcje rekruencyjne, tak jak <span class="inlinecode"><span class="id" title="keyword">fun</span></span> pozwala tworzyć
    anonimowe funkcje nierekurencyjne. Funkcje zdefiniowane komendami 
    <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> i <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> są w jęzku termów Coqa reprezentowane
    odpowiednio za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span> i <span class="inlinecode"><span class="id" title="keyword">fun</span></span>.

<div class="paragraph"> </div>

    Po drugie: za listą argumentów, a przed zwracanym typem, występuje
    adnotacja <span class="inlinecode">{<span class="id" title="keyword">struct</span></span> <span class="inlinecode"><span class="id" title="var">n</span>}</span>. Wskazuje ona, który z argumentów funkcji
    jest argumentem głównym. Definiując funkcje rekurencyjne zazwyczaj
    nie musimy go pisać, gdyż Coq jest w stanie sam wywnioskować, który
    argument jest główny.

<div class="paragraph"> </div>

    Czym jest argument główny? Aby to zrozumieć, zbadajmy najpierw
    relację bycia podtermem (dla uproszczenia, skupimy się na termach
    typów induktywnych). Relację tę opisują dwie proste zasady:
<ul class="doclist">
<li> po pierwsze, jeżeli dany term został skonstruowany pewnym konstruktorem,
      to jego podtermami są rekurencyjne argumenty konstruktora. Przykład:
      <span class="inlinecode">0</span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span>, zaś <span class="inlinecode"><span class="id" title="var">nil</span></span> podtermem <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode">42</span> <span class="inlinecode"><span class="id" title="var">nil</span></span>.

</li>
<li> po drugie, jeżeli <span class="inlinecode"><span class="id" title="var">t1</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">t2</span></span>, a <span class="inlinecode"><span class="id" title="var">t2</span></span> podtermem <span class="inlinecode"><span class="id" title="var">t3</span></span>,
      to <span class="inlinecode"><span class="id" title="var">t1</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">t3</span></span> — własność ta nazywa się tranzytywnością.
      Przykład: <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span>, a zatem <span class="inlinecode">0</span> jest podtermem
      <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span>. Podobnie <span class="inlinecode"><span class="id" title="var">nil</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode">666</span> <span class="inlinecode">(<span class="id" title="var">cons</span></span> <span class="inlinecode">42</span> <span class="inlinecode"><span class="id" title="var">nil</span>)</span> 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab147"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj relacje bycia podtermem dla liczb naturalnych i list. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Udowodnij, że przytoczone wyżej przykłady nie są oszustwem.
    Komenda <span class="inlinecode"><span class="id" title="keyword">Goal</span></span> jest wygodna, gdyż używając jej nie musimy
    nadawać twierdzeniu nazwy. Użycie <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> zapisze twierdzenie
    jako <span class="inlinecode"><span class="id" title="var">Unnamed_thm</span></span>, <span class="inlinecode"><span class="id" title="var">Unnamed_thm0</span></span>, <span class="inlinecode"><span class="id" title="var">Unnamed_thm1</span></span> etc. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="R2.html#subterm_list"><span class="id" title="inductive">subterm_list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> 42 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>).<br/>

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="R2.html#subterm_nat"><span class="id" title="inductive">subterm_nat</span></a> 0 (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> 0).<br/>

<br/>

<br/>

<br/>
</div>

<div class="doc">
Argument główny to ten, który jest dopasowywany jako pierwszy. Argumentami
    głównymi w wywołaniach rekurencyjnych mogą być jedynie podtermy argumentu
    głównego z obecnego wywołania.

<div class="paragraph"> </div>

    Argumentem głównym funkcji <span class="inlinecode"><span class="id" title="var">plus</span></span> jest jej pierwszy argument (o czym
    informuje nas adnotacja <span class="inlinecode">{<span class="id" title="keyword">struct</span></span> <span class="inlinecode"><span class="id" title="var">n</span>}</span>), gdyż to on jest dopasowywany
    jako pierwszy (i jedyny). W przypadku gdy <span class="inlinecode"><span class="id" title="var">n</span></span> jest równe <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, <span class="inlinecode"><span class="id" title="var">plus</span></span>
    jest wywoływany rekurencyjnie z argumentami <span class="inlinecode"><span class="id" title="var">p</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span>, co jest dozwolone,
    gdyż jego argument główny, <span class="inlinecode"><span class="id" title="var">p</span></span>, jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>. 
</div>
<div class="code">
</div>
