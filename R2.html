<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
</head>
<h1 class="libtitle">R2: Indukcja i rekursja (alfa</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 W poprzednim rozdziale dowiedzieliśmy się już co nieco o typach, a
    także spotkaliśmy kilka z nich oraz kilka sposobów tworzenia nowych
    typów ze starych (takich jak np. koniunkcja; pamiętaj, że zdania są
    typami). W tym rozdziale dowiemy się o nich nieco więcej: spotkamy
    się z ich sortami oraz uniwersami, w których żyją; dowiemy się, jak
    definiować nowe typy przy pomocy indukcji oraz jak użyć rekursji do
    tworzenia funkcji, które konstruują i dekonstruują ich termy. 
<div class="paragraph"> </div>

<a name="lab57"></a><h1 class="section">Sorty</h1>

<div class="paragraph"> </div>

 Jeżeli przeczytałeś uważnie sekcję "Typy i termy" z poprzedniego
    rozdziału, zauważyłeś zapewne stwierdzenie, że typy są termami.
    W połączeniu ze stwierdzeniem, że każdy term ma swój typ, zrodzić
    musi się pytanie: jakiego typu są typy? Zacznijmy od tego, że
    żeby uniknąć używania mało poetyckiego określenia "typy typów",
    typy typów nazywamy sortami. 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>, jak już wiesz, jest sortem zdań logicznych. Jeżeli
    <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span></span> oraz <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> (tzn. <span class="inlinecode"><span class="id" type="var">A</span></span> jest sortu <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>), to typ
    <span class="inlinecode"><span class="id" type="var">P</span></span> możemy interpretować jako zdanie logiczne, a term <span class="inlinecode"><span class="id" type="var">x</span></span>
    jako jego dowód. Na przykład <span class="inlinecode"><span class="id" type="var">I</span></span> jest dowodem zdania <span class="inlinecode"><span class="id" type="var">True</span></span>,
    tzn. <span class="inlinecode"><span class="id" type="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">True</span></span>, zaś term <span class="inlinecode">42</span> nie jest dowodem <span class="inlinecode"><span class="id" type="var">True</span></span>, gdyż
    <span class="inlinecode">42</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;True&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#I"><span class="id" type="constructor">I</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;I&nbsp;:&nbsp;True&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> 42.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;42&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
O ile jednak każde zdanie logiczne jest typem, nie każdy typ jest
    zdaniem — przykładem niech będą liczby naturalne <span class="inlinecode"><span class="id" type="var">nat</span></span>. Sortem <span class="inlinecode"><span class="id" type="var">nat</span></span>
    jest <span class="inlinecode"><span class="id" type="keyword">Set</span></span>. Niech nie zmyli cię ta nazwa: <span class="inlinecode"><span class="id" type="keyword">Set</span></span> nie ma nic wspólnego
    ze zbiorami znanymi choćby z teorii zbiorów ZF.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" type="keyword">Set</span></span> jest sortem, w którym żyją specyfikacje. Jeżeli <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span></span> oraz
    <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Set</span></span> (tzn. sortem <span class="inlinecode"><span class="id" type="var">A</span></span> jest <span class="inlinecode"><span class="id" type="keyword">Set</span></span>), to <span class="inlinecode"><span class="id" type="var">A</span></span> możemy interpretować
    jako specyfikację pewnej klasy programów, a term <span class="inlinecode"><span class="id" type="var">x</span></span> jako program,
    który tę specyfikację spełnia (implementuje). Na przykład <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span>
    jest programem, ktory spełnia specyfikację <span class="inlinecode"><span class="id" type="var">nat</span></span>, tzn. <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span>,
    zaś <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">n</span></span> nie spełnia specyfikacji <span class="inlinecode"><span class="id" type="var">nat</span></span>, gdyż
    <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nat&nbsp;:&nbsp;Set&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> 2.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;2&nbsp;+&nbsp;2&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> ⇒ <a class="idref" href="R2.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="comment">(*&nbsp;fun&nbsp;n&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;n&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Oczywiście w przypadku typu <span class="inlinecode"><span class="id" type="var">nat</span></span> mówiene o specyfikacji jest trochę
    na wyrost, gdyż określenie "specyfikacja" kojarzy nam się z czymś,
    co określa właściwości, jakie powinien mieć spełniający ją program.
    O takich specyfikacjach dowiemy się więcej w kolejnych rozdziałach.
    Choć każda specyfikacja jest typem, to rzecz jasna nie każdy typ jest
    specyfikacją — niektóre typy są przecież zdaniami. 
<div class="paragraph"> </div>

<a name="lab58"></a><h1 class="section">Hierarchia uniwersów</h1>

<div class="paragraph"> </div>

 Uwaga: ta sekcja jest czysto teoretyczna. Jeżeli boisz
    się uprawiania teorii dla samej teorii, możesz ją pominąć.

<div class="paragraph"> </div>

    Jeżeli czytasz uważnie, to pewnie wciąż czujesz niedosyt — wszakże
    sorty, jako typy, także są termami. Jakie są więc typy/sorty sortów?
    Przekonajmy się. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="keyword">Prop</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;:&nbsp;Type&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="keyword">Set</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Set&nbsp;:&nbsp;Type&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="keyword">Prop</span></span> oraz <span class="inlinecode"><span class="id" type="keyword">Set</span></span> są typu/sortu <span class="inlinecode"><span class="id" type="keyword">Type</span></span>, który bywa też nazywany
    uniwersum. To stwierdzenie wciąż jednak pewnie nie zaspakaja twojej
    ciekawości. Pójdźmy więc po nitce do kłębka. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="keyword">Type</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Type&nbsp;:&nbsp;Type&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Zdaje się, że osiągnęliśmy kłębek i że <span class="inlinecode"><span class="id" type="keyword">Type</span></span> jest typu <span class="inlinecode"><span class="id" type="keyword">Type</span></span>.
    Rzeczywistość jest jednak o wiele ciekawsza. Gdyby rzeczywiście
    zachodziło <span class="inlinecode"><span class="id" type="keyword">Type</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Type</span></span>, doszłoby do paradoksu znanego jako
    paradoks Girarda (którego omówienie jednak pominiemy). Prawda
    jest inna. 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Set&nbsp;Printing&nbsp;Universes.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Uwaga: powyższa komenda zadziała jedynie w konsoli (program coqtop).
    Aby osiągnąć ten sam efekt w CoqIDE, zaznacz opcję
    View &gt; Display universe levels. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="keyword">Type</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Type&nbsp;<span class="comment">(*&nbsp;Top.7&nbsp;*)</span>&nbsp;:&nbsp;Type&nbsp;<span class="comment">(*&nbsp;(Top.7)+1&nbsp;*)</span>&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Co oznacza ten dziwny napis? Otóż w Coqu mamy do czynienia nie z
    jednym, ale z wieloma (a nawet nieskończenie wieloma) uniwersami.
    Uniwersa te są numerowane liczbami naturalnymi: najniższe uniwersum
    ma numer 0, a każde kolejne o jeden większy. Wobec tego hierarchia
    uniwersów wygląda tak (użyta notacja nie jest tą, której używa Coq;
    została wymyślona ad hoc):

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="keyword">Set</span></span> jest typu/sortu <span class="inlinecode"><span class="id" type="keyword">Type</span>(0)</span>

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">Type</span>(0)</span> jest typu/sortu <span class="inlinecode"><span class="id" type="keyword">Type</span>(1)</span>

</li>
<li> w ogólności, <span class="inlinecode"><span class="id" type="keyword">Type</span>(<span class="id" type="var">i</span>)</span> jest typu/sortu <span class="inlinecode"><span class="id" type="keyword">Type</span>(<span class="id" type="var">i</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> 
</li>
</ul>

<div class="paragraph"> </div>

 Aby uniknąć paradoksu, definicje odnoszące się do typów żyjących
    na różnych poziomach hierarchii muszą same bytować w uniwersum
    na poziomie wyższym niż każdy z tych, do których się odwołują.
    Aby to zapewnić, Coq musi pamiętać, na którym poziomie znajduje
    każde użycie <span class="inlinecode"><span class="id" type="keyword">Type</span></span> i odpowiednio dopasowywać poziom hierarchii,
    do którego wrzucone zostaną nowe definicje.

<div class="paragraph"> </div>

    Co więcej, w poprzednim rozdziale dopuściłem się drobnego kłamstewka
    twierdząc, że każdy term ma dokładnie jeden typ. W pewnym sensie nie
    jest tak, gdyż powyższa hierarcha jest <i>kumulatywna</i> — znaczy to, że
    jeśli <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Type</span>(<span class="id" type="var">i</span>)</span>, to także <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Type</span>(<span class="id" type="var">j</span>)</span> dla i &lt; j. Tak więc każdy
    typ, którego sortem jest <span class="inlinecode"><span class="id" type="keyword">Type</span></span>, nie tylko nie ma unikalnego typu/sortu,
    ale ma ich nieskończenie wiele.

<div class="paragraph"> </div>

    Brawo! Czytając tę sekcję, dotarłeś do króliczej nory i posiadłeś
    wiedzę tajemną, której prawie na pewno nigdy ani nigdzie nie użyjesz.
    Możemy zatem przejść do meritum. 
</div>
<div class="code">

<br/>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>