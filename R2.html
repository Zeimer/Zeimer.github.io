<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
</head>
<h1 class="libtitle">R2</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab44"></a><h1 class="section">W2 : Indukcja i rekursja.</h1>

<div class="paragraph"> </div>

 Coq jest językiem silnie typowanym — każdy term ma dokładnie jeden
    typ, który jest niezmienny. Co więcej, jego system typów jest tak
    potężny, że umożliwia nam wiele rzeczy, których prawie żaden inny
    język programowania nie potrafi, jak np. reprezentowanie
    skomplikowanych obiektów matematycznych i dowodzenie twierdzeń.
    Typy w Coqu dzielą się na dwa rodzaje: induktywne i koinduktywne,
    z których zdecydowanie ważniejsze są te pierwsze. 
<div class="paragraph"> </div>

<a name="lab45"></a><h1 class="section">Typy induktywne</h1>

<div class="paragraph"> </div>

 Typ induktywny definiuje się przy pomocy zbioru konstruktorów,
    które służą do budowania jego elementów. Konstruktory te są
    funkcjami, ale niczego nie obliczają — nadają one typowi jego
    kształt. W szczególności, nie mają nic wspólnego z konstruktorami
    w takich językach jak C++ lub Java — nie mogą przetwarzać swoich
    argumentów, alokować pamięci, dokonywać operacji wejścia/wyjścia
    etc. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">bool</span> : <span class="id" type="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">true</span> : <span class="id" type="var">bool</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">false</span> : <span class="id" type="var">bool</span>.<br/>

<br/>
</div>

<div class="doc">
Naszym pierwszym przykładem będzie typ <span class="inlinecode"><span class="id" type="var">bool</span></span>. Definicja typu
    induktywnego ma następującą postać: najpierw występuje słowo
    kluczowe <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>, następnie nazwa typu, a po dwukropku sort,
    którym zajmiemy się za chwilę. Następnie mamy symbol <span class="inlinecode">:=</span>
    służący do definiowania, który należy odróżnić od symbolu <span class="inlinecode">=</span>,
    który oznacza równość. Dalej wymienione są konstruktory
    definiowanego typu. Mają one swoje unikalne nazwy i są funkcjami,
    których przeciwdziedziną jest definiowany typ. W naszym przypadku
    mamy 2 konstruktory, zwane <span class="inlinecode"><span class="id" type="var">true</span></span> oraz <span class="inlinecode"><span class="id" type="var">false</span></span>, które są funkcjami
    0-argumentowymi. Definicja, jak każda komenda, kończy się kropką. 
<div class="paragraph"> </div>

 Czym jest <span class="inlinecode"><span class="id" type="keyword">Set</span></span>, który nazwaliśmy sortem zdefiniowanego przez nas
    typu <span class="inlinecode"><span class="id" type="var">bool</span></span>? Jako że każdy term musi mieć swój typ, a typy także
    są termami, to każdy typ musi mieć swój własny typ, który nazywamy
    sortem. Oczywiśce na tym się nie kończy — sorty także są termami,
    czyli muszą mieć swoje własne typy etc. 
<div class="paragraph"> </div>

 W Coqu są trzy główne sorty:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="keyword">Set</span></span> jest sortem, w którym żyją typy i programy

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> jest sortem, w którym żyją zdania logiczne i dowody

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">Type</span></span> jest sortem sortów <span class="inlinecode"><span class="id" type="keyword">Set</span></span> oraz <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>, tzn. zachodzi
      <span class="inlinecode"><span class="id" type="keyword">Set</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Type</span></span> oraz <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Type</span></span>. Nie będziemy się nim na
      razie zajmować — w szczególności, nie przejmuj się jakiego
      typu/sortu jest <span class="inlinecode"><span class="id" type="keyword">Type</span></span> 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">negb</span> (<span class="id" type="var">b</span> : <span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> :=<br/>
<span class="id" type="keyword">match</span> <span class="id" type="var">b</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">true</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">false</span> ⇒ <span class="id" type="var">true</span><br/>
<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Mając typ induktywny, możemy definiować funkcje. Podstawowym
    narzędziem do tego służącym jest pattern matching (ang.
    "dopasowywanie do wzorca"). Pozwala on sprawdzić, którego
    konstruktora użyto do zrobienia dopasowywanej wartości.
    Nasza funkcja działa następująco: sprawdzamy, którym
    konstruktorem zrobiono argument <span class="inlinecode"><span class="id" type="var">b</span></span> — jeżeli było to <span class="inlinecode"><span class="id" type="var">true</span></span>,
    zwracamy wartość typu <span class="inlinecode"><span class="id" type="var">bool</span></span> zrobioną konstruktorem <span class="inlinecode"><span class="id" type="var">false</span></span>,
    a gdy <span class="inlinecode"><span class="id" type="var">b</span></span> zostało zrobione konstruktorem <span class="inlinecode"><span class="id" type="var">false</span></span>, zwracamy
    <span class="inlinecode"><span class="id" type="var">true</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">compute</span> <span class="id" type="keyword">in</span> <span class="id" type="var">negb</span> <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Odpalenie danej funkcji w Coqu jest dość toporne — wymaga to
    użycia komendy <span class="inlinecode"><span class="id" type="keyword">Eval</span></span> <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> lub <span class="inlinecode"><span class="id" type="keyword">Eval</span></span> <span class="inlinecode"><span class="id" type="tactic">compute</span></span>, jak w powyższym
    przykładzie. Wynika to z faktu, że Coq nie został stworzony do
    wykonywania programów, a jedynie do ich definiowania i dowodzenia
    ich poprawności. Aby użyć programu napisanego w Coqu w świecie
    rzeczywistym, stosuje się zazwyczaj mechanizm ekstrakcji,
    który pozwala z programu napisanego w Coqu atuomatycznie uzyskać
    program napisany w Scheme, OCamlu lub Haskellu, które są od Coqa
    dużo szybsze. 
<div class="paragraph"> </div>

 Zdefiniowawszy naszą funkcję, możemy zadać sobie pytanie:
    czy definicja jest poprawna? Gdybyśmy pisali w jednym z
    języków imperatywnych, moglibyśmy napisać dla niej testy
    jednostkowe. Coq umożliwia nam coś dużo silniejszego:
    możemy wyrazić przy pomocy twierdzenia, że funkcja posiada
    interesującą nas własność, a następnie spróbować je udowodnić.
    Jeżeli nam się powiedzie, mamy całkowitą pewność, że funkcja
    rzeczywiście posiada żądaną własność. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">negb_involutive</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> : <span class="id" type="var">bool</span>, <span class="id" type="var">negb</span> (<span class="id" type="var">negb</span> <span class="id" type="var">b</span>) = <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Nasze twierdzenie głosi, że funkcja <span class="inlinecode"><span class="id" type="var">negb</span></span> jest inwolucją,
    tzn. że dwukrotne jej zaaplikowanie do danego argumentu
    nie zmienia go. 
<div class="paragraph"> </div>

 Dowód przebiega w następujący sposób: taktyką <span class="inlinecode"><span class="id" type="tactic">intro</span></span>
    wprowadzamy zmienną <span class="inlinecode"><span class="id" type="var">b</span></span> do kontekstu, a następnie
    używamy taktyki <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>, aby sprawdzić, którym
    konstruktorem została zrobiona. Ponieważ typ <span class="inlinecode"><span class="id" type="var">bool</span></span> ma
    dwa konstruktory, taktyka ta generuje nam dwa podcele:
    musimy udowodnić twierdzenie osobno dla przypadku, gdy
    <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span> oraz dla <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">false</span></span>. Potem przy pomocy
    taktyki <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> obliczamy wartość naszej funkcji —
    zauważ, że byłoby to niemożliwe, gdyby argument był
    postaci <span class="inlinecode"><span class="id" type="var">b</span></span>, ale jest jak najbardziej możliwe, gdy jest
    on postaci <span class="inlinecode"><span class="id" type="var">true</span></span> albo <span class="inlinecode"><span class="id" type="var">false</span></span>. Na koniec używamy taktyki
    <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>, która potrafi udowodnić cel postaci
    a = a. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">negb_involutive'</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> : <span class="id" type="var">bool</span>, <span class="id" type="var">negb</span> (<span class="id" type="var">negb</span> <span class="id" type="var">b</span>) = <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Zauważmy, że nie musimy używać taktyki <span class="inlinecode"><span class="id" type="tactic">intro</span></span>, żeby wprowadzić
    <span class="inlinecode"><span class="id" type="var">b</span></span> do kontekstu: taktyka <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> sama jest w stanie wykryć,
    że nie ma jej w kontekście i wprowadzić ją tam przed rozbiciem
    jej na konstruktory. Zauważmy też, że oba podcele rozwiązaliśmy
    w ten sam sposób, więc możemy użyć kombinatora <span class="inlinecode">;</span> (średnika),
    żeby rozwiązać je oba za jednym zamachem. 
<div class="paragraph"> </div>

<a name="lab46"></a><h4 class="section">Ćwiczenie 1.</h4>
 Zdefiniuj funkcje <span class="inlinecode"><span class="id" type="var">andb</span></span> (koniunkcja boolowska) oraz <span class="inlinecode"><span class="id" type="var">orb</span></span>
    (alternatywa boolowska). Napisz i udowodnij twierdzenie,
    które mówi, że funkcje te są przemienne. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">andb</span> (<span class="id" type="var">b1</span> <span class="id" type="var">b2</span> : <span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> :=<br/>
<span class="id" type="keyword">match</span> <span class="id" type="var">b1</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">true</span> ⇒ <span class="id" type="var">b2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">false</span> ⇒ <span class="id" type="var">false</span><br/>
<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">orb</span> (<span class="id" type="var">b1</span> <span class="id" type="var">b2</span> : <span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> :=<br/>
<span class="id" type="keyword">match</span> <span class="id" type="var">b1</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">true</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">false</span> ⇒ <span class="id" type="var">b2</span><br/>
<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_comm</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">andb</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span> = <span class="id" type="var">andb</span> <span class="id" type="var">b2</span> <span class="id" type="var">b1</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">b1</span>, <span class="id" type="var">b2</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">orb_comm</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">orb</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span> = <span class="id" type="var">orb</span> <span class="id" type="var">b2</span> <span class="id" type="var">b1</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">b1</span>, <span class="id" type="var">b2</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab47"></a><h2 class="section">Notacje</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Notation</span> "b1 &amp;&amp; b2" := (<span class="id" type="var">andb</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span>).<br/>
<span class="id" type="keyword">Notation</span> "b1 || b2" := (<span class="id" type="var">orb</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span>).<br/>

<br/>
</div>

<div class="doc">
Coq dysponuje również potężnym systemem notacji, które pozwalają
    nam uprościć sposób zapisywania funkcji, typów czy predykatów. 
<div class="paragraph"> </div>

<a name="lab48"></a><h1 class="section">Ltac — język taktyk</h1>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_dist_orb</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span> <span class="id" type="var">b3</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">b1</span> &amp;&amp; (<span class="id" type="var">b2</span> || <span class="id" type="var">b3</span>) = (<span class="id" type="var">b1</span> &amp;&amp; <span class="id" type="var">b2</span>) || (<span class="id" type="var">b1</span> &amp;&amp; <span class="id" type="var">b3</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">b1</span>, <span class="id" type="var">b2</span>, <span class="id" type="var">b3</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższe twierdzenie mówi, że koniunkcja boolowska jest rozdzielna
    względem alternatywy boolowskiej, ale dużo ważniejszy jest jego
    dowód. Myślę, że dostrzegasz już pewien schemat, jeżeli chodzi
    o dowodzenie właściwości funkcji boolowskich: sprowadza się to
    do rozbicia zmiennych na przypadki i obliczenia funkcji, w wyniku
    czego, jeżeli twierdzenie rzeczywiście jest prawdziwe, dostajemy
    pewną ilość tryiwalnych równości. 
<div class="paragraph"> </div>

 Gdybyśmy chcieli zdefiniować więcej funkcji boolowskich i dowodzić
    ich właściwości, moglibyśmy po prostu kopiować dowody i ewentualnie
    przystosowywać je do
    ilości występujących w twierdzeniach zmiennych boolowskich. Nie
    jest to jednak dobry pomysł. Tak jak programista nie powinien
    kopiować fragmentów kodu i wklejać ich gdzie indziej, tak też
    matematyk nie powinien kopiować i wklejać fragmentów dowodów.
    Programista dysponuje narzędziem, które pozwala mu tego uniknąć
    — jest nim możliwość pisania własnych funkcji/procedur, które
    pozwalają nadać kawałkowi kodu nazwę i odwoływać się do niego
    przy jej użyciu. Podobnym narzędziem dysponuje matematyk dowodzący
    w Coqu — jest nim możliwość pisania własnych taktyk w języku <span class="inlinecode"><span class="id" type="keyword">Ltac</span></span>.
    Dotychczas spotkaliśmy jedynie taktyki standardowe, jak <span class="inlinecode"><span class="id" type="tactic">intro</span></span>
    czy <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>, teraz zaś dowiemy się, jak pisać własne. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">solve_bool</span> := <span class="id" type="tactic">intros</span>;<br/>
<span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">b</span> : <span class="id" type="var">bool</span> |- <span class="id" type="var">_</span> ⇒ <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>; <span class="id" type="var">solve_bool</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">reflexivity</span><br/>
<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">solve_bool2</span> :=<br/>
<span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> : <span class="id" type="var">bool</span>, <span class="id" type="var">_</span> ⇒ <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>; <span class="id" type="var">solve_bool2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">reflexivity</span><br/>
<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicje taktyk zaczynają się od słowa kluczowego <span class="inlinecode"><span class="id" type="keyword">Ltac</span></span>.
    W ciele definicji możemy używać taktyk oraz konstruktu
    <span class="inlinecode"><span class="id" type="keyword">match</span></span> <span class="inlinecode"><span class="id" type="keyword">goal</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span>, który próbuje dopasować kontekst oraz
    cel do podanych niżej wzorców. Mają one postać
    <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">kontekst</span></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" type="var">cel</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">taktyka</span></span> lub podkreślnika,
    który oznacza "dopasuj cokolwiek". 
<div class="paragraph"> </div>

 Wyrażenie <span class="inlinecode"><span class="id" type="var">kontekst</span></span> jest
    listą hipotez/wartości, których szukany w kontekście, tzn.
    jest postaci <span class="inlinecode"><span class="id" type="var">x1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A1</span>,</span> <span class="inlinecode"><span class="id" type="var">x2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A2</span>...</span>, gdzie <span class="inlinecode"><span class="id" type="var">A1</span></span> oznacza typ
    pierwszej wartości/hipotezy, a <span class="inlinecode"><span class="id" type="var">x1</span></span> oznacza nazwę, którą
    nadajemy jej na potrzeby naszej taktyki (nie musi być ona
    taka sama jak rzeczywista nazwa występująca w twierdzeniu
    — możemy ją np. pominąć, używając podkreślnika <span class="inlinecode"><span class="id" type="var">_</span></span>). 
<div class="paragraph"> </div>

 Wyrażenie <span class="inlinecode"><span class="id" type="var">cel</span></span> jest typem, który reprezentuje dany cel,
    np. gdybyśmy szukali celów będących równościami, moglibyśmy
    jako <span class="inlinecode"><span class="id" type="var">cel</span></span> podać wzorzec <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">_</span></span>. 
<div class="paragraph"> </div>

 Po strzałce <span class="inlinecode">⇒</span> następuje nazwa taktyki, której chcemy
    użyć w danym przypadku. Ponieważ możemy użyć tylko jednej,
    zazwyczaj będziemy budować ją z wielu kombinatorów. 
<div class="paragraph"> </div>

 W naszym przypadku taktykę możemy podsumować tak:

<div class="paragraph"> </div>

<ul class="doclist">
<li> wprowadź zmienne do kontekstu (<span class="inlinecode"><span class="id" type="tactic">intros</span></span>)

</li>
<li> dopasuj cel i kontekst do podanych wzorców (<span class="inlinecode"><span class="id" type="keyword">match</span></span> <span class="inlinecode"><span class="id" type="keyword">goal</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span>)
<ul class="doclist">
<li> jeżeli w kontekście jest wartość typu <span class="inlinecode"><span class="id" type="var">bool</span></span>, nazwij ją <span class="inlinecode"><span class="id" type="var">b</span></span>,
        rozbij ją, a następnie wywołaj się rekurencyjnie
        (<span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">b</span>;</span> <span class="inlinecode"><span class="id" type="var">solve_bool</span></span>)

</li>
<li> w przeciwnym przypadku uprość cel i udowodnij trywialne
        równości (<span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="tactic">simpl</span>;</span> <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>) 
</li>
</ul>

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_dist_orb'</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span> <span class="id" type="var">b3</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">b1</span> &amp;&amp; (<span class="id" type="var">b2</span> || <span class="id" type="var">b3</span>) = (<span class="id" type="var">b1</span> &amp;&amp; <span class="id" type="var">b2</span>) || (<span class="id" type="var">b1</span> &amp;&amp; <span class="id" type="var">b3</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">solve_bool</span>.<br/>
<span class="id" type="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">solve_bool2</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_true</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">b1</span> &amp;&amp; <span class="id" type="var">b2</span> = <span class="id" type="var">b1</span> || <span class="id" type="var">b2</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">solve_bool</span>.<br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Jak widzimy, napisana przez nas taktyka nie jest magiczna
    i nie potrafi udowodnić nieprawdziwego twierdzenia. 
</div>
<div class="code">

<br/>

<br/>

<br/>
<span class="id" type="var">Czym</span> <span class="id" type="var">jest</span> <span class="id" type="var">typ</span> <span class="id" type="var">induktywny</span>? <span class="id" type="var">Mo</span>ż<span class="id" type="var">emy</span> <span class="id" type="var">go</span> <span class="id" type="var">sobie</span> <span class="id" type="var">wyobrazi</span>ć <span class="id" type="var">jako</span> <span class="id" type="var">przestrze</span>ń,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">w</span> <span class="id" type="var">której</span> <span class="id" type="var">znajduj</span>ą <span class="id" type="var">si</span>ę <span class="id" type="var">drzewka</span> <span class="id" type="var">reprezentuj</span>ą<span class="id" type="var">ce</span> <span class="id" type="var">warto</span>ś<span class="id" type="var">ci</span> <span class="id" type="var">tego</span> <span class="id" type="var">typu</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">sk</span>ł<span class="id" type="var">adaj</span>ą<span class="id" type="var">ce</span> <span class="id" type="var">si</span>ę <span class="id" type="var">z</span> <span class="id" type="var">konstruktorów</span>.<br/>
&nbsp;&nbsp;&nbsp;2. <span class="id" type="var">Przyk</span>ł<span class="id" type="var">ady</span>: <span class="id" type="var">False</span>, <span class="id" type="var">unit</span>, <span class="id" type="var">bool</span>, <span class="id" type="var">nat</span>, <span class="id" type="var">list</span>, <span class="id" type="var">tree</span> (?), <span class="id" type="var">even</span>, <span class="id" type="var">T</span> *)<br/>
<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">False</span> : <span class="id" type="keyword">Prop</span> := .<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">T</span> : <span class="id" type="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">e</span> : <span class="id" type="var">T</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">c</span> : <span class="id" type="var">bool</span> → <span class="id" type="var">T</span> → <span class="id" type="var">T</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">d</span> : <span class="id" type="var">nat</span> → <span class="id" type="var">T</span> → <span class="id" type="var">T</span> → <span class="id" type="var">T</span>.<br/>

<br/>
</div>

<div class="doc">
Intuicyjnie typ to rodzaj metki, która mówi nam, z jakim rodzajem
    obiektu mamy do czynienia. Z języków imperatywnych, jak C lub Java,
    kojarzysz zapewne takie typy jak int (liczba całkowita, 32-bitowa),
    string (łańcuch znaków) lub float (liczba zmiennoprzecinkowa). W
    językach tych typy te są określane jako typy podstawowe (ang.
    primitive types) i przeciwstawiane ... 
<div class="paragraph"> </div>

 Typy w Coqu są czymś zupełnie innym niż w językach imperatywnych jak
    C lub Java. 
</div>
<div class="code">
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>