<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-88023543-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<h1 class="libtitle">R1: Logika</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 Naszą przygodę z Coqiem rozpoczniemy od skoku na głęboką wodę,
    czyli nauki dowodzenia twierdzeń w logice konstruktywnej przy
    pomocy taktyk. Powiemy sobie także co nieco o automatyzacji i
    cechach różniących logikę konstruktywną od klasycznej oraz
    dowiemy się, czym jest dedukcja naturalna.

<div class="paragraph"> </div>

    Coq składa się w zasadzie z trzech języków:

<div class="paragraph"> </div>

<ul class="doclist">
<li> język termów nazywa się Gallina. Służy do pisania
      programów oraz podawania twierdzeń

</li>
<li> język komend nazywa się vernacular ("potoczny"). Służy do
      interakcji z Coqiem, takich jak np. wyszukanie
      wszystkich obiektów związanych z podaną nazwą

</li>
<li> język taktyk nazywa się Ltac. Służy do dowodzenia twierdzeń. 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab9"></a><h1 class="section">Typy i termy</h1>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Section</span> <a name="constructive_propositional_logic"><span class="id" type="section">constructive_propositional_logic</span></a>.<br/>

<br/>
</div>

<div class="doc">
Mechanizm sekcji nie będzie nas na razie interesował. Użyjemy go,
    żeby nie zaśmiecać głównej przestrzeni nazw. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Hypothesis</span> <a name="constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a name="constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a name="constructive_propositional_logic.R"><span class="id" type="variable">R</span></a> : <span class="id" type="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
Zapis <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span></span> oznacza, że term <span class="inlinecode"><span class="id" type="var">x</span></span> jest typu <span class="inlinecode"><span class="id" type="var">A</span></span>. <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> to typ zdań
    logicznych, więc komendę tę można odczytać następująco:
    niech <span class="inlinecode"><span class="id" type="var">P</span></span>, <span class="inlinecode"><span class="id" type="var">Q</span></span> i <span class="inlinecode"><span class="id" type="var">R</span></span> będą zdaniami logicznymi.

<div class="paragraph"> </div>

    Czym są termy? Są to twory o naturze syntaktycznej (składniowej),
    reprezentujące funkcje, typy, zdania logiczne, predykaty, relacje
    etc. Polskim słowem o najbliższym znaczeniu jest słowo "wyrażenie".
    Zamiast prób definiowania termów, co byłoby problematyczne,
    zobaczmy przykłady:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode">2</span> — stałe są termami

</li>
<li> <span class="inlinecode"><span class="id" type="var">P</span></span> — zmienne są termami

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> — typy są termami

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> — λ-abstrakcje (funkcje) są termami

</li>
<li> <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> — aplikacje funkcji do argumentu są termami

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">if</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span> <span class="inlinecode"><span class="id" type="keyword">then</span></span> <span class="inlinecode">5</span> <span class="inlinecode"><span class="id" type="keyword">else</span></span> <span class="inlinecode">2</span> — konstrukcja if-else jest termem 
</li>
</ul>

<div class="paragraph"> </div>

 Nie są to wszystkie występujące w Coqu rodzaje termów — jest
    ich nieco więcej.

<div class="paragraph"> </div>

    Kolejnym fundamentalnym pojęciem jest pojęcie typu. W Coqu
    każdy term ma dokładnie jeden, niezmienny typ. Czym są typy?
    Intuicyjnie można powiedzieć, że typ to rodzaj metki, która
    dostarcza nam informacji dotyczących danego termu.

<div class="paragraph"> </div>

    Dla przykładu,
    stwierdzenie <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> informuje nas, że <span class="inlinecode"><span class="id" type="var">x</span></span> jest liczbą
    naturalną, dzięki czemu wiemy, że możemy użyć go jako argumentu
    dodawania: term <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> jest poprawnie typowany (ang. well-typed),
    tzn. <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span>, a więc możemy skonkludować, że <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> również
    jest liczbą naturalną.

<div class="paragraph"> </div>

    Innym przykładem niech będzie stwierdzenie <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">nat</span></span>,
    które mówi nam, że <span class="inlinecode"><span class="id" type="var">f</span></span> jest funkcją, która bierze liczbę
    naturalną i zwraca liczbę naturalną. Dzięki temu wiemy, że term
    <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode">2</span> jest poprawnie typowany i jest liczbą naturalną,
    tzn. <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode">2</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span>, zaś term <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"><span class="id" type="var">f</span></span> nie jest poprawnie typowany,
    a więc próba jego użycia, a nawet napisania byłaby błędem.

<div class="paragraph"> </div>

    Typy są tworami absolutnie kluczowymi. Informują nas, z jakimi
    obiektami mamy do czynienia i co możemy z nimi zrobić, a Coq
    pilnuje ścisłego przestrzegania tych reguł. Dzięki temu
    wykluczona zostaje możliwość popełnienia całej gamy różnych
    błędów, które występują w językach nietypowanych, takich jak
    dodanie liczby do ciągu znaków.

<div class="paragraph"> </div>

    Co więcej, system typów Coqa jest jednym z najsilniejszych,
    jakie dotychczas wymyślono, dzięki czemu umożliwia nam wiele
    rzeczy, których prawie żaden inny język programowania nie potrafi,
    jak np. reprezentowanie skomplikowanych obiektów matematycznych
    i dowodzenie twierdzeń. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> 2.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;2&nbsp;:&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;P&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Uwaga techniczna: w komentarzach postaci <span class="comment">(*&nbsp;===&gt;&nbsp;*)</span> będę
    przedstawiać wyniki wypisywane przez komendy.

<div class="paragraph"> </div>

    Typ każdego termu możemy sprawdzić przy pomocy komendy <span class="inlinecode"><span class="id" type="keyword">Check</span></span>.
    Jest ona nie do przecenienia. Jeżeli nie rozumiesz, co się
    dzieje w trakcie dowodu lub dlaczego Coq nie chce zaakceptować
    jakiejś definicji, użyj komendy <span class="inlinecode"><span class="id" type="keyword">Check</span></span>, żeby sprawdzić,
    z jakimi typami masz do czyenienia. 
<div class="paragraph"> </div>

<a name="lab10"></a><h1 class="section">Typy a zbiory</h1>
 Z filozoficznego punktu widzenia należy stanowczo odróżnić
    typy od zbiorów, znanych chociażby z teorii zbiorów ZF,
    która jest najpowszechniej używaną podstawą współczesnej
    matematyki:

<div class="paragraph"> </div>

<ul class="doclist">
<li> zbiory są materialne, podczas gdy typy są strukturalne.
      Dla przykładu, zbiory {1, 2} oraz {2, 3} mają przecięcie
      równe {2}, które to przecięcie jest podzbiorem każdego
      z nich. W przypadku typów jest inaczej — dwa różne typy
      są zawsze rozłączne i żaden typ nie jest podtypem innego

</li>
<li> relacja "x ∈ A" jest semantyczna, tzn. jest zdaniem
      logicznym i wymaga dowodu. Relacja "x : A" jest syntaktyczna,
      a więc nie jest zdaniem logicznym i nie wymaga dowodu —
      Coq jest w stanie sprawdzić automatycznie (bez pomocy
      użytkownika), czy dany term jest danego typu, a często
      także wywnioskować z kontekstu, jakiego typu jest dany
      term

</li>
<li> zbiór to kolekcja obiektów, do której można włożyć cokolwiek.
      Nowe zbiory mogą być formowane ze starych w sposób niemal
      dowolny (aksjomaty są dość liberalne). Typ to kolekcja obiektów
      o takiej samej wewnętrznej naturze. Zasady formowania nowych
      typów ze starych są bardzo ścisłe

</li>
<li> teoria zbiorów mówi, jakie obiekty istnieją (np. aksjomat
      zbioru potęgowego mówi, że dla każdego zbioru istnieje zbiór
      wszystkich jego podzbiorów). Teoria typów mówi, w jaki sposób
      obiekty mogą być konstruowane — różnica być może ciężko
      dostrzegalna dla niewprawionego oka, ale znaczna 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab11"></a><h1 class="section">Logika klasyczna i konstruktywna</h1>
 Jak udowodnić twierdzenie, by komputer mógł zweryfikować nasz
    dowód? Jedną z metod dowodzenia używanych w logice klasycznej
    są tabelki prawdy. Są one metodą skuteczną, gdyż działają
    zawsze i wszędzie, ale nie są wolne od problemów.

<div class="paragraph"> </div>

    Pierwszą, praktyczną przeszkodą jest rozmiar tabelek — rośnie on
    wykładniczo wzrast ze wzrostem ilości zmiennych zdaniowych, co
    czyni tę metodę skrajnie niewydajną i obliczeniożerną, a więc
    niepraktyczną dla twierdzeń większych niż zabawkowe.

<div class="paragraph"> </div>

    Druga przeszkoda, natury filozoficznej, i bardziej fundamentalna
    od pierwszej to poczynione implicite założenie, że każde zdanie
    jest prawdziwe lub fałszywe, co w logice konstruktywnej jest nie
    do końca prawdą, choć w logice klasycznej jest słuszne. Wynika to
    z różnych interpretacji prawdziwości w tych logikach.

<div class="paragraph"> </div>

    Dowód
    konstruktywny to taki, który polega na skonstruowaniu pewnego
    obiektu i logika konstruktywna dopuszcza jedynie takie dowody.
    Logika klasyczna, mimo że również dopuszcza dowody konstruktywne,
    standardy ma nieco luźniejsze i dopuszcza również dowód polegający
    na pokazaniu, że nieistnienie jakiegoś obiektu jest sprzeczne.
    Jest to sposób dowodzenia fundamentalnie odmienny od poprzedniego,
    gdyż sprzeczność nieistnienia jakiegoś obiektu nie daje nam żadnej
    wskazówki, jak go skonstruować.

<div class="paragraph"> </div>

    Dobrym przykładem jest poszukiwanie rozwiązań równania: jeżeli
    udowodnimy, że nieistnienie rozwiązania jest sprzeczne, nie
    znaczy to wcale, że znaleźliśmy rozwiązanie. Wiemy tylko, że
    jakieś istnieje, ale nie wiemy, jak je skonstruować. 
<div class="paragraph"> </div>

<a name="lab12"></a><h1 class="section">Dedukcja naturalna i taktyki</h1>
 Ważną konkluzją płynącą z powyższych rozważań jest fakt, że
    logika konstruktywna ma interpretację obliczeniową — każdy
    dowód można interpretować jako pewien program.
    Odnosząc się do poprzedniego przykładu, konstruktywny dowód
    faktu, że jakieś równanie ma rozwiązanie, jest jednocześnie
    programem, który to rozwiązanie oblicza.

<div class="paragraph"> </div>

    Wszystko to sprawia, że dużo lepszym, z naszego punktu widzenia,
    stylem dowodzenia będzie <i>dedukcja naturalna</i> — styl oparty na
    małej liczbie aksjomatów, zaś dużej liczbie reguł wnioskowania.
    Reguł, z których każda ma swą własną interpretację obliczeniową,
    dzięki czemu dowodząc przy ich pomocy będziemy jednocześnie
    konstruować pewien program. Sprawdzenie, czy dowód jest poprawny,
    będzie się sprowadzało do sprawdzenia, czy program ten jest
    poprawnie typowany (co Coq może zrobić automatycznie), zaś
    wykonanie tego programu skonstruuje obiekt, który będzie "świadkiem"
    prawdziwości twierdzenia.

<div class="paragraph"> </div>

    Jako, że każdy dowód jest też programem, w Coqu dowodzić można
    na dwa diametralnie różne sposoby. Pierwszy z nich polega na
    "ręcznym" skonstruowaniu termu, który reprezentuje dowód —
    ten sposób dowodzenia przypomina zwykłe programowanie.

<div class="paragraph"> </div>

    Drugim sposobem jest użycie taktyk. Ten sposób jest rozszerzeniem
    opisanego powyżej systemu dedukcji naturalnej. Taktyki nie są
    tym samym, co reguły wnioskowania — regułom odpowiadają jedynie
    najprostsze taktyki. Język taktyk Coqa, Ltac, pozwala z prostych
    taktyk budować bardziej skomplikowane przy użyciu konstrukcji
    podobnych do tych, których używa się do pisania "zwykłych"
    programów.

<div class="paragraph"> </div>

    Taktyki konstruują dowody, czyli programy, jednocześnie same
    będąc programami. Innymi słowy: taktyki to programy, które piszą
    inne programy.

<div class="paragraph"> </div>

    Ufff... jeżeli twój mózg jeszcze nie eksplodował, to czas
    wziąć się do konkretów! 
<div class="paragraph"> </div>

<a name="lab13"></a><h1 class="section">Konstruktywny rachunek zdań</h1>
 Nadszedł dobry moment na to, żebyś odpalił CoqIDE. Sesja
    interaktywna w CoqIDE przebiega następująco: edytujemy plik
    z rozszerzeniem .v wpisując komendy. Po kliknięciu przycisku
    "Forward one command" (strzałka w dół) Coq interpretuje kolejną
    komendę, a po kliknięciu "Backward one command" (strzałka w
    górę) cofa się o jedną komendę do tyłu. Ta interaktywność,
    szczególnie w trakcie przeprowadzania dowodu, jest bardzo
    mocnym atutem Coqa — naucz się ją wykorzystywać, dokładnie
    obserwując skutki działania każdej komendy.

<div class="paragraph"> </div>

    W razie problemów z CoqIDE poszukaj pomocy w manualu:
    coq.inria.fr/refman/Reference-Manual018.html 
<div class="paragraph"> </div>

<a name="lab14"></a><h2 class="section">Implikacja</h2>
 Zacznijmy od czegoś prostego: pokażemy, że P implikuje P. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="impl_refl"><span class="id" type="lemma">impl_refl</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intro</span> <span class="id" type="var">dowód_na_to_</span>ż<span class="id" type="var">e_P_zachodzi</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">exact</span> <span class="id" type="var">dowód_na_to_</span>ż<span class="id" type="var">e_P_zachodzi</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Słowo kluczowe <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> obwieszcza, że chcemy podać twierdzenie.
    Musi mieć ono nazwę (tutaj <span class="inlinecode"><span class="id" type="var">impl_refl</span></span>). Samo twierdzenie podane jest
    po dwukropku — twierdzenie jest typem, a jego udowodnienie sprowadza
    się do skonstruowania termu tego typu. Zauważmy też, że każda
    komenda musi kończyć się kropką.

<div class="paragraph"> </div>

    Twierdzenia powinny mieć łatwe do zapamiętania oraz sensowne nazwy,
    które informują (z grubsza), co właściwie chcemy udowodnić.
    Nazwa <span class="inlinecode"><span class="id" type="var">impl_refl</span></span> oznacza, że twierdzenie wyraża fakt, że
    implikacja jest zwrotna.

<div class="paragraph"> </div>

    Dowody będziemy zaczynać komendą <span class="inlinecode"><span class="id" type="keyword">Proof</span></span>. Jest ona opcjonalna, ale
    poprawia czytelność, więc warto ją stosować. 

<div class="paragraph"> </div>

    Jeżeli każesz Coqowi zinterpretować komendę zaczynającą się
    od <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span>, po prawej stronie ekranu pojawi się stan aktualnie
    przeprowadzanego dowodu.

<div class="paragraph"> </div>

    Od góry mamy: ilość podcelów (rozwiązanie wszystkich kończy dowód)
    — obecnie 1, kontekst (znajdują się w nim obiekty, które możemy
    wykorzystać w dowodzie) — obecnie mamy w nim zdania
    <span class="inlinecode"><span class="id" type="var">P</span></span>, <span class="inlinecode"><span class="id" type="var">Q</span></span> i <span class="inlinecode"><span class="id" type="var">R</span></span>; kreskę oddzielającą kontekst od aktualnego celu,
    obok niej licznik, który informuje nas, nad którym podcelem pracujemy
    — obecnie 1/1, oraz aktualny cel — dopiero zaczynamy, więc brzmi
    tak samo jak nasze twierdzenie.

<div class="paragraph"> </div>

    Taktyki mogą wprowadzać zmiany w celu lub w kontekście,
    w wyniku czego rozwiązują lub generują nowe podcele. Taktyka może
    zakończyć się sukcesem lub zawieść. Dokładne warunki sukcesu lub
    porażnki zależą od konkretnej taktyki.

<div class="paragraph"> </div>

    Taktyka <span class="inlinecode"><span class="id" type="tactic">intro</span></span> działa na cele będące implikacją <span class="inlinecode">→</span> i wprowadza
    jedną hipotezę z celu do kontekstu jeżeli to możliwe; w przeciwnym
    przypadku zawodzi. W dowodach słownych lub pisanych na kartce/tablicy
    użyciu taktyki <span class="inlinecode"><span class="id" type="tactic">intro</span></span> odpowiadałoby stwierdzenie "załóżmy, że
    P jest prawdą", "załóżmy, że P zachodzi" lub po prostu "załóżmy,
    że P".

<div class="paragraph"> </div>

    Szczegółem, który odróżnia dowód w Coqu (który dalej będziemy
    zwać "dowodem formalnym") od dowodu na kartce/tablicy/słownie
    (zwanego dalej "dowodem nieformalnym"), jest fakt, że nie tylko
    sama hipoteza,
    ale też dowód ("świadek") jej prawdziwości, musi mieć jakąś
    nazwę — w przeciwnym wypadku nie bylibyśmy w stanie się do
    nich odnosić. Dowodząc na tablicy, możemy odnieść się
    do jej zawartości np. poprzez wskazanie miejsca, w stylu
    "dowód w prawym górnym rogu tablicy". W Coqu wszelkie
    odniesienia działają identycznie jak odniesienia
    do zmiennych w każdym innym języku programowania — przy
    pomocy nazwy.

<div class="paragraph"> </div>

    Upewnij się też, że dokładnie rozumiesz, co taktyka <span class="inlinecode"><span class="id" type="tactic">intro</span></span>
    wprowadziła do kontekstu. Nie było to zdanie <span class="inlinecode"><span class="id" type="var">P</span></span> — ono już
    się tam znajdowało, o czym świadczyło stwierdzenie <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>
    — cofnij stan dowodu i sprawdź, jeżeli nie wierzysz. Hipotezą
    wprowadzoną do kontekstu był obiekt, którego nazwę podaliśmy taktyce
    jako argument, tzn. <span class="inlinecode"><span class="id" type="var">dowód_na_to_</span>ż<span class="id" type="var">e_P_zachodzi</span></span>, który jest właśnie
    tym, co głosi jego nazwa — "świadkiem" prawdziwości <span class="inlinecode"><span class="id" type="var">P</span></span>. Niech
    nie zmyli cię użyte na początku rozdziału słowo kluczowe
    <span class="inlinecode"><span class="id" type="keyword">Hypothesis</span></span>.

<div class="paragraph"> </div>

    Taktyka <span class="inlinecode"><span class="id" type="tactic">exact</span></span> rozwiązuje cel, jeżeli term podany jako argument
    ma taki sam typ, jak cel, a w przeciwnym przypadku zawodzi.
    Jej użyciu w dowodzie nieformalnym odpowiada stwierdzenie
    "mamy w założeniach dowód na to, że P, który nazywa się x,
    więc x dowodzi tego, że P".

<div class="paragraph"> </div>

    Pamiętaj, że cel jest zdaniem logicznym, czyli typem, a hipoteza
    jest dowodem tego zdania, czyli termem tego typu. Przyzwyczaj się
    do tego utożsamienia typów i zdań oraz dowodów i programów/termów
    — jest to wspomniana we wstępie korespondencja Curry'ego-Howarda,
    której wiele wcieleń jeszcze zobaczymy.

<div class="paragraph"> </div>

    Dowód kończy się zazwyczaj komendą <span class="inlinecode"><span class="id" type="keyword">Qed</span></span>, która go zapisuje. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="impl_refl'"><span class="id" type="lemma">impl_refl'</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intro</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Zauważmy, że w Coqowych nazwach można używać apostrofu.
    Zgodnie z konwencją nazwa pokroju <span class="inlinecode"><span class="id" type="var">x'</span></span> oznacza, że <span class="inlinecode"><span class="id" type="var">x'</span></span>
    jest w jakiś sposób blisko związany z <span class="inlinecode"><span class="id" type="var">x</span></span>. W tym wypadku
    używamy go, żeby podać inny dowód udowodnionego już
    wcześniej twierdzenia. Nie ma też nic złego w pisaniu
    taktyk w jednej linijce (styl pisania jak zawsze powinien
    maksymalizować czytelność).

<div class="paragraph"> </div>

    Jeżeli użyjemy taktyki <span class="inlinecode"><span class="id" type="tactic">intro</span></span> bez podawania nazwy hipotezy,
    zostanie użyta nazwa domyślna (dla wartości typu <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> jest to <span class="inlinecode"><span class="id" type="var">H</span></span>;
    jeżeli ta nazwa jest zajęta, zostanie użyte <span class="inlinecode"><span class="id" type="var">H0</span></span>, <span class="inlinecode"><span class="id" type="var">H1</span></span>...). Domyślne
    nazwy zazwyczaj nie są dobrym pomysłem, ale w prostych dowodach
    możemy sobie na nie pozwolić.

<div class="paragraph"> </div>

    Taktyka <span class="inlinecode"><span class="id" type="tactic">assumption</span></span> (ang. "założenie") sama potrafi znaleźć
    nazwę hipotezy, która rozwiązuje cel. Jeżeli nie znajdzie
    takiej hipotezy, to zawodzi. Jej użycie w dowodzenie nieformalnym
    odpowiada stwierdzeniu "P zachodzi na mocy założenia". 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">impl_refl'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;impl_refl'&nbsp;=&nbsp;fun&nbsp;H&nbsp;:&nbsp;P&nbsp;=&gt;&nbsp;H<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;P&nbsp;-&gt;&nbsp;P&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Wspomnieliśmy wcześniej, że zdania logiczne są typami,
    a ich dowody termami. Używając komendy <span class="inlinecode"><span class="id" type="keyword">Print</span></span> możemy
    wyświetlić definicję podanego termu (nie każdego, ale
    na razie się tym nie przejmuj). Jak się okazuje,
    dowód naszej trywialnej implikacji jest funkcją. Jest
    to kolejny element korespondencji Curry'ego-Howarda.

<div class="paragraph"> </div>

    Po głębszym namyśle nie powinien nas on dziwić:
    implikację można interpretować wszakże jako funkcję,
    która bierze dowód poprzednika i zwraca dowód następnika.
    Wykonanie funkcji odpowiada tutaj procesowi wywnioskowania
    konkluzji z przesłanki.

<div class="paragraph"> </div>

    Wspomnieliśmy także, że każda taktyka ma swoją własną
    interpretację obliczeniową. Jaki był więc udział taktyk
    <span class="inlinecode"><span class="id" type="tactic">intro</span></span> i <span class="inlinecode"><span class="id" type="tactic">exact</span></span> w konstrukcji naszego dowodu? Dowód
    implikacji jest funkcją, więc możemy sobie wyobrazić,
    że na początku dowodu term wyglądał tak: <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode">?1</span> <span class="inlinecode">⇒</span> <span class="inlinecode">?2</span>
    (symbole <span class="inlinecode">?1</span> i <span class="inlinecode">?2</span> reprezentują fragmenty dowodu, których
    jeszcze nie skonstruowaliśmy). Taktyka <span class="inlinecode"><span class="id" type="tactic">intro</span></span> wprowadza
    zmienną do kontekstu i nadaje jej nazwę, czemu odpowiada
    zastąpienie w naszym termie <span class="inlinecode">?1</span> przez <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span>. Możemy
    sobie wyobrazić, że po użyciu taktyki intro term wygląda
    tak: <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode">?2</span>. Użycie taktyki <span class="inlinecode"><span class="id" type="tactic">exact</span></span> (lub
    <span class="inlinecode"><span class="id" type="tactic">assumption</span></span>) dało w efekcie zastępienie <span class="inlinecode">?2</span> przez <span class="inlinecode"><span class="id" type="var">H</span></span>,
    czyli szukany dowód zdania <span class="inlinecode"><span class="id" type="var">P</span></span>. Ostatecznie term przybrał
    postać <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">H</span></span>. Ponieważ nie ma już żadnych
    brakujących elementów, dowód kończy się. Gdy użyliśmy
    komendy <span class="inlinecode"><span class="id" type="keyword">Qed</span></span> Coq zweryfikował, czy aby na pewno term
    skonstruowany przez taktyki jest poprawnie typowany,
    a następnie zaakceptował nasz dowód. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="modus_ponens"><span class="id" type="lemma">modus_ponens</span></a> : (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>) → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Implikacja jest operatorem łączącym w prawo (ang. right
    associative), więc wyrażenie <span class="inlinecode">(<span class="id" type="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">Q</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">Q</span></span> to coś
    innego, niż <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">Q</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">Q</span></span> — w pierwszym przypadku
    jedna z hipotez jest implikacją

<div class="paragraph"> </div>

    Wprowadzanie zmiennych do kontekstu pojedynczo może nie być
    dobrym pomysłem, jeżeli jest ich dużo. Taktyka <span class="inlinecode"><span class="id" type="tactic">intros</span></span> pozwala
    nam wprowadzić do kontekstu zero lub więcej zmiennych na raz,
    a także kontrolować ich nazwy. Taktyka ta nigdy nie zawodzi.
    Jej odpowiednik w dowodach nieformalnych oraz interpretacja
    obliczeniowa są takie, jak wielokrotnego (lub zerokrotnego)
    użycia taktyki <span class="inlinecode"><span class="id" type="tactic">intro</span></span>.

<div class="paragraph"> </div>

    Taktyka <span class="inlinecode"><span class="id" type="tactic">apply</span></span> pozwala zaaplikować hipotezę do celu, jeżeli
    hipoteza jest implikacją, której konkluzją jest cel. W wyniku
    działania tej taktyki zostanie wygenerowana ilość podcelów
    równa ilości przesłanek, a stary cel zostanie rozwiązany. W
    kolejnych krokrach będziemy musieli udowodnić, że przesłanki
    są prawdziwe. W naszym przypadku hipotezę <span class="inlinecode"><span class="id" type="var">H</span></span> typu <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>
    zaaplikowaliśmy do celu <span class="inlinecode"><span class="id" type="var">Q</span></span>, więc zostanie wygenerowany jeden
    podcel <span class="inlinecode"><span class="id" type="var">P</span></span>.

<div class="paragraph"> </div>

    Interpretacją obliczeniową taktyki <span class="inlinecode"><span class="id" type="tactic">apply</span></span> jest, jak sama
    nazwa wskazuje, aplikacja funkcji. Nie powinno nas to wcale
    dziwić — wszak ustaliliśmy przed chwilą, że implikacje
    są funkcjami. Możemy sobie wyobrazić, że po użyciu
    taktyki <span class="inlinecode"><span class="id" type="tactic">intros</span></span> nasz proofterm (będę tego wyrażenia używał
    zamiast rozwlekłego "term będący dowodem") wyglądał tak:
    <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode">(<span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">Q</span>)</span> <span class="inlinecode">(<span class="id" type="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span>)</span> <span class="inlinecode">⇒</span> <span class="inlinecode">?1</span>. Taktyka <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>
    przekształca brakujący fragment dowodu <span class="inlinecode">?1</span> we fragment,
    w którym również czegoś brakuje: <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">?2</span> — tym czymś jest
    argument. Pasujący argument znaleźliśmy przy pomocy taktyki
    assumption, więc ostatecznie proofterm ma postać
    <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode">(<span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">Q</span>)</span> <span class="inlinecode">(<span class="id" type="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span>)</span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode"><span class="id" type="var">H0</span></span>.

<div class="paragraph"> </div>

    Reguła wnioskowania modus ponens jest zdecydowanie najważniejszą
    (a w wielu systemach logicznych jedyną) regułą wnioskowania.
    To właśnie ona odpowiada za to, że w systemie dedukcji
    naturalnej dowodzimy "od tyłu" — zaczynamy od celu i aplikujemy
    hipotezy, aż dojdziemy do jakiegoś zdania prawdziwego.

<div class="paragraph"> </div>

    Nadszedł czas na pierwsze ćwiczenia. Zanim przejdziesz dalej,
    postaraj się je wykonać — dzięki temu upewnisz się, że
    zrozumiałeś w wystarczającym stopniu omawiane w tekście
    zagadnienia. Postaraj się nie tylko udowodnić poniższe
    twierdzenia, ale także zrozumieć (a póki zadania są
    proste — być może także przewidzieć), jaki proofterm zostanie
    wygenerowany. Powodzenia! 
<div class="paragraph"> </div>

<a name="lab15"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="impl_trans"><span class="id" type="lemma">impl_trans</span></a> : (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>) → (<a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a>) → (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab16"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="impl_permute"><span class="id" type="lemma">impl_permute</span></a> : (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a>) → (<a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="impl_dist"><span class="id" type="lemma">impl_dist</span></a> : (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a>) → ((<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>) → (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a>)).<br/>

<br/>
</div>

<div class="doc">
<a name="lab18"></a><h4 class="section">Ćwiczenie XXX. Udowodnij to twierdzenie bez używania <span class="inlinecode"><span class="id" type="tactic">apply</span></span>.</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="modus_ponens'"><span class="id" type="lemma">modus_ponens'</span></a> : (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>) → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab19"></a><h2 class="section">Fałsz</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ex_falso"><span class="id" type="lemma">ex_falso</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intro</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">False</span></span> to zdanie zawsze fałszywe, którego nie można udowodnić.
    Nie istnieje żaden term tego typu, więc jeżeli taki term znajdzie
    się w naszym kontekście, to znaczy, że uzyskaliśmy sprzeczność.
    Jeżeli użyjemy taktyki <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> na hipotezie, która jest typu
    <span class="inlinecode"><span class="id" type="var">False</span></span>, obecny podcel zostanie natychmiast rozwiązany.

<div class="paragraph"> </div>

    Nazwa <span class="inlinecode"><span class="id" type="var">ex_falso</span></span> pochodzi od łacińskiego wyrażenia "ex falso
    sequitur quodlibet", które znaczy "z fałszu wynika cokolwiek
    zechcesz".

<div class="paragraph"> </div>

    Uzasadnienie tej reguły wnioskowania w logice klasycznej jest
    dziecinnie proste: skoro fałsz to prawda, to w tabelce prawdy
    dla tego zdania w kolumnie wynikowej wszystkie zera (fałsz)
    możemy zastąpić jedynkami (prawda), otrzymując zdanie prawdziwe.

<div class="paragraph"> </div>

    W logice konstruktywnej takie uzasadnienie oczywiście nie
    przejdzie, gdyż ustaliliśmy już, że nie możemy o dowolnym
    zdaniu powiedzieć, że jest albo prawdziwe, albo fałszywe,
    gdyż nie jesteśmy w stanie tak ogólnego faktu udowodnić. Nie
    będziemy na razie uzasadniać tej reguły ani wnikać w szczegóły
    działania taktyki <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> — dowiemy się tego już niedługo. 
<div class="paragraph"> </div>

<a name="lab20"></a><h2 class="section">Prawda</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="truth"><span class="id" type="lemma">truth</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">True</span></span> to zdanie zawsze prawdziwe. Jego udowodnienie nie jest
    zbyt trudne — możemy to zrobić np. przy pomocy taktyki <span class="inlinecode"><span class="id" type="tactic">trivial</span></span>,
    która, jak sama nazwa wskazuje, potrafi sama rozwiązywać proste
    cele. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">truth</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;truth&nbsp;=&nbsp;I&nbsp;:&nbsp;True&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jeżeli przyjrzymy się skonstruowanemu prooftermowi, dostrzeżemy
    term o nazwie <span class="inlinecode"><span class="id" type="var">I</span></span>. Jest to jedyny dowód zdania <span class="inlinecode"><span class="id" type="var">True</span></span>. Jego
    nazwa nie niesie ze sobą żadnego głębszego znaczenia, ale jego
    istnienie jest konieczne — pamiętajmy, że udowodnienie zdania
    sprowadza się do skonstruowania termu odpowiedniego typu.
    Nie inaczej jest w przypadku zdania zawsze prawdziwego — musi
    istnieć jego dowód, a żeby móc się do niego odnosić, musi też
    mieć jakąś nazwę.

<div class="paragraph"> </div>

    Zdanie <span class="inlinecode"><span class="id" type="var">True</span></span>, w przeciwieństwie do <span class="inlinecode"><span class="id" type="var">False</span></span>, nie jest zbyt
    użyteczne ani często spotykane, ale czasem się przydaje. 
<div class="paragraph"> </div>

<a name="lab21"></a><h2 class="section">Negacja</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;~&nbsp;P&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
W Coqu negację zdania <span class="inlinecode"><span class="id" type="var">P</span></span> oznaczamy przez <span class="inlinecode">¬<span class="id" type="var">P</span></span>. Symbol <span class="inlinecode">¬</span>
    nie jest jednak nazwą negacji — nazwy nie mogą być symbolami.
    Jest to jedynie notacja, która ma uczynić zapis krótszym i
    bardziej podobnym do tego używanego na codzień. Niesie to
    jednak za sobą pewne konsekwencje — nie możemy np. użyć
    komendy <span class="inlinecode"><span class="id" type="keyword">Print</span></span> <span class="inlinecode">~.</span>, żeby wyświetlić definicję negacji. Jak
    więc poznać nazwę, kryjącą się za jakąś notacją? 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Locate</span> "~".<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;"~&nbsp;x"&nbsp;:=&nbsp;not&nbsp;x&nbsp;...&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Możemy to zrobić przy pomocy komendy <span class="inlinecode"><span class="id" type="var">Locate</span></span>. Wyświetla ona,
    do jakich nazw odwołuje się dana notacja. Negacja w Coqu
    nazywa się <span class="inlinecode"><span class="id" type="var">not</span></span>.

<div class="paragraph"> </div>

    W logice klasycznej negację zdania P można zinterpretować
    po prostu jako spójnik zdaniowy tworzący nowe zdanie, którego
    wartość logiczna jest przeciwna do wartości zdania P.

<div class="paragraph"> </div>

    Jeżeli uważnie czytałeś fragmenty dotyczące logiki klasycznej
    i konstruktywnej, dostrzegasz już zapewne, że taka definicja
    nie przejdzie w logice konstruktywnej, której interpretacja
    opiera się na dowodach, a nie wartościach logicznych. Jak więc
    konstruktywnie zdefiniować negację?

<div class="paragraph"> </div>

    Zauważmy, że jeżeli zdanie <span class="inlinecode"><span class="id" type="var">P</span></span> ma dowód, to nie powinien istnieć
    żaden dowód jego negacji, <span class="inlinecode">¬<span class="id" type="var">P</span></span>. Uzyskanie takiego dowodu oznaczałoby
    sprzeczność, a więc w szczególności możliwość udowodnienia <span class="inlinecode"><span class="id" type="var">False</span></span>.
    Jak to spostrzeżenie przekłada się na Coqową praktykę? Skoro znamy
    już nazwę negacji, <span class="inlinecode"><span class="id" type="var">not</span></span>, możemy sprawdzić jej definicję: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">not</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;not&nbsp;=&nbsp;fun&nbsp;A&nbsp;:&nbsp;Prop&nbsp;=&gt;&nbsp;A&nbsp;-&gt;&nbsp;False<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Prop&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Definicja negacji w Coqu opiera się właśnie na powyższym spostrzeżeniu:
    jest to funkcja, która bierze zdanie <span class="inlinecode"><span class="id" type="var">A</span></span>, a zwraca zdanie <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">False</span></span>,
    które możemy odczytać jako "A prowadzi do sprzeczności". Jeżeli
    nie przekonuje cię to rozumowanie, przyjrzyj się uważnie poniższemu
    twierdzeniu. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="P_notP"><span class="id" type="lemma">P_notP</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">HnotP</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">HnotP</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HnotP</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" type="tactic">unfold</span></span> służy do odwijania definicji. W wyniku jej działania
    nazwa zostanie zastąpiona przez jej definicję, ale tylko w celu.
    Jeżeli podana nazwa do niczego się nie odnosi, taktyka zawiedzie. Aby
    odwinąć definicję w hipotezie, musimy użyć taktyki <span class="inlinecode"><span class="id" type="tactic">unfold</span></span> <span class="inlinecode"><span class="id" type="var">nazwa</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span>
    <span class="inlinecode"><span class="id" type="var">hipoteza</span></span>, a jeżeli chcemy odwinąć ją wszędzie — <span class="inlinecode"><span class="id" type="tactic">unfold</span></span> <span class="inlinecode"><span class="id" type="var">nazwa</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> *.

<div class="paragraph"> </div>

    Twierdzenie to jest też pewnym uzasadnieniem definicji negacji: jest
    ona zdefiniowana tak, aby uzyskanie fałszu z dwóch sprzecznych
    przesłanek było jak najprostsze. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="P_notP'"><span class="id" type="lemma">P_notP'</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → 42 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 666.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">cut</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyką, która czasem przydaje się w dowodzeniu negacji i radzeniu
    sobie z <span class="inlinecode"><span class="id" type="var">False</span></span>, jest <span class="inlinecode"><span class="id" type="tactic">cut</span></span>. Jeżeli nasz cel jest postaci <span class="inlinecode"><span class="id" type="var">G</span></span>,
    to taktyka <span class="inlinecode"><span class="id" type="tactic">cut</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> rozwiąże go i wygeneruje nam w zamian dwa
    podcele postaci <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">G</span></span> oraz <span class="inlinecode"><span class="id" type="var">P</span></span>. Nieformalnie odpowiada takiemu
    rozumowaniu: "cel G wynika z P; P zachodzi".

<div class="paragraph"> </div>

    Udowodnić <span class="inlinecode"><span class="id" type="var">False</span></span> <span class="inlinecode">→</span> <span class="inlinecode">42</span> <span class="inlinecode">=</span> <span class="inlinecode">666</span> moglibyśmy tak jak poprzednio:
    wprowadzić hipotezę <span class="inlinecode"><span class="id" type="var">False</span></span> do kontekstu przy pomocy <span class="inlinecode"><span class="id" type="tactic">intro</span></span>,
    a potem użyć na niej <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>. Możemy jednak zrobić to nieco
    szybciej. Jeżeli cel jest implikacją, to taktyka <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> <span class="inlinecode">1</span>
    działa tak samo, jak wprowadzenie do kontekstu jednej przesłanki
    i użycie na niej zwykłego <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>.

<div class="paragraph"> </div>

    Drugi podcel również moglibyśmy rozwiązać jak poprzednio: odwinąć
    definicję negacji, zaaplikować odpowiednią hipotezę, a potem
    zakończyć przy pomocy <span class="inlinecode"><span class="id" type="tactic">assumption</span></span>. Nie musimy jednak wykonywać
    pierwszego z tych kroków — Coq jest w stanie zorientować się,
    że <span class="inlinecode">¬<span class="id" type="var">P</span></span> jest tak naprawdę implikacją, i zaaplikować hipotezę <span class="inlinecode"><span class="id" type="var">H</span></span>
    bez odwijania definicji negacji. W ten sposób oszczędzamy sobie
    trochę pisania, choć ktoś mógłby argumentować, że zmniejszamy
    czytelność dowodu.

<div class="paragraph"> </div>

    Uwaga dotycząca stylu kodowania: postaraj się zachować 2 spacje
    wcięcia na każdy poziom zagłębienia, gdzie poziom zagłębienia
    zwiększa się o 1, gdy jakaś taktyka wygeneruje więcej niż 1 podcel.
    Tutaj taktyka <span class="inlinecode"><span class="id" type="tactic">cut</span></span> wygenerowała nam 2 podcele, więc dowody
    obydwu zaczniemy od nowej linii po dwóch dodatkowych spacjach.
    Rozwiązanie takie znacznie zwiększa czytelność, szczególnie w
    długich dowodach.

<div class="paragraph"> </div>

    Interpretacja obliczeniowa negacji wynika wprost z interpretacji
    obliczeniowej implikacji. Konstruktywna negacja różni się od tej
    klasycznej, o czym przekonasz się w ćwiczeniu. 
<div class="paragraph"> </div>

<a name="lab22"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="not_False"><span class="id" type="lemma">not_False</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab23"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="not_True"><span class="id" type="lemma">not_True</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab24"></a><h4 class="section">Ćwiczenie XXX. Czy odwrotna implikacja również zachodzi?</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="dbl_neg_intro"><span class="id" type="lemma">dbl_neg_intro</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~~</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab25"></a><h4 class="section">Ćwiczenie XXX. Czym to twierdzenie różni się od poprzedniego?</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="triple_neg_rev"><span class="id" type="lemma">triple_neg_rev</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~~~</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab26"></a><h2 class="section">Koniunkcja</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_intro"><span class="id" type="lemma">and_intro</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Symbol <span class="inlinecode">∧</span> oznacza koniunkcję dwóch zdań logicznych i podobnie
    jak <span class="inlinecode">¬</span> jest jedynie notacją (koniunkcja w Coqu nazywa się <span class="inlinecode"><span class="id" type="var">and</span></span>).

<div class="paragraph"> </div>

    W logice
    klasycznej koniunkcja jest prawdziwa, gdy obydwa jej człony są
    prawdziwe. W logice konstruktywnej sytuacja jest analogiczna, choć
    subtelnie różna: aby udowodnić koniunkcję, musimy udowodnić każdy
    z jej dwóch członów osobno.

<div class="paragraph"> </div>

    Koniunkcji w Coqu dowodzimy przy pomocy taktyki <span class="inlinecode"><span class="id" type="tactic">split</span></span>. Jako że
    musimy udowodnić oddzielnie oba jej człony, zostały dla nas
    wygenerowane dwa nowe podcele — jeden dla lewego członu, a drugi
    dla prawego. Ponieważ stary cel został rozwiązany, to do udowodnienia
    pozostają nam tylko te dwa nowe podcele. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_proj1"><span class="id" type="lemma">and_proj1</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Aby udowodnić koniunkcję, użyliśmy taktyki <span class="inlinecode"><span class="id" type="tactic">split</span></span>, która rozbiła
    ją na dwa osobne podcele. Jeżeli koniunkcją jest jedną z naszych
    hipotez, możemy posłużyć się podobnie działającą taktyką
    <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>, która dowód koniunkcji rozbija na osobne dowody obu
    jej członów. W naszym przypadku hipoteza <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" type="var">Q</span></span> zostaje
    rozbita na hipotezy <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> oraz <span class="inlinecode"><span class="id" type="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>. Zauważ, że nowe hipotezy
    dostały nowe, domyślne nazwy. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_proj1'"><span class="id" type="lemma">and_proj1'</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intro</span> <span class="id" type="var">HPQ</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">HPQ</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>]. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Podobnie jak w przypadku taktyki <span class="inlinecode"><span class="id" type="tactic">intro</span></span>, domyślne nazwy nadawane
    przez taktykę <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> często nie są zbyt fortunne. Żeby nadać
    częściom składowym rozbijanej hipotezy nowe nazwy, możemy użyć
    tej taktyki ze składnią <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">nazwa</span></span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode"><span class="id" type="var">wzorzec</span></span>. Ponieważ
    koniunkcja składa się z dwóch członów, <span class="inlinecode"><span class="id" type="var">wzorzec</span></span> będzie miał
    postać <span class="inlinecode">[<span class="id" type="var">nazwa1</span></span> <span class="inlinecode"><span class="id" type="var">nazwa2</span>]</span>.

<div class="paragraph"> </div>

    Interpretacja obliczeniowa koniunkcji jest bardzo prosta:
    koniunkcja to uporządkowana para zdań, zaś dowód koniunkcji
    to uporządkowana para dowodów — pierwszy jej element dowodzi
    pierwszego członu koniunkcji, a drugi element — drugiego
    członu koniunkcji. 
<div class="paragraph"> </div>

<a name="lab27"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="and_proj2"><span class="id" type="lemma">and_proj2</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab28"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="and3_intro"><span class="id" type="lemma">and3_intro</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab29"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="and3_proj"><span class="id" type="lemma">and3_proj</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab30"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="noncontradiction"><span class="id" type="lemma">noncontradiction</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab31"></a><h2 class="section">Równoważność zdaniowa</h2>

<div class="paragraph"> </div>

 Równoważność zdaniowa jest w Coqu oznaczana <span class="inlinecode">↔</span>. Symbol ten,
    jak (prawie) każdy jest jedynie notacją — równoważność
    nazywa się <span class="inlinecode"><span class="id" type="var">iff</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">iff</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;fun&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop&nbsp;=&gt;&nbsp;(A&nbsp;-&gt;&nbsp;B)&nbsp;/\&nbsp;(B&nbsp;-&gt;&nbsp;A)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Prop&nbsp;-&gt;&nbsp;Prop&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Jak widać, równoważność <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">↔</span> <span class="inlinecode"><span class="id" type="var">Q</span></span> to koniunkcja dwóch implikacji
    <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">Q</span></span> oraz <span class="inlinecode"><span class="id" type="var">Q</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">P</span></span>. W związku z tym nie powinno nas dziwić,
    że pracuje się z nią tak samo jak z koniunkcją. Tak jak nie
    musieliśmy odwijać definicji negacji, żeby zaaplikować ją jak
    rasową impikcję, tak też nie musimy odwijać definicji równoważności,
    żeby posługiwać się nią jak prawdziwą koniunkcją. Jej interpretacja
    obliczeniowa wywodzi się z interpretacji obliczeniowej koniunkcji
    oraz implikacji. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_intro"><span class="id" type="lemma">iff_intro</span></a> : (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>) → (<a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>) → (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intro</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intro</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H0</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Do rozbijania równoważności będących celem służy, tak jak w
    przypadku koniunkcji, taktyka <span class="inlinecode"><span class="id" type="tactic">split</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_proj1"><span class="id" type="lemma">iff_proj1</span></a> : (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a> → (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HPQ</span> <span class="id" type="var">HQP</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HPQ</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Równoważnosć znajdującą się w kontekście możemy zaś, tak jak
    koniunkcje, rozbijać taktyką <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>. Taką samą postać ma
    również wzorzec, służący w klauzuli <span class="inlinecode"><span class="id" type="keyword">as</span></span> do nadawania nazw
    zmiennym. 
<div class="paragraph"> </div>

<a name="lab32"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="iff_refl"><span class="id" type="lemma">iff_refl</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab33"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="iff_symm"><span class="id" type="lemma">iff_symm</span></a> : (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a> → (<a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab34"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="iff_trans"><span class="id" type="lemma">iff_trans</span></a>: (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a> → (<a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a> → (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab35"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="iff_not"><span class="id" type="lemma">iff_not</span></a> : (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a> → (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab36"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="curry_uncurry"><span class="id" type="lemma">curry_uncurry</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab37"></a><h2 class="section">Alternatywa</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="or_left"><span class="id" type="lemma">or_left</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intro</span>. <span class="id" type="tactic">left</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Symbol <span class="inlinecode">∨</span> oznacza alternatywę (zwaną też czasem dysjunkcją)
    dwóch zdań logicznych. Żeby dowieść alternatywy <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>,
    musimy udowonić albo lewy, albo prawy jej człon. Taktyki <span class="inlinecode"><span class="id" type="tactic">left</span></span>
    oraz <span class="inlinecode"><span class="id" type="tactic">right</span></span> pozwalają nam wybrać, którego z nich chcemy dowodzić. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="or_comm_impl"><span class="id" type="lemma">or_comm_impl</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intro</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">p</span> | <span class="id" type="var">q</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">right</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">left</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Zauważmy, że użycie taktyki destruct zmieniło nam ilość celów.
    Wynika to z faktu, że nie wiemy, który człon hipotezy <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" type="var">Q</span></span> jest
    prawdziwy, więc dla każdego przypadku musimy przeprowadzić osobny
    dowód. Inaczej wygląda też wzorzec służący do rozbicia tej
    hipotezy — w przypadku alternatywy ma on postać <span class="inlinecode">[<span class="id" type="var">nazwa1</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">nazwa2</span>]</span>.

<div class="paragraph"> </div>

    Interpretacja obliczeniowa alternatywy jest następująca: jest to
    suma rozłączna dwóch zdań. Dowód alternatywy to dowód jednego z jej
    członów z dodatkową informacją o tym, który to człon.

<div class="paragraph"> </div>

    To ostatnie stwierdzenie odróżnia alternatywę konstruktywną od
    klasycznej: klasyczna alternatywa to stwierdzenie "któres z tych
    dwóch zdań jest prawdziwe (lub oba)", zaś konstruktywna to
    stwierdzenie "lewy człon jest prawdziwy albo prawy człon jest
    prawdziwy (albo oba, ale i tak dowodzimy tylko jednego)". Jest
    to znaczna różnica — w przypadku logiki klasycznej nie wiemy,
    który człon jest prawdziwy. 
<div class="paragraph"> </div>

<a name="lab38"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="or_right"><span class="id" type="lemma">or_right</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab39"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="or_big"><span class="id" type="lemma">or_big</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab40"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="or3_comm_impl"><span class="id" type="lemma">or3_comm_impl</span></a> : <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.R"><span class="id" type="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab41"></a><h4 class="section">Ćwiczenie XXX. Czy odwrotna implikacja również zachodzi?</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="or_impl"><span class="id" type="lemma">or_impl</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">→</span></a> (<a class="idref" href="R1.html#constructive_propositional_logic.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#constructive_propositional_logic.Q"><span class="id" type="variable">Q</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab42"></a><h1 class="section">Konstruktywny rachunek predykatów</h1>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="R1.html#constructive_propositional_logic"><span class="id" type="section">constructive_propositional_logic</span></a>.<br/>

<br/>
</div>

<div class="doc">
Komenda <span class="inlinecode"><span class="id" type="keyword">End</span></span> zamyka sekcję, którą otworzyliśmy na samym początku
    tego rozdziału. Zdania <span class="inlinecode"><span class="id" type="var">P</span></span>, <span class="inlinecode"><span class="id" type="var">Q</span></span> i <span class="inlinecode"><span class="id" type="var">R</span></span> znikają z
    dostępnej dla nas przestrzeni nazw, dzięki czemu uniknęliśmy jej
    zaśmiecenia. Nasze twierdzenia wciąż są jednak dostępne (sprawdź
    to).

<div class="paragraph"> </div>

    Zajmiemy się teraz konstruktywnym rachunkiem predykatów. Jest on
    rozszerzeniem omawianego poprzednio konstruktywnego rachunku zdań
    o predykaty oraz kwantyfikatory, które pozwolą
    nam wyrażać takie zależności jak "każdy" oraz "istnieje". Predykaty
    możemy interpretować jako "właściwości obiektów". 
<div class="paragraph"> </div>

<a name="lab43"></a><h2 class="section">Kwantyfikacja uniwersalna</h2>

<div class="paragraph"> </div>

 Zobaczmy o co chodzi na znanym nam już przykładzie zrotności
    implikacji: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="impl_refl''"><span class="id" type="lemma">impl_refl''</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>, <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="keyword">∀</span></span> oznacza kwantyfikację uniwersalną. Możemy ten symbol
    odczytywać "dla każdego". Zasięg kwantyfikatora rozciąga się
    od przecinka aż do kropki. Wobec tego treść naszego twierdzenia
    możemy odczytać "dla każdego zdania logicznego P, P implikuje P".

<div class="paragraph"> </div>

    Kwantyfikator uniwersalny jest w swej naturze bardzo podobny do
    implikacji — zmienne, których dotyczy, możemy wprowadzić do
    kontekstu przy pomocy taktyki <span class="inlinecode"><span class="id" type="tactic">intro</span></span>. W dowodzie nieforamlnym
    użyciu taktyki <span class="inlinecode"><span class="id" type="tactic">intro</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> na celu kwantyfikowanym uniwersalnie
    odpowiadałoby stwierdzenie "niech P będzie dowolnym zdaniem logicznym".

<div class="paragraph"> </div>

    Zauważ, że używając taktyki <span class="inlinecode"><span class="id" type="tactic">intros</span></span>, możemy wprowadzić do kontekstu
    jednocześnie zmienne kwantyfikowane uniwersalnie oraz przesłanki
    występujące po lewej stronie implikacji. To wszystko powinno nasunąć
    nam myśl, że kwantyfikacja uniwersalna i implikacja są ze sobą blisko
    związane. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">impl_refl''</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;impl_refl''&nbsp;=&nbsp;fun&nbsp;(P&nbsp;:&nbsp;Prop)&nbsp;(H&nbsp;:&nbsp;P)&nbsp;=&gt;&nbsp;H<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;Prop,&nbsp;P&nbsp;-&gt;&nbsp;P&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Rzeczywiście: dowodem naszego zdania jest coś, co na pierwszy rzut
    oka wygląda jak funkcja. Jeżeli jednak przyjrzysz się jej uważnie,
    dostrzeżesz że nie może być to zwykła funkcja — typ zwracanej
    wartości <span class="inlinecode"><span class="id" type="var">H</span></span> różni się w zależności od argumentu <span class="inlinecode"><span class="id" type="var">P</span></span>. Jeżeli
    za <span class="inlinecode"><span class="id" type="var">P</span></span> wstawimy <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode">1</span>, to <span class="inlinecode"><span class="id" type="var">H</span></span> będzie dowodem na to, że
    <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode">1</span>. Jeżeli za <span class="inlinecode"><span class="id" type="var">P</span></span> wstawimy <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>, to <span class="inlinecode"><span class="id" type="var">H</span></span> będzie dowodem
    na to, że <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>. Zauważ, że <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode">1</span> oraz <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span> to dwa różne
    zdania, a zatem są to także różne typy.

<div class="paragraph"> </div>

    Dowód naszego zdania nie może być zatem zwykłą funkcją — gdyby
    nią był, zawsze zwracałby wartości tego samego typu. Jest on
    funkcją zależną, czyli taką, której przeciwdziedzina zależy
    od dziedziny. Funkcja zależna dla każdego argumentu może
    zwracać wartości różnego typu.

<div class="paragraph"> </div>

    Ustaliliśmy więc, że kwantyfikacja uniwersalna jest pewnym
    uogólnieniem implikacji, zaś jej interpretacją obliczeniową
    jest funkcja zależna, czyli pewne uogólnienie zwykłej funkcji,
    która jest interpretacją obliczeniową implikacji. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="general_to_particular"><span class="id" type="lemma">general_to_particular</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#n"><span class="id" type="variable">n</span></a>) → <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> 42.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">specialize</span> (<span class="id" type="var">H</span> 42). <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Podobnie jak zwykłe funkcje, funkcje zależne możemy aplikować
    do celu za pomocą taktyki <span class="inlinecode"><span class="id" type="tactic">apply</span></span>. Możliwy jest też inny
    sposób rozumowania, nieco bardziej przypominający rozumowania
    "w przód": przy pomocy taktyki <span class="inlinecode"><span class="id" type="tactic">specialize</span></span> możemy zainstancjować
    <span class="inlinecode"><span class="id" type="var">n</span></span> w naszej hipotezie <span class="inlinecode"><span class="id" type="var">H</span></span>, podając jej pewną liczbę naturalną.
    Wtedy nasza hipoteza <span class="inlinecode"><span class="id" type="var">H</span></span> z ogólnej, z kwantyfikacją po wszystkich
    liczbach naturalnych, zmieni się w szczególną, dotyczącą tylko
    podanej przez nas liczby.

<div class="paragraph"> </div>

    Komenda <span class="inlinecode"><span class="id" type="var">Restart</span></span> pozwala nam zacząć dowód od nowa w dowolnym
    jego momencie. Jej użycie nie jest wymagane, by ukończyć
    powyższy dowód — spróbuj wstawić w jej miejsce <span class="inlinecode"><span class="id" type="keyword">Qed</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_proj1''"><span class="id" type="lemma">and_proj1''</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#n"><span class="id" type="variable">n</span></a> ∧ <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#n"><span class="id" type="variable">n</span></a>) → (<span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#n"><span class="id" type="variable">n</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span> <span class="id" type="var">k</span>. <span class="id" type="tactic">destruct</span> (<span class="id" type="var">H</span> <span class="id" type="var">k</span>). <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
W powyższym przykładzie próba użycia taktyki <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> na
    hipotezie <span class="inlinecode"><span class="id" type="var">H</span></span> zawiodłaby — <span class="inlinecode"><span class="id" type="var">H</span></span> nie jest produktem. Żeby
    rozbić tę hipotezę, musielibyśmy najpierw wyspecjalizować
    ją dla interesującego nas <span class="inlinecode"><span class="id" type="var">k</span></span>, a dopiero potem rozbić.
    Możemy jednak zrobić to w nieco krótszy sposób — pisząc
    <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode">(<span class="id" type="var">H</span></span> <span class="inlinecode"><span class="id" type="var">k</span>)</span>. Dzięki temu "w locie" przemienimy <span class="inlinecode"><span class="id" type="var">H</span></span>
    z hipotezy ogólnej w szczególną, dotycząca tylko <span class="inlinecode"><span class="id" type="var">k</span></span>, a
    potem rozbijemy. Podobnie poprzednie twierdzenie moglibyśmy
    udowodnić szybciej, jeżeli zamiast <span class="inlinecode"><span class="id" type="tactic">specialize</span></span> i <span class="inlinecode"><span class="id" type="tactic">assumption</span></span>
    napisalibyśmy <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode">(<span class="id" type="var">H</span></span> <span class="inlinecode">42)</span>. 
<div class="paragraph"> </div>

<a name="lab44"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="all_dist"><span class="id" type="lemma">all_dist</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <a class="idref" href="R1.html#A"><span class="id" type="variable">A</span></a> → <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a> ∧ <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab45"></a><h2 class="section">Kwantyfikacja egzystencjalna</h2>

<div class="paragraph"> </div>

 Zdania egzystencjalne to zdania postaci "istnieje obiekt x,
    który ma właściwość P". W Coqu prezentują się tak: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ex_example1"><span class="id" type="lemma">ex_example1</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="R1.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">∃</span> 0. <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Kwantyfikacja egzystencjalna jest w Coqu zapisywana jako <span class="inlinecode"><span class="id" type="tactic">∃</span></span>
    (exists). Aby udowodnić zdanie kwantyfikowane egzystencjalnie, musimy
    skonstruować obiekt, którego istnienie postulujemy, oraz
    udowodnić, że ma deklarowaną właściwość. Jest to wymóg dużo
    bardziej restrykcyjny niż w logice klasycznej, gdzie możemy
    zadowolić się stwierdzeniem, że nieistnienie takiego obiektu
    jest sprzeczne.

<div class="paragraph"> </div>

    Powyższe twierdzenie możemy odczytać "istnieje liczba naturalna,
    która jest równa 0". W dowodzenie nieformalnym użyciu taktyki
    <span class="inlinecode"><span class="id" type="tactic">∃</span></span> odpowiada stwierdzenie: "liczbą posiadającą tę właściwość
    jest 0". Następnie pozostaje nam udowodnić, iż rzeczywiście <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>,
    co jest trywialne. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ex_example2"><span class="id" type="lemma">ex_example2</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="R1.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intro</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">n</span> <span class="id" type="var">H</span>]. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Gdy zdanie kwantyfikowane egzystencjalnie znajdzie się w naszych
    założeniach, możemy je rozbić i uzyskać wspomniany w nim obiekt
    oraz dowód wspominianej właściwości. Nie powinno nas to dziwić —
    skoro zakładamy, że zdanie to jest prawdziwe, to musiało zostać
    ono udowodnione w sposób opisany powyżej — właśnie poprzez wskazanie
    obiektu i udowodnienia, że ma daną własność.

<div class="paragraph"> </div>

    Myślę, że dostrzegasz już pewną prawidłowość:

<div class="paragraph"> </div>

<ul class="doclist">
<li> udowodnienie koniunkcji wymaga udowodnienia obydwu członów z osobna,
      więc dowód koniunkcji można rozbić na dowody poszczególnych członów
      (podobna sytuacja zachodzi w przypadku równoważności)

</li>
<li> udowodnienie alternatywy wymaga udowodnienia któregoś z członów, więc
      dowód alternatywy można rozbić, uzyskując dwa osobne podcele, a w
      każdym z nich dowód jednego z członów tej alternatywy

</li>
<li> udowodnienie zdania egzystencjalnego wymaga wskazania obiektu i
      podania dowodu żądanej własności, więc dowód takiego zdania
      możemy rozbić, uzyskując ten obiekt i dowód jego własności 
</li>
</ul>

<div class="paragraph"> </div>

 Takie konstruowanie i dekonstruowanie dowodów (i innych termów)
    będzie naszym chlebem powszednim w logice konstruktywnej i w Coqu.
    Wynika ono z samej natury konstrukcji: zasady konstruowania termów
    danego typu są ściśle określone, więc możemy dokonywać dekonstrukcji,
    która polega po prostu na sprawdzeniu, jakimi zasadami posłużono się
    w konstrukcji. Nie przejmuj się, jeżeli wydaje ci się to nie do końca
    jasne — więcej dowiesz się już w kolejnym rozdziale.

<div class="paragraph"> </div>

    Ostatnią wartą omówienia sprawą jest interpretacja obliczeniowa
    kwantyfikacji egzystencjalnej. Jest nią para zależna, tzn. taka,
    w której typ drugiego elementu może zależeć od pierwszego — pierwszym
    elementem pary jest obiekt, a drugim dowód, że ma on pewną własność.
    Zauważ, że podstawiając <span class="inlinecode">0</span> do <span class="inlinecode"><span class="id" type="tactic">∃</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>,</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, otrzymamy
    zdanie <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, które jest innym zdaniem, niż <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> (choćby dlatego,
    że pierwsze jest prawdziwe, a drugie nie). Interpretacją obliczeniową
    taktyki <span class="inlinecode"><span class="id" type="tactic">∃</span></span> jest wobec tego podanie pierwszego elementu pary,
    a podanie drugiego to po prostu przeprowadzenie reszty dowodu.

<div class="paragraph"> </div>

    "Zależność" jest tutaj tego samego rodzaju, co w przypadku produktu
    zależnego — tam typ wyniku mógł być różny w zależność od wartości,
    jaką funkcja bierze na wejściu, a w przypadku sumy zależnej typ
    drugiego elementu może być różny w zależności od tego, jaki jest
    pierwszy element.

<div class="paragraph"> </div>

    Nie daj się zwieść niefortunnemu nazewnictwu: produkt zależny
    <span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span>,</span> <span class="inlinecode"><span class="id" type="var">B</span></span>, którego elementami są funkcje zależne,
    jest uogólnieniem typu funkcyjnego <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">B</span></span>, którego elementami
    są zwykłe funkcje, zaś suma zależna <span class="inlinecode"><span class="id" type="tactic">∃</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span>,</span> <span class="inlinecode"><span class="id" type="var">B</span></span>, której
    elementami są pary zależne, jest uogólnieniem produktu <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" type="var">B</span></span>,
    którego elementami są zwykłe pary. 
<div class="paragraph"> </div>

<a name="lab46"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="ex_or_dist"><span class="id" type="lemma">ex_or_dist</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <a class="idref" href="R1.html#A"><span class="id" type="variable">A</span></a> → <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#A"><span class="id" type="variable">A</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a> ∨ <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#A"><span class="id" type="variable">A</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#A"><span class="id" type="variable">A</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab47"></a><h1 class="section">Kombinatory taktyk</h1>

<div class="paragraph"> </div>

 Przyjrzyjmy się jeszcze raz twierdzeniu <span class="inlinecode"><span class="id" type="var">iff_intro</span></span> (lekko
    zmodernizowanemu przy pomocy kwantyfikacji uniwersalnej). 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_intro'"><span class="id" type="lemma">iff_intro'</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, (<a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a>) → (<a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a>) → (<a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intro</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intro</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H0</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Jego dowód wygląda dość schematycznie. Taktyka <span class="inlinecode"><span class="id" type="tactic">split</span></span> generuje
    nam dwa podcele będące implikacjami — na każdym z osobna używamy
    następnie <span class="inlinecode"><span class="id" type="tactic">intro</span></span>, a kończymy <span class="inlinecode"><span class="id" type="tactic">assumption</span></span>. Jedyne, czym różnią
    się dowody podcelów, to nazwa aplikowanej hipotezy.

<div class="paragraph"> </div>

    A co, gdyby jakaś taktyka wygenerowała nam 100 takich schematycznych
    podcelów? Czy musielibyśmy przechodzić przez mękę ręcznego dowodzenia
    tych niezbyt ciekawych przypadków? Czy da się powyższy dowód jakoś
    skrócić lub zautomatyzować?

<div class="paragraph"> </div>

    Odpowiedź na szczęście brzmi "tak". Z pomocą przychodzą nam kombinatory
    taktyk (ang. tacticals), czyli taktyki, które mogą przyjmować jako
    argumenty inne
    taktyki. Dzięki temu możemy łączyć proste taktyki w nieco bardziej
    skomplikowane lub jedynie zmieniać niektóre aspekty ich zachowań. 
<div class="paragraph"> </div>

<a name="lab48"></a><h2 class="section"><span class="inlinecode">;</span> (średnik)</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_intro''"><span class="id" type="lemma">iff_intro''</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, (<a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a>) → (<a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a>) → (<a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span>; [<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span> | <span class="id" type="tactic">apply</span> <span class="id" type="var">H0</span>]; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Najbardziej podstawowym kombinatorem jest <span class="inlinecode">;</span> (średnik). Zapis
    <span class="inlinecode"><span class="id" type="var">t1</span>;</span> <span class="inlinecode"><span class="id" type="var">t2</span></span> oznacza "użyj na obecnym celu taktyki <span class="inlinecode"><span class="id" type="var">t1</span></span>, a następnie
    na wszystkich podcelach wygenerowanych przez <span class="inlinecode"><span class="id" type="var">t1</span></span> użyj taktyki
    <span class="inlinecode"><span class="id" type="var">t2</span></span>".

<div class="paragraph"> </div>

    Zauważmy, że taktyka <span class="inlinecode"><span class="id" type="tactic">split</span></span> działa nie tylko na koniunkcjach i
    równoważnościach, ale także wtedy, gdy są one konkluzją pewnej
    implikacji. W takich przypadkach taktyka <span class="inlinecode"><span class="id" type="tactic">split</span></span> przed rozbiciem
    ich wprowadzi do kontekstu przesłanki implikacji (a także zmienne
    związane kwantyfikacją uniwersalną), zaoszczędzając nam użycia
    wcześniej taktyki <span class="inlinecode"><span class="id" type="tactic">intros</span></span>.

<div class="paragraph"> </div>

    Wobec tego, zamiast wprowadzać zmienne do kontekstu przy pomocy
    <span class="inlinecode"><span class="id" type="tactic">intros</span></span>, rozbijać cel <span class="inlinecode"><span class="id" type="tactic">split</span></span>em, a potem jeszcze w każdym
    podcelu z osobna wprowadzać do kontekstu przesłankę implikacji,
    możemy to zrobić szybciej pisząc <span class="inlinecode"><span class="id" type="tactic">split</span>;</span> <span class="inlinecode"><span class="id" type="tactic">intros</span></span>.

<div class="paragraph"> </div>

    Drugie użycie średnika jest uogólnieniem pierwszego. Zapis
    <span class="inlinecode"><span class="id" type="var">t</span>;</span> <span class="inlinecode">[<span class="id" type="var">t1</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">t2</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">tn</span>]</span> oznacza "użyj na obecnym podcelu
    taktyki <span class="inlinecode"><span class="id" type="var">t</span></span>; następnie na pierwszym wygenerowanym przez nią
    podcelu użyj taktyki <span class="inlinecode"><span class="id" type="var">t1</span></span>, na drugim <span class="inlinecode"><span class="id" type="var">t2</span></span>, etc., a na n-tym
    użyj taktyki <span class="inlinecode"><span class="id" type="var">tn</span></span>". Wobec tego zapis <span class="inlinecode"><span class="id" type="var">t1</span>;</span> <span class="inlinecode"><span class="id" type="var">t2</span></span> jest jedynie
    skróconą formą <span class="inlinecode"><span class="id" type="var">t1</span>;</span> <span class="inlinecode">[<span class="id" type="var">t2</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">t2</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">t2</span>]</span>.

<div class="paragraph"> </div>

    Użycie tej formy kombinatora <span class="inlinecode">;</span> jest uzasadnione tym, że
    w pierwszym z naszych podcelów musimy zaaplikować hipotezę
    <span class="inlinecode"><span class="id" type="var">H</span></span>, a w drugim <span class="inlinecode"><span class="id" type="var">H0</span></span> — w przeciwnym wypadku nasza taktyka
    zawiodłaby (sprawdź to). Ostatnie użycie tego kombinatora
    jest identyczne jak pierwsze — każdy z podcelów kończymy
    taktyką <span class="inlinecode"><span class="id" type="tactic">assumption</span></span>.

<div class="paragraph"> </div>

    Dzięki średnikowi dowód naszego twierdzenia skurczył się z
    trzech linijek do jednej, co jest wyśmienitym wynikiem —
    trzy razy mniej linii kodu to trzy razy mniejszy problem
    z jego utrzymaniem. Fakt ten ma jednak również i swoją
    ciemną stronę. Jest nią utrata interaktywności — wykonanie
    taktyki przeprowadza dowód od początku do końca.

<div class="paragraph"> </div>

    Znalezienie odpowiedniego balansu między automatyzacją i
    interaktywnością nie jest sprawą łatwą. Dowodząc twierdzenia
    twoim pierwszym i podstawowym celem powinno być zawsze jego
    zrozumienie, co oznacza dowód mniej lub bardziej interaktywny,
    nieautomatyczny. Gdy uda ci się już udowodnić i zrozumieć dane
    twierdzenie, możesz przejść do automatyzacji. Proces ten jest
    analogiczny jak w przypadku inżynierii oprogramowania — najpierw
    tworzy się działający prototyp, a potem się go usprawnia.

<div class="paragraph"> </div>

    Praktyka pokazuje jednak, że naszym ostatecznym
    celem powinna być pełna automatyzacja, tzn. sytuacja, w
    której dowód każdego twierdzenia (poza zupełnie banalnymi)
    będzie się sprowadzał, jak w powyższym przykładzie, do
    użycia jednej, specjalnie dla niego stworzonej taktyki.
    Ma to swoje uzasadnienie:

<div class="paragraph"> </div>

<ul class="doclist">
<li> zrozumienie cudzych dowodów jest zazwyczaj dość trudne,
      co ma spore znaczenie w większych projektach, w których
      uczestniczy wiele osób, z których część odchodzi, a na
      ich miejsce przychodzą nowe

</li>
<li> przebrnięcie przez dowód interaktywny, nawet jeżeli
      ma walory edukacyjne i jest oświecające, jest zazwyczaj
      czasochłonne, a czas to pieniądz

</li>
<li> skoro zrozumienie dowodu jest trudne i czasochłonne,
      to będziemy chcieli unikać jego zmieniania, co może
      nastąpić np. gdy będziemy chcieli dodać do systemu
      jakąś funkcjonalność i udowodnić, że po jej dodaniu
      system wciąż działa poprawnie 
</li>
</ul>

<div class="paragraph"> </div>

 Następujące ćwiczenia rozwiąż najpierw najpierw z jak największym
    zrozumieniem, a następnie zautomatyzuj tak, aby całość była
    rozwiązywana w jednym kroku przez pojedynczą (złożoną) taktykę. 
<div class="paragraph"> </div>

<a name="lab49"></a><h4 class="section">Ćwiczenie XXX.</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="or_comm_ex"><span class="id" type="lemma">or_comm_ex</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab50"></a><h4 class="section">Ćwiczenie XXX</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="diamond"><span class="id" type="lemma">diamond</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> <span class="id" type="var">S</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#R"><span class="id" type="variable">R</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">→</span></a> (<a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#S"><span class="id" type="variable">S</span></a>) → (<a class="idref" href="R1.html#R"><span class="id" type="variable">R</span></a> → <a class="idref" href="R1.html#S"><span class="id" type="variable">S</span></a>) → <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#S"><span class="id" type="variable">S</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab51"></a><h2 class="section"><span class="inlinecode">||</span> (alternatywa)</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_intro'''"><span class="id" type="lemma">iff_intro'''</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, (<a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a>) → (<a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a>) → (<a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H0</span> || <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Innym przydatnym kombinatorem jest <span class="inlinecode">||</span>, który będziemy nazywać
    alternatywą. Żeby wyjaśnić jego działanie, posłużymy się pojęciem
    postępu. Taktyka dokonuje postępu, jeżeli wygenerowany przez nią
    cel różni się od poprzedniego celu. Innymi słowy, taktyka nie
    dokonuje postępu, jeżeli nie zmienia obecnego celu. Za pomocą
    <span class="inlinecode"><span class="id" type="tactic">progress</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> możemy sprawdzić, czy taktyka <span class="inlinecode"><span class="id" type="var">t</span></span> dokona postępu
    na obecnym celu.

<div class="paragraph"> </div>

    Taktyka <span class="inlinecode"><span class="id" type="var">t1</span></span> <span class="inlinecode">||</span> <span class="inlinecode"><span class="id" type="var">t2</span></span> używa na obecnym celu <span class="inlinecode"><span class="id" type="var">t1</span></span>. Jeżeli <span class="inlinecode"><span class="id" type="var">t1</span></span> dokona
    postępu, to <span class="inlinecode"><span class="id" type="var">t1</span></span> <span class="inlinecode">||</span> <span class="inlinecode"><span class="id" type="var">t2</span></span> będzie miało taki efekt jak <span class="inlinecode"><span class="id" type="var">t1</span></span> i skończy
    się sukcesem. Jeżeli <span class="inlinecode"><span class="id" type="var">t1</span></span> nie dokona postępu, to na obecnym celu
    zostanie użyte <span class="inlinecode"><span class="id" type="var">t2</span></span>. Jeżeli <span class="inlinecode"><span class="id" type="var">t2</span></span> dokona postępu, to <span class="inlinecode"><span class="id" type="var">t1</span></span> <span class="inlinecode">||</span> <span class="inlinecode"><span class="id" type="var">t2</span></span>
    będzie miało taki efekt jak <span class="inlinecode"><span class="id" type="var">t2</span></span> i skończy się sukcesem. Jeżeli
    <span class="inlinecode"><span class="id" type="var">t2</span></span> nie dokona postępu, to <span class="inlinecode"><span class="id" type="var">t1</span></span> <span class="inlinecode">||</span> <span class="inlinecode"><span class="id" type="var">t2</span></span> zawiedzie i cel się nie
    zmieni.

<div class="paragraph"> </div>

    W naszym przypadku w każdym z podcelów wygenerowanych przez
    <span class="inlinecode"><span class="id" type="tactic">split</span>;</span> <span class="inlinecode"><span class="id" type="tactic">intros</span></span> próbujemy zaaplikować najpierw <span class="inlinecode"><span class="id" type="var">H0</span></span>, a potem
    <span class="inlinecode"><span class="id" type="var">H</span></span>. Na pierwszym podcelu <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H0</span></span> zawiedzie (a więc nie
    dokona postępu), więc zostanie użyte <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>, które zmieni
    cel. Wobec tego <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H0</span></span> <span class="inlinecode">||</span> <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> na pierwszym podcelu
    będzie miało taki sam efekt, jak użycie <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>. W drugim
    podcelu <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H0</span></span> skończy się sukcesem, więc tu <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H0</span></span> <span class="inlinecode">||</span>
    <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> będzie miało taki sam efekt, jak <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H0</span></span>. 
<div class="paragraph"> </div>

<a name="lab52"></a><h2 class="section"><span class="inlinecode"><span class="id" type="tactic">idtac</span></span>, <span class="inlinecode"><span class="id" type="tactic">do</span></span> oraz <span class="inlinecode"><span class="id" type="tactic">repeat</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="idtac_do_example"><span class="id" type="lemma">idtac_do_example</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> <span class="id" type="var">S</span> : <span class="id" type="keyword">Prop</span>, <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#S"><span class="id" type="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">idtac</span>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">right</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">idtac</span></span> to taktyka identycznościowa, czyli taka, która nic
    nic robi. Sama w sobie nie jest zbyt użyteczna, ale przydaje
    się do czasem do tworzenia bardziej skomplikowanych taktyk.

<div class="paragraph"> </div>

    Kombinator <span class="inlinecode"><span class="id" type="tactic">do</span></span> pozwala nam użyć danej taktyki określoną ilość
    razy. <span class="inlinecode"><span class="id" type="tactic">do</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> na obecnym celu używa <span class="inlinecode"><span class="id" type="var">t</span></span>. Jeżeli <span class="inlinecode"><span class="id" type="var">t</span></span> zawiedzie,
    to <span class="inlinecode"><span class="id" type="tactic">do</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> również zawiedzie. Jeżeli <span class="inlinecode"><span class="id" type="var">t</span></span> skończy się sukcesem,
    to na każdym podcelu wygenerowanym przez <span class="inlinecode"><span class="id" type="var">t</span></span> użyte zostanie
    <span class="inlinecode"><span class="id" type="tactic">do</span></span> <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">-</span> <span class="inlinecode">1)</span> <span class="inlinecode"><span class="id" type="var">t</span></span>. W szczególności <span class="inlinecode"><span class="id" type="tactic">do</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" type="var">t</span></span> działa jak <span class="inlinecode"><span class="id" type="tactic">idtac</span></span>,
    czyli kończy się sukcesem nic nie robiąc.

<div class="paragraph"> </div>

    W naszym przypadku użycie taktyki <span class="inlinecode"><span class="id" type="tactic">do</span></span> <span class="inlinecode">3</span> <span class="inlinecode"><span class="id" type="tactic">right</span></span> sprawi, że
    przy wyborze członu alternatywy, którego chcemy dowodzić,
    trzykrotnie pójdziemy w prawo. Zauważmy, że taktyka <span class="inlinecode"><span class="id" type="tactic">do</span></span> <span class="inlinecode">4</span> <span class="inlinecode"><span class="id" type="tactic">right</span></span>
    zawiodłaby, gdyż po 3 użyciach <span class="inlinecode"><span class="id" type="tactic">right</span></span> cel nie byłby już
    alternatywą, więc kolejne użycie <span class="inlinecode"><span class="id" type="tactic">right</span></span> zawiodłoby, a wtedy
    cała taktyka <span class="inlinecode"><span class="id" type="tactic">do</span></span> <span class="inlinecode">4</span> <span class="inlinecode"><span class="id" type="tactic">right</span></span> również zawiodłaby. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="repeat_example"><span class="id" type="lemma">repeat_example</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">C</span> <span class="id" type="var">D</span> <span class="id" type="var">E</span> <span class="id" type="var">F</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#A"><span class="id" type="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#B"><span class="id" type="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#C"><span class="id" type="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#D"><span class="id" type="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#E"><span class="id" type="variable">E</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#F"><span class="id" type="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">repeat</span> <span class="id" type="tactic">right</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Kombinator <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> powtarza daną taktykę, aż ta rozwiąże cel,
    zawiedzie, lub nie zrobi postępu. Formalnie: <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> używa
    na obecnym celu taktyki <span class="inlinecode"><span class="id" type="var">t</span></span>. Jeżeli <span class="inlinecode"><span class="id" type="var">t</span></span> rozwiąże cel, to
    <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> kończy się sukcesem. Jeżeli <span class="inlinecode"><span class="id" type="var">t</span></span> zawiedzie lub nie
    zrobi postępu, to <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> również kończy się sukcesem.
    Jeżeli <span class="inlinecode"><span class="id" type="var">t</span></span> zrobi jakiś postęp, to na każdym wygenerowaym przez
    nią celu zostanie użyte <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span>.

<div class="paragraph"> </div>

    W naszym przypadku <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> <span class="inlinecode"><span class="id" type="tactic">right</span></span> ma taki efekt, że przy wyborze
    członu alternatywy wybieramy człon będący najbardziej na prawo,
    tzn. dopóki cel jest alternatywą, aplikowana jest taktyka <span class="inlinecode"><span class="id" type="tactic">right</span></span>,
    która wybiera prawy człon. Kiedy nasz cel przestaje być alternatywą,
    taktyka <span class="inlinecode"><span class="id" type="tactic">right</span></span> zawodzi i wtedy taktyka <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> <span class="inlinecode"><span class="id" type="tactic">right</span></span> kończy swoje
    działanie sukcesem. 
<div class="paragraph"> </div>

<a name="lab53"></a><h2 class="section"><span class="inlinecode"><span class="id" type="tactic">try</span></span> i <span class="inlinecode"><span class="id" type="tactic">fail</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_intro4"><span class="id" type="lemma">iff_intro4</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, (<a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a>) → (<a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a>) → (<a class="idref" href="R1.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">try</span> (<span class="id" type="tactic">apply</span> <span class="id" type="var">H0</span>; <span class="id" type="tactic">assumption</span>; <span class="id" type="tactic">fail</span>);<br/>
&nbsp;&nbsp;<span class="id" type="tactic">try</span> (<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">assumption</span>; <span class="id" type="tactic">fail</span>).<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">try</span></span> jest kombinatorem, który zmienia zachowanie przekazanej mu
    taktyki. Jeżeli <span class="inlinecode"><span class="id" type="var">t</span></span> zawiedzie, to <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> zadziała jak <span class="inlinecode"><span class="id" type="tactic">idtac</span></span>,
    czyli nic nie zrobi i skończy się sukcesem. Jeżeli <span class="inlinecode"><span class="id" type="var">t</span></span> skończy się
    sukcesem, to <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> również skończy się sukcesem i będzie miało
    taki sam efekt, jak <span class="inlinecode"><span class="id" type="var">t</span></span>. Tak więc, podobnie jak <span class="inlinecode"><span class="id" type="tactic">repeat</span></span>, <span class="inlinecode"><span class="id" type="tactic">try</span></span>
    nigdy nie zawodzi.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" type="tactic">fail</span></span> jest przeciwieństwem <span class="inlinecode"><span class="id" type="tactic">idtac</span></span> — jest to taktyka, która zawsze
    zawodzi. Sama w sobie jest bezużyteczna, ale w tandemie z <span class="inlinecode"><span class="id" type="tactic">try</span></span>
    oraz średnikiem daje nam pełną kontrolę nad tym, czy taktyka
    zakończy się sukcesem, czy zawiedzie, a także czy dokona postępu.

<div class="paragraph"> </div>

    Częstym sposobem użycia <span class="inlinecode"><span class="id" type="tactic">try</span></span> i <span class="inlinecode"><span class="id" type="tactic">fail</span></span> jest <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="var">t</span>;</span> <span class="inlinecode"><span class="id" type="tactic">fail</span>)</span>. Taktyka
    ta na obecnym celu używa <span class="inlinecode"><span class="id" type="var">t</span></span>. Jeżeli <span class="inlinecode"><span class="id" type="var">t</span></span>
    rozwiąże cel, to <span class="inlinecode"><span class="id" type="tactic">fail</span></span> nie zostanie wywołane i całe <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="var">t</span>;</span> <span class="inlinecode"><span class="id" type="tactic">fail</span>)</span>
    zadziała tak jak <span class="inlinecode"><span class="id" type="var">t</span></span>, czyli rozwiąże cel. Jeżeli <span class="inlinecode"><span class="id" type="var">t</span></span> nie rozwiąże celu,
    to na wygenerowanych podcelach wywoływane zostanie <span class="inlinecode"><span class="id" type="tactic">fail</span></span>, które
    zawiedzie — dzięki temu <span class="inlinecode"><span class="id" type="var">t</span>;</span> <span class="inlinecode"><span class="id" type="tactic">fail</span></span> również zawiedzie, nie dokonując
    żadnych zmian w celu (nie dokona postępu), a całe <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="var">t</span>;</span> <span class="inlinecode"><span class="id" type="tactic">fail</span>)</span>
    zakończy się sukcesem, również nie dokonując w celu żadnych zmian.
    Wobec tego działanie <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="var">t</span>;</span> <span class="inlinecode"><span class="id" type="tactic">fail</span>)</span> można podsumować tak: "jeżeli <span class="inlinecode"><span class="id" type="var">t</span></span>
    rozwiąże cel to użyj jej, a jeżeli nie, to nic nie rób".

<div class="paragraph"> </div>

    Postaraj się dokładnie zrozumieć, jak opis ten ma się do powyższego
    przykładu — spróbuj usunąć jakieś <span class="inlinecode"><span class="id" type="tactic">try</span></span>, <span class="inlinecode"><span class="id" type="tactic">fail</span></span> lub średnik i zobacz,
    co się stanie.

<div class="paragraph"> </div>

    Oczywiście przykład ten jest bardzo sztuczny — najlepszym pomysłem
    udowodnienia tego twierdzenia jest użycie ogólnej postaci średnika
    <span class="inlinecode"><span class="id" type="var">t</span>;</span> <span class="inlinecode"><span class="id" type="var">t1</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">tn</span></span>, tak jak w przykładzie <span class="inlinecode"><span class="id" type="var">iff_intro''</span></span>. Idiom
    <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode">(<span class="id" type="var">t</span>;</span> <span class="inlinecode"><span class="id" type="tactic">fail</span>)</span> najlepiej sprawdza się, gdy użycie średnika w ten
    sposób jest niepraktyczne, czyli gdy celów jest dużo, a rozwiązać
    automatycznie potrafimy tylko część z nich. Możemy użyć go wtedy,
    żeby pozbyć się prostszych przypadków nie zaśmiecając sobie jednak
    kontekstu w pozostałych przypadkach. Idiom ten jest też dużo
    bardziej odporny na przyszłe zmiany w programie, gdyż użycie go
    nie wymaga wiedzy o tym, ile podcelów zostanie wygenerowanych.

<div class="paragraph"> </div>

    Przedstawione kombinatory są najbardziej użyteczne i stąd
    najpowszechniej używane. Nie są to jednak wszystkie kombinatory
    — jest ich znacznie więcej. Opisy taktyk i kombinatorów
    z biblioteki standardowej znajdziesz tu:
    https://coq.inria.fr/refman/tactic-index.html 
<div class="paragraph"> </div>

<a name="lab54"></a><h1 class="section">Zadania (beta)</h1>
 Uwaga: niektóre zadania mogą pokrywać się z ćwiczeniami, które
    występują w tekście.
    Uwaga TODO: dodać ćwiczenia do sekcji Kombinatory taktyk. 
<div class="paragraph"> </div>

<a name="lab55"></a><h2 class="section">Konstruktywny rachunek zdań.</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Section</span> <a name="exercises_propositional"><span class="id" type="section">exercises_propositional</span></a>.<br/>
<span class="id" type="keyword">Hypotheses</span> <a name="exercises_propositional.P"><span class="id" type="variable">P</span></a> <a name="exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a name="exercises_propositional.R"><span class="id" type="variable">R</span></a> <a name="exercises_propositional.S"><span class="id" type="variable">S</span></a> : <span class="id" type="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
Komenda <span class="inlinecode"><span class="id" type="keyword">Hypotheses</span></span> formalnie działa jak wprowadzenie aksjomatu,
    który w naszym przypadku brzmi "P, Q, R i S są zdaniami logicznymi".
    Taki aksjomat jest rzecz jasna zupełnie niegroźny, ale z innymi
    trzeba uważać — gdybyśmy wprowadzili aksjomat <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>, to
    popadlibyśmy w sprzeczność i nie moglibyśmy ufać żadnym dowodom,
    które przeprowadzamy. 
</div>
<div class="code">

<br/>

<br/>
<span class="comment">(*&nbsp;Przemienność&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="and_comm"><span class="id" type="lemma">and_comm</span></a> : <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="or_comm"><span class="id" type="lemma">or_comm</span></a> : <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;Łączność&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="and_assoc"><span class="id" type="lemma">and_assoc</span></a> : <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="or_assoc"><span class="id" type="lemma">or_assoc</span></a> : <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;Rozdzielność&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="and_dist_or"><span class="id" type="lemma">and_dist_or</span></a> : <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="or_dist_and"><span class="id" type="lemma">or_dist_and</span></a> : <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="imp_dist_imp"><span class="id" type="lemma">imp_dist_imp</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a>(<a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a>) → (<a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>)).<br/>

<br/>
<span class="comment">(*&nbsp;Kuryfikacja&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="curry"><span class="id" type="lemma">curry</span></a> : (<a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>) → (<a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>).<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="uncurry"><span class="id" type="lemma">uncurry</span></a> : (<a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>) → (<a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>).<br/>

<br/>
<span class="comment">(*&nbsp;De&nbsp;Morgan&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="deMorgan_1"><span class="id" type="lemma">deMorgan_1</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="deMorgan_2"><span class="id" type="lemma">deMorgan_2</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;Niesprzeczność&nbsp;i&nbsp;zasada&nbsp;wyłączonego&nbsp;środka&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="noncontradiction'"><span class="id" type="lemma">noncontradiction'</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="noncontradiction_v2"><span class="id" type="lemma">noncontradiction_v2</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="em_irrefutable"><span class="id" type="lemma">em_irrefutable</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~~(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;Elementy&nbsp;neutralne&nbsp;i&nbsp;anihilujące&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="and_false_annihilation"><span class="id" type="lemma">and_false_annihilation</span></a> : <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="or_false_neutral"><span class="id" type="lemma">or_false_neutral</span></a> : <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_true_neutral"><span class="id" type="lemma">and_true_neutral</span></a> : <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="or_true_annihilation"><span class="id" type="lemma">or_true_annihilation</span></a> : <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;Różne&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="or_imp_and"><span class="id" type="lemma">or_imp_and</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>).<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_not_imp"><span class="id" type="lemma">and_not_imp</span></a> : <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a>).<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="or_not_imp"><span class="id" type="lemma">or_not_imp</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">→</span></a> (<a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a>).<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="contraposition"><span class="id" type="lemma">contraposition</span></a> : (<a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a>) → (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="absurd"><span class="id" type="lemma">absurd</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="impl_and"><span class="id" type="lemma">impl_and</span></a> : (<a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> → (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.Q"><span class="id" type="variable">Q</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_propositional.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_propositional.R"><span class="id" type="variable">R</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="R1.html#exercises_propositional"><span class="id" type="section">exercises_propositional</span></a>.<br/>

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="R1.html#and_comm"><span class="id" type="lemma">and_comm</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;P&nbsp;Q&nbsp;:&nbsp;Prop,&nbsp;P&nbsp;/\&nbsp;Q&nbsp;-&gt;&nbsp;Q&nbsp;/\&nbsp;P&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
W praktyce komenda <span class="inlinecode"><span class="id" type="keyword">Hypothesis</span></span> służy do tego, żeby za dużo nie
    pisać — po zamknięciu sekcji komendą <span class="inlinecode"><span class="id" type="keyword">End</span></span>, Coq doda do każdego
    twierdzenia znajdującego się w tej sekcji kwantyfikację uniwersalną
    po hipotezach zadeklarowanych przy pomocy <span class="inlinecode"><span class="id" type="keyword">Hypothesis</span></span>. W naszym
    przypadku Coq dodał do <span class="inlinecode"><span class="id" type="var">and_comm</span></span> kwantyfikację po <span class="inlinecode"><span class="id" type="var">P</span></span> i <span class="inlinecode"><span class="id" type="var">Q</span></span>,
    mimo że nie napisaliśmy jej explicite. 
<div class="paragraph"> </div>

<a name="lab56"></a><h2 class="section">Konstruktywny rachunek predykatów.</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Section</span> <a name="exercises_predicate"><span class="id" type="section">exercises_predicate</span></a>.<br/>
<span class="id" type="keyword">Variable</span> <a name="exercises_predicate.A"><span class="id" type="variable">A</span></a> : <span class="id" type="keyword">Type</span>.<br/>
<span class="id" type="keyword">Hypotheses</span> <a name="exercises_predicate.P"><span class="id" type="variable">P</span></a> <a name="exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a name="exercises_predicate.R"><span class="id" type="variable">R</span></a> <a name="exercises_predicate.S"><span class="id" type="variable">S</span></a> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a> → <span class="id" type="keyword">Prop</span>.<br/>

<br/>
<span class="comment">(*&nbsp;Projekcje&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="forall_and_proj1"><span class="id" type="lemma">forall_and_proj1</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a> ∧ <a class="idref" href="R1.html#exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) → (<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>).<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="forall_and_proj2"><span class="id" type="lemma">forall_and_proj2</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a> ∧ <a class="idref" href="R1.html#exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) → (<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>).<br/>

<br/>
<span class="comment">(*&nbsp;Rozdzielność&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="forall_dist_and"><span class="id" type="lemma">forall_dist_and</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a> ∧ <a class="idref" href="R1.html#exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>).<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="exists_dist_or"><span class="id" type="lemma">exists_dist_or</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a> ∨ <a class="idref" href="R1.html#exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="R1.html#exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>).<br/>

<br/>
<span class="comment">(*&nbsp;Inne&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="forall_or_imp"><span class="id" type="lemma">forall_or_imp</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">→</span></a> (<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a> ∨ <a class="idref" href="R1.html#exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>).<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="forall_imp_imp"><span class="id" type="lemma">forall_imp_imp</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a> → <a class="idref" href="R1.html#exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) → (<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) → (<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>).<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="forall_inhabited_nondep"><span class="id" type="lemma">forall_inhabited_nondep</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a> → (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#R"><span class="id" type="variable">R</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="R1.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="forall_or_nondep"><span class="id" type="lemma">forall_or_nondep</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#R"><span class="id" type="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">→</span></a> (<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a> ∨ <a class="idref" href="R1.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="forall_nondep_impl"><span class="id" type="lemma">forall_nondep_impl</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#R"><span class="id" type="variable">R</span></a> → <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#R"><span class="id" type="variable">R</span></a> → <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#exercises_predicate.A"><span class="id" type="variable">A</span></a>, <a class="idref" href="R1.html#exercises_predicate.P"><span class="id" type="variable">P</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>).<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="barber_paradox"><span class="id" type="lemma">barber_paradox</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">man</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">barber</span> : <a class="idref" href="R1.html#man"><span class="id" type="variable">man</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">shaves</span> : <a class="idref" href="R1.html#man"><span class="id" type="variable">man</span></a> → <a class="idref" href="R1.html#man"><span class="id" type="variable">man</span></a> → <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#man"><span class="id" type="variable">man</span></a>, <a class="idref" href="R1.html#shaves"><span class="id" type="variable">shaves</span></a> <a class="idref" href="R1.html#barber"><span class="id" type="variable">barber</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a> ↔ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="R1.html#shaves"><span class="id" type="variable">shaves</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>) → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">
W przyszłości pojawi się krótkie wyjaśnienie dotyczące tego
    zadania. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="R1.html#exercises_predicate"><span class="id" type="section">exercises_predicate</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab57"></a><h2 class="section">Klasyczny rachunek zdań (i predykatów).</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Section</span> <a name="exercises_classical"><span class="id" type="section">exercises_classical</span></a>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Logic.Classical.html#"><span class="id" type="library">Classical</span></a>.<br/>
<span class="id" type="keyword">Hypotheses</span> <a name="exercises_classical.P"><span class="id" type="variable">P</span></a> <a name="exercises_classical.Q"><span class="id" type="variable">Q</span></a> <a name="exercises_classical.R"><span class="id" type="variable">R</span></a> <a name="exercises_classical.S"><span class="id" type="variable">S</span></a> : <span class="id" type="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
Koemnda <span class="inlinecode"><span class="id" type="keyword">Require</span></span> <span class="inlinecode"><span class="id" type="keyword">Import</span></span> pozwala nam zaimportować żądany
    moduł z biblioteki standardowej Coqa. Dzięki temu będziemy
    mogli używać zawartych w nim definicji, twierdzeń etc.

<div class="paragraph"> </div>

    Classical to moduł, który pozwala przeprowadzać rozumowania
    w logice klasycznej. Deklaruje on jako aksjomaty niektóre
    tautologie logiki klasycznej, np. zasadę wyłączonego środka,
    która tutaj nazywa się <span class="inlinecode"><span class="id" type="var">classic</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Logic.Classical_Prop.html#classic"><span class="id" type="axiom">classic</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;P&nbsp;:&nbsp;Prop,&nbsp;P&nbsp;\/&nbsp;~&nbsp;P&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="imp_and_or"><span class="id" type="lemma">imp_and_or</span></a> : (<a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_classical.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_classical.R"><span class="id" type="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a> → (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_classical.Q"><span class="id" type="variable">Q</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">(</span></a><a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_classical.R"><span class="id" type="variable">R</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="deMorgan_2_conv"><span class="id" type="lemma">deMorgan_2_conv</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="R1.html#exercises_classical.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_classical.Q"><span class="id" type="variable">Q</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="not_imp"><span class="id" type="lemma">not_imp</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_classical.Q"><span class="id" type="variable">Q</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_classical.Q"><span class="id" type="variable">Q</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="imp_not_or"><span class="id" type="lemma">imp_not_or</span></a> : (<a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_classical.Q"><span class="id" type="variable">Q</span></a>) → (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="R1.html#exercises_classical.Q"><span class="id" type="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="contraposition_conv"><span class="id" type="lemma">contraposition_conv</span></a> : (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_classical.Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a> → (<a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_classical.Q"><span class="id" type="variable">Q</span></a>).<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="excluded_middle"><span class="id" type="lemma">excluded_middle</span></a> : <a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="peirce"><span class="id" type="lemma">peirce</span></a> : ((<a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a> → <a class="idref" href="R1.html#exercises_classical.Q"><span class="id" type="variable">Q</span></a>) → <a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a>) → <a class="idref" href="R1.html#exercises_classical.P"><span class="id" type="variable">P</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="drinker_paradox"><span class="id" type="lemma">drinker_paradox</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">man</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">drinks</span> : <a class="idref" href="R1.html#man"><span class="id" type="variable">man</span></a> → <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="R1.html#man"><span class="id" type="variable">man</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">drinker</span> : <a class="idref" href="R1.html#man"><span class="id" type="variable">man</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="R1.html#drinks"><span class="id" type="variable">drinks</span></a> <a class="idref" href="R1.html#drinker"><span class="id" type="variable">drinker</span></a> → <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> : <a class="idref" href="R1.html#man"><span class="id" type="variable">man</span></a>, <a class="idref" href="R1.html#drinks"><span class="id" type="variable">drinks</span></a> <a class="idref" href="R1.html#x"><span class="id" type="variable">x</span></a>.<br/>

<br/>
</div>

<div class="doc">
To zadanie też pewnie w przyszłości szczegółowiej opiszę. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="R1.html#exercises_classical"><span class="id" type="section">exercises_classical</span></a>.<br/>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>