<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-88023543-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<h1 class="libtitle">R0: Wstęp</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab1"></a><h1 class="section">Cel</h1>
 Celem tego kursu jest zapoznanie czytelnika z kilkoma rzeczami:

<div class="paragraph"> </div>

<ul class="doclist">
<li> programowaniem funkcyjnym w duchu Haskella i rodziny ML,
      przeciwstawionym programowaniu imperatywnemu

</li>
<li> dowodzeniem twierdzeń, które jest:
<ul class="doclist">
<li> formalne, gdzie "formalny" znaczy "zweryfikowany przez komputer"

</li>
<li> interaktywne, czyli umożliwiające dowolne wykonywanie i cofanie
        kroków dowodu oraz sprawdzenie jego stanu po każdym kroku

</li>
<li> (pół)automatyczne, czyli takie, w którym komputer może wyręczyć
        użytkownika w wykonywaniu trywialnych i żmudnych, ale koniecznych
        kroków dowodu

</li>
</ul>

</li>
<li> matematyką opartą na logice konstruktywnej, teorii typów i teorii
      kategorii oraz na ich zastosowaniach do dowodzenia poprawności
      programów funkcyjnych i w szeroko pojętej informatyce 
</li>
</ul>

<div class="paragraph"> </div>

 W tym krótkim wstępie postaramy się spojrzeć na powyższe cele z
    perspektywy historycznej, a nie dydaktycznej. Nie przejmuj się
    zatem, jeżeli nie rozumiesz jakiegoś pojęcia lub terminu — czas
    na dogłębne wyjaśnienia przyjdzie w kolejnych rozdziałach. 
<div class="paragraph"> </div>

<a name="lab2"></a><h1 class="section">Wybór</h1>
 Istnieje wiele środków, które pozwoliłyby nam osiągnąć postawione
    cele, a jako że nie sposób poznać ich wszystkich, musimy dokonać
    wyboru.

<div class="paragraph"> </div>

    Wśród dostępnych języków programowania jest wymieniony już
    Haskell, ale nie pozwala on na dowodzenie twierdzeń (a poza tym jest
    sprzeczny, jeżeli zinterpretujemy go jako system logiczny), a także
    jego silniejsze potomstwo, jak Idris czy Agda, w których możemy
    dowodzić, ale ich wsparcie dla interaktywności oraz automatyzacji
    jest marne.

<div class="paragraph"> </div>

    Wśród asystentów dowodzenia (ang. proof assistants) mamy do wyboru
    takich zawodników, jak polski system Mizar, który nie jest jednak
    oparty na teorii typów, Lean, który niestety jest jeszcze w fazie
    rozwoju, oraz Coq. Nasz wybór padnie właśnie na ten ostatni język. 
<div class="paragraph"> </div>

<a name="lab3"></a><h1 class="section">Programowanie i dowodzenie</h1>
<a name="lab4"></a><h2 class="section">Alan Turing i jego maszyna</h2>
 Teoretyczna nauka o obliczeniach powstała niedługo przed wynalezieniem
    pierwszych komputerów. Od samego początku definicji obliczalności
    oraz modeli obliczeń było wiele. Choć pokazano później, że wszystkie
    są równoważne, z konkurencji między nimi wyłonił się niekwestionowany
    zwycięzca — maszyna Turinga, wynaleziona przez Alana... (zgadnij
    jak miał na nazwisko).

<div class="paragraph"> </div>

    Maszyna Turinga nazywa się maszyną nieprzypadkowo — jest mocno
    "hardware'owym" modelem obliczeń. Idea jest dość prosta: maszyna
    ma nieskończenie długą taśmę, przy pomocy której może odczytywać
    i zapisywać symbole oraz manipulować nimi według pewnych reguł.

<div class="paragraph"> </div>

    W czasach pierwszych komputerów taki "sprzętowy" sposób myślenia
    przeważył i wyznaczył kierunek rozwoju języków programowania,
    który dominuje do dziś. Kierunek ten jest imperatywny; program
    to w jego wyobrażeniu ciąg instrukcji, których rolą jest zmiana
    obecnego stanu pamięci na inny.

<div class="paragraph"> </div>

    Ten styl programowania sprawdził się w tym sensie, że istnieje na
    świecie cała masa różnych systemów informatycznych zaprogramowanych
    w językach imperatywnych, które jakoś działają... Nie jest on jednak
    doskonały. Wprost przeciwnie — jest:

<div class="paragraph"> </div>

<ul class="doclist">
<li> trudny w analizie (trudno przewidzieć, co robi program, jeżeli
      na jego zachowanie wpływ ma cały stan programu)

</li>
<li> trudny w urównoleglaniu (trudno wykonywać jednocześnie różne
      części programu, jeżeli wszystkie mogą modyfikować wspólny
      globalny stan) 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab5"></a><h2 class="section">Alonzo Church i rachunek λ</h2>
 Innym modelem obliczeń, nieco bardziej abstrakcyjnym czy też
    "software'owym" jest rachunek λ, wymyślony przez Alonzo Churcha.
    Nie stał się tak wpływowy jak maszyny Turinga, mimo że jest równie
    prosty — opiera się jedynie na dwóch operacjach:

<div class="paragraph"> </div>

<ul class="doclist">
<li> λ-abstrakcji, czyli związaniu zmiennej wolnej w wyrażeniu, co
      czyni z niego funkcję

</li>
<li> aplikacji funkcji do argumentu, która jest realizowana przez
      podstawienie argumentu za zmienną związaną 
</li>
</ul>

<div class="paragraph"> </div>

 Nie bój się, jeśli nie rozumiesz; jestem marnym bajkopisarzem i
    postaram się wyjaśnić wszystko później, przy użyciu odpowiednich
    przykładów.

<div class="paragraph"> </div>

    Oryginalny rachunek λ nie był typowany, tzn. każdą funkcję można
    "wywołać" z każdym argumentem, co może prowadzić do bezsensownych
    pomyłek. Jakiś czas później wymyślono typowany rachunek λ, w którym
    każdy term (wyrażenie) miał swój "typ", czyli metkę, która mówiła,
    jakiego jest rodzaju (liczba, funkcja etc.).

<div class="paragraph"> </div>

    Następnie odkryto, że przy pomocy typowanego rachunku λ można wyrazić
    intuicjonistyczny rachunek zdań oraz reprezentować dowody przeprowadzone
    przy użyciu dedukcji naturalnej. Tak narodziła się "korespondencja
    Curry'ego-Howarda", która stwierdza między innymi, że pewne systemy
    logiczne odpowiadają pewnym rodzajom typowanego rachunku λ, że
    zdania logiczne odpowiadają typom, a dowody — programom. 
<div class="paragraph"> </div>

<a name="lab6"></a><h2 class="section">Martin-Löf, Coquand, CoC, CIC i Coq</h2>
 Kolejnego kroku dokonał Jean-Yves Girard, tworząc System F —
    typowany, polimorficzny rachunek λ, który umożliwia reprezentację
    funkcji generycznych, działających na argumentach dowolnego typu
    w ten sam sposób (przykładem niech będzie funkcja identycznościowa).
    System ten został również odkryty niezależnie przez Johna Reynoldsa.

<div class="paragraph"> </div>

    Następna gałąź badań, która przyczyniła się do obecnego kształtu
    języka Coq, została zapoczątkowana przez szwedzkiego matematyka
    imieniem Per Martin-Löf. W swojej intuicjonistycznej teorii
    typów (blisko spokrewnionej z rachunkiem λ) wprowadził on pojęcie
    typu zależnego. Typy zależne, jak się okazało, odpowiadają
    intuicjonistycznemu rachunkowi predykatów — i tak korespondencja
    Curry'ego-Howarda rozrastała się...

<div class="paragraph"> </div>

    Innymi rozszerzeniami typowanego rachunku λ były operatory typów
    (ang. type operators), czyli funkcje biorące i zwracające typy.
    Te trzy ścieżki rozwoju (polimorfizm, operatory typów i typy
    zależne) połączył w rachunku konstrukcji (ang. Calculus of
    Constructions, w skrócie CoC) Thierry Coquand, jeden z twórców
    języka Coq, którego pierwsza wersja była oparta właśnie o rachunek
    konstrukcji.

<div class="paragraph"> </div>

    Zwieńczeniem tej ścieżki rozwoju były typy induktywne, również
    obecne w teorii typów Martina-Löfa. Połączenie rachunku konstrukcji
    i typów induktywnych dało rachunek induktywnych konstrukcji (ang.
    Calculus of Inductive Constructions, w skrócie CIC), który jest
    obecną podstawą teoretyczną języka Coq (po drobnych rozszerzeniach,
    takich jak dodanie typów koinduktywnych oraz hierarchii uniwersów,
    również pożyczonej od Martina-Löfa). 
<div class="paragraph"> </div>

<a name="lab7"></a><h1 class="section">Literatura</h1>
 Mimo, iż Coq liczy sobie dobre 27 lat, przystępnej literatury na
    jego temat jest jak na lekarstwo, choć stan ten na szczęście
    ulega ostatnio szybkim zmianom. Z dostępnych pozycji polecenia
    godne są:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Software Foundations Benjamina Pierce'a — książka dwuczęściowa,
      zawierająca dobre wprowadzenie do języka Coq (aczkolwiek
      pomijająca niektóre mechanizmy, jak klasy, oraz skupiająca
      się moim zdaniem zbyt mało na automatyzacji) oraz część
      dotyczącą teorii języków programowania, definiowania ich
      składni i semantyki w Coqu oraz dowodzenia ich własności.
      Dostępna za darmo tutaj: cis.upenn.edu/~bcpierce/sf/current

</li>
<li> Coq'Art, której autorami są Yves Bertot oraz Pierre Castéran —
      książka nieco szerzej opisująca język Coq, poświęca sporo
      miejsca rachunkowi konstrukcj i aspektom teoretycznym, zawiera
      także rozdziały dotyczące automatyzacji, silnej specyfikacji,
      koindukcji, zaawansowanej rekurencji i reflekcji. Wersja
      angielska jest płatna, zaś wersja francuska jest dostępna za
      darmo tu: labri.fr/perso/casteran/CoqArt

</li>
<li> Certified Programming with Dependent Types Adama Chlipali —
      książka dla zaawansowanych, traktująca o praktycznym użyciu
      typów zależnych oraz kładąca bardzo mocny nacisk na
      automatyzację, dostępna za darmo tu: adam.chlipala.net/cpdt

</li>
<li> Verified Functional Algorithms, której autorem jest Andrew
      Appel, to trzecia część cyklu Software Foundations. Jak sama
      nazwa wskazuje skupia się ona na algorytmach, adaptowaniu ich
      do realiów języków funkcyjnych oraz weryfikacją poprawności
      ich działania. Analiza algorytmów jest odsunięta na dalszy
      plan, gdyż jest niemożliwe, aby w Coqu formalnie udowodnić
      złożoność jakiegoś algorytmu. Dostępna jest za darmo tutaj:
      https://www.cs.princeton.edu/~appel/vfa/

</li>
<li> Mathematical Components Book, dostępna za darmo tutaj:
      https://math-comp.github.io/mcb/book.pdf, to książka dotycząca
      biblioteki o nazwie Mathematical Components. Zawiera ona
      wprowadzenia do Coqa, ale poza tym opisuje też dwie inne rzeczy:
<ul class="doclist">
<li> Metodologię dowodzenie zwaną <i>small scale reflection</i>
        (ang. reflekcja na małą skalę), która pozwala wykorzystać
        w dowodach maksimum możliwości obliczeniowych Coqa, a dzięki
        temu uprościć dowody i zorganizować twierdzenia w logiczny
        sposób

</li>
<li> Język taktyk Ssreflect, którego bazą jest <span class="inlinecode"><span class="id" type="keyword">Ltac</span></span>, a który
        wprowadza w stosunku do niego wiele ulepszeń i udogodnień,
        umożliwiając między innymi sprawne zastosowanie metodologii
        <i>small scale reflection</i> w praktyce

</li>
</ul>

</li>
<li> Manual, dostępny pod adresem https://coq.inria.fr/refman/,
      nie jest wprawdzie zbyt przyjazny do czytania ciurkiem, ale
      można tu znaleźć wiele wartościowych informacji. Gdyby ktoś
      jednak pokusił się o przeczytanie go od deski do deski,
      polecam następującą kolejności rozdziałów: 4 -&gt; (5) -&gt; 1 -&gt; 2 -&gt;
      17 -&gt; 29 -&gt; 13 -&gt; 12 -&gt; (3) -&gt; (6) -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 21 -&gt;
      22 -&gt; 25 -&gt; 26 -&gt; 27 -&gt; 18 -&gt; 19 -&gt; 20 -&gt; 24 -&gt; 23 -&gt; (11) -&gt;
      (14) -&gt; (15) -&gt; (16) -&gt; (28) -&gt; (30), gdzie nawiasy okrągłe
      oznaczają rozdziały opcjonalne (niezbyt ciekawe lub nieprzydatne) 
</li>
</ul>

<div class="paragraph"> </div>

 Zalecana kolejność czytania:
    SF, część 1 -&gt; (Coq'Art) -&gt; (MCB) -&gt; SF, część 2 i 3 -&gt; CPDT -&gt;
    Manual 
<div class="paragraph"> </div>

<a name="lab8"></a><h1 class="section">Sprawy techniczne</h1>
 Kurs ten tworzę z myślą o osobach, które potrafią programować w
    jakimś języku imperatywnym oraz znają podstawy logiki klasycznej,
    ale będę się starał uczynić go jak najbardziej zrozumiałym dla
    każdego. Polecam nie folgować sobie i wykonywać wszystkie ćwiczenia
    w miarę czytania, a cały kod koniecznie przepisywać ręcznie, bez
    kopiowania i wklejania. Poza ćwiczeniami składającymi się z
    pojedynczych twierdzeń powinny się też pojawić miniprojekty, które
    będą polegać na formalizacji jakiejś drobnej teorii lub zastosowaniu
    nabytej wiedzy do rozwiązania jakiegoś typowego problemu.

<div class="paragraph"> </div>

    Język Coq można pobrać z jego strony domowej: coq.inria.fr

<div class="paragraph"> </div>

    Z tej samej strony można pobrać CoqIDE, darmowe IDE stworzone
    specjalnie dla języka Coq. Wprawdzie z Coqa można korzystać
    w konsoli lub przy użyciu edytora Proof General, zintegrowanego
    z Emacsem, ale w dalszej części tekstu będę zakładał, że użytkownik
    korzysta właśnie z CoqIDE.

<div class="paragraph"> </div>

    Gdyby ktoś miał problemy z CoqIDE, lekką alternatywą jest ProofWeb:
    http://proofweb.cs.ru.nl/index.html

<div class="paragraph"> </div>

    Uwaga: kurs powstaje w czasie rzeczywistym. Nie polecam czytać
    rozdziałów i podrozdziałów oznaczonych jako alfa, bo może to
    poskutkować nagłym atakiem raka mózgu. 
</div>
<div class="code">
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>