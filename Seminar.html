<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-88023543-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<h1 class="libtitle">Seminar: IndPred</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 The topic of this talk is "Inductive Predicates", but we won't confine
    ourselves to just them and will study all the different kinds of
    inductive types out there. 
<div class="paragraph"> </div>

<a name="lab148"></a><h1 class="section">Inductive propositions and types with a grain of axioms</h1>

<div class="paragraph"> </div>

 Let's start with inductive propositions: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;False&nbsp;:&nbsp;Prop&nbsp;:=&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;True&nbsp;:&nbsp;Prop&nbsp;:=&nbsp;&nbsp;I&nbsp;:&nbsp;True&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">False</span></span> and <span class="inlinecode"><span class="id" title="var">True</span></span> have very simple definitions. <span class="inlinecode"><span class="id" title="var">False</span></span> doesn't have
    any constructors and <span class="inlinecode"><span class="id" title="var">True</span></span> does have one, called <span class="inlinecode"><span class="id" title="var">I</span></span>. This name is
    arbitrary — it has to be there, because constructors can't be nameless,
    but doesn't really matter, because we're only interested in its existence,
    not name.

<div class="paragraph"> </div>

    The definitions are not that interesting if you have seen them already,
    so let's have a look at something weirder: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="VeryTrue"><span class="id" title="inductive">VeryTrue</span></a> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="proof"><span class="id" title="constructor">proof</span></a> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="other_proof"><span class="id" title="constructor">other_proof</span></a> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a>.<br/>

<br/>
</div>

<div class="doc">
How is this one different from <span class="inlinecode"><span class="id" title="var">True</span></span>? Well, <span class="inlinecode"><span class="id" title="var">False</span></span>, <span class="inlinecode"><span class="id" title="var">True</span></span> and
    <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> can be likened to <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, <span class="inlinecode"><span class="id" title="var">unit</span></span> and <span class="inlinecode"><span class="id" title="var">bool</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Empty_set"><span class="id" title="inductive">Empty_set</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;Empty_set&nbsp;:&nbsp;Set&nbsp;:=&nbsp;.*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;unit&nbsp;:&nbsp;Set&nbsp;:=&nbsp;&nbsp;tt&nbsp;:&nbsp;unit&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;bool&nbsp;:&nbsp;Set&nbsp;:=&nbsp;&nbsp;true&nbsp;:&nbsp;bool&nbsp;|&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The similarities are striking — these two series of types from a
    high-level point of view look (nearly) the same. The dissimilarities
    are more subtle.

<div class="paragraph"> </div>

    Besides names the only difference lies in the sorts — <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> and
    <span class="inlinecode"><span class="id" title="keyword">Set</span></span> — but it's a colossal one.

<div class="paragraph"> </div>

    Note: if a proof isn't there, it's an exercise. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="bool_inhabited"><span class="id" title="lemma">bool_inhabited</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="VeryTrue_inhabited"><span class="id" title="lemma">VeryTrue_inhabited</span></a> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a>.<br/>

<br/>
</div>

<div class="doc">
First off, both <span class="inlinecode"><span class="id" title="var">bool</span></span> and <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span>, which correspond in the series,
    are inhabited. This means that <span class="inlinecode"><span class="id" title="var">bool</span></span> has an element and <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> is
    indeed true. No surprise here. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="unit_contractible"><span class="id" title="lemma">unit_contractible</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>, <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="bool_not_contractible"><span class="id" title="lemma">bool_not_contractible</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
</div>

<div class="doc">
Secondly, <span class="inlinecode"><span class="id" title="var">unit</span></span> is contractible and <span class="inlinecode"><span class="id" title="var">bool</span></span> is not. This means roughly
    that <span class="inlinecode"><span class="id" title="var">unit</span></span> has one element and <span class="inlinecode"><span class="id" title="var">bool</span></span> has more than one (in fact it
    has two). We could believe that this is also the case for <span class="inlinecode"><span class="id" title="var">True</span></span> and
    <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span>, but it's not that simple. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="True_contractible"><span class="id" title="lemma">True_contractible</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>, <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="VeryTrue_not_contractible"><span class="id" title="lemma">VeryTrue_not_contractible</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <a class="idref" href="Seminar.html#proof"><span class="id" title="constructor">proof</span></a>, <a class="idref" href="Seminar.html#other_proof"><span class="id" title="constructor">other_proof</span></a>. <span class="id" title="tactic">inversion</span> 1.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Even though <span class="inlinecode"><span class="id" title="var">True</span></span> has the same property that holds for <span class="inlinecode"><span class="id" title="var">unit</span></span>,
    it looks like the trickery of <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> is not enough to prove
    that <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> is contractible. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.ProofIrrelevance.html#"><span class="id" title="library">ProofIrrelevance</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="VeryTrue_contractible"><span class="id" title="lemma">VeryTrue_contractible</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a>, <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
</div>

<div class="doc">
No, it's not about lack of trickery — it may simply be not true. In
    fact, it's axiom-dependent. In vanilla Coq we can't do much, but if
    we assume the Axiom of Proof Irrelevance, we can prove that both
    constructors of <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> construct the very same proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.ProofIrrelevance.html#proof_irrelevance"><span class="id" title="axiom">proof_irrelevance</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;proof_irrelevance&nbsp;:&nbsp;forall&nbsp;(P&nbsp;:&nbsp;Prop)&nbsp;(p1&nbsp;p2&nbsp;:&nbsp;P),&nbsp;p1&nbsp;=&nbsp;p2&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The Axiom of Proof Irrelevance states that all proofs of any proposition
    are equal. This is exactly the statement we wanted to prove. You may
    wonder if we're allowed to assume such an axiom, but it was proved
    that this axiom is consistent with the Calculus of Inductive Constructions
    (so, it won't introduce any contradictions to Coq).

<div class="paragraph"> </div>

    But before we go on we have to clarify what was meant by "proof" in the
    above statement in order to avoid falling into an equivocation lurking
    in the darkness out there.

<div class="paragraph"> </div>

    In the context of Coq the word "proof" can mean two things:
<ul class="doclist">
<li> "proofterm". Proofterm is just a term. To prove <span class="inlinecode"><span class="id" title="var">P</span></span> we have to
      construct <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> and this <span class="inlinecode"><span class="id" title="var">p</span></span> is the proofterm that proves <span class="inlinecode"><span class="id" title="var">P</span></span>.

</li>
<li> "proofscript". A proofscript is the text that appears between the
      theorem statement and the keyword <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 What I meant by "all proofs of any proposition are equal" could be
    better rephrased as "all proofterms of any proposition are equal". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.FinFun.html#"><span class="id" title="library">Logic.FinFun</span></a>.<br/>

<br/>
</div>

<div class="doc">
Note: module FinFun contains definitions of injections, surjections and
    bijections.

<div class="paragraph"> </div>

    These are not the only differences. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="no_bij_unit_bool"><span class="id" title="lemma">no_bij_unit_bool</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">f</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.FinFun.html#Bijective"><span class="id" title="definition">Bijective</span></a> <a class="idref" href="Seminar.html#f"><span class="id" title="variable">f</span></a>.<br/>

<br/>
</div>

<div class="doc">
Even though there are functions going from <span class="inlinecode"><span class="id" title="var">unit</span></span> to <span class="inlinecode"><span class="id" title="var">bool</span></span> and the
    other way around too, they are in no sense equivalences. Particularly,
    <span class="inlinecode"><span class="id" title="var">unit</span></span> is not in bijction with <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="unit_not_bool"><span class="id" title="lemma">unit_not_bool</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>

<br/>
</div>

<div class="doc">
Since Leibniz it is known that two equal things must also have the
    same properties. Using this fact we can prove that <span class="inlinecode"><span class="id" title="var">unit</span></span> is not
    equal to <span class="inlinecode"><span class="id" title="var">bool</span></span> (since they differ in the property of being in
    bijction with <span class="inlinecode"><span class="id" title="var">uni</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="VeryTrue_True"><span class="id" title="lemma">VeryTrue_True</span></a> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> and <span class="inlinecode"><span class="id" title="var">True</span></span> are, however, logically equivalent. This really
    shouldn't surprise us, because both can be proved without any assumptions.
    But this is not all that's true about their relationship. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="bij_VeryTrue_True"><span class="id" title="lemma">bij_VeryTrue_True</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">f</span> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.FinFun.html#Bijective"><span class="id" title="definition">Bijective</span></a> <a class="idref" href="Seminar.html#f"><span class="id" title="variable">f</span></a>.<br/>

<br/>
</div>

<div class="doc">
From the Axiom of Proof Irrelevance it follows that <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> and
    <span class="inlinecode"><span class="id" title="var">True</span></span> are in bijection with each other. This too isn't that much
    of a surprise because we have shown before that they both are
    contractible, i.e. both have only a single element. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="Classical"><span class="id" title="module">Classical</span></a>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.ClassicalFacts.html#"><span class="id" title="library">ClassicalFacts</span></a>.<br/>

<br/>
</div>

<div class="doc">
There's another axiom we can assume: the Axiom of Propositional
    Extensionality, which lives in the module <span class="inlinecode"><span class="id" title="var">ClassicalFacts</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.ClassicalFacts.html#prop_extensionality"><span class="id" title="definition">prop_extensionality</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;prop_extensionality&nbsp;=&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;&lt;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;=&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
This axiom states that if two propositions are logically equivalent,
    then they are equal. It also has been proved that adding it to Coq
    is consistent (even if we already have proof irrelevance). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span> <a name="Classical.prop_ext"><span class="id" title="axiom">prop_ext</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.ClassicalFacts.html#prop_extensionality"><span class="id" title="definition">prop_extensionality</span></a>.<br/>

<br/>
</div>

<div class="doc">
Note: assuming this axiom is technically realized differently than
    assuming <span class="inlinecode"><span class="id" title="var">proof_irrelevance</span></span>. To assume <span class="inlinecode"><span class="id" title="var">proof_irrelevance</span></span>, we only
    had to import the relevant module and the axiom was sitting there
    waiting for us. However, to assume <span class="inlinecode"><span class="id" title="var">prop_extensionality</span></span> we have to
    write it out explicitly after importing the module. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Classical.VeryTrue_is_True"><span class="id" title="lemma">VeryTrue_is_True</span></a> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
</div>

<div class="doc">
Using this axiom, we can prove that <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> and <span class="inlinecode"><span class="id" title="var">True</span></span> are not only
    logically equivalent and in bijection with each other, but actually
    equal. Propositions are very different from ordinary types. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Classical"><span class="id" title="module">Classical</span></a>.<br/>

<br/>
</div>

<div class="doc">
Let's try to sum up the above lesson using slogans and metaphors.
    An often repeated phrase is "propositions as types". By this it is
    most often meant that proposition can be represented by types and
    logic can be reduced to operations on types.

<div class="paragraph"> </div>

    This is mostly accurate, but as we have seen, proposition and types
    are not exactly the same thing in Coq. We can imagine that a type is
    just a bag of dots. The bag is the type proper and the dots are just
    repeated applications of the type's constructors.

<div class="paragraph"> </div>

    We can then in search of dots put our hand into the bag and if there
    are some, we can pull them out. If there are many of them, we can
    distinguish them by looking at them or doing more complicated operations.

<div class="paragraph"> </div>

    Propositions can be thought of as bags of dots in the same way, but if
    we put our hand into the bag, only two things can possibly happen:
<ul class="doclist">
<li> We pull out a big blob of glue with some dots glued to it. We can't
      unglue them, but we know there are some dots

</li>
<li> There's nothing 
</li>
</ul>

<div class="paragraph"> </div>

 The moral of this story is as follows: in case of types (those terms
    whose type is <span class="inlinecode"><span class="id" title="keyword">Set</span></span> or <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, to be more precise) we are interested
    in what the terms look like, how many are there and so on. In the
    case of propositions (terms whose type is <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>) we can possibly
    only be interested in whether there are any terms (proofs) or not. 
<div class="paragraph"> </div>

<a name="lab149"></a><h1 class="section">On the number of constructors</h1>

<div class="paragraph"> </div>

 Let's consider how the truth of a proposition depends on the number
    of its constructors. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="TheTruest"><span class="id" title="inductive">TheTruest</span></a> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="ShortProof"><span class="id" title="constructor">ShortProof</span></a> : <a class="idref" href="Seminar.html#TheTruest"><span class="id" title="inductive">TheTruest</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="LongProof"><span class="id" title="constructor">LongProof</span></a> : <a class="idref" href="Seminar.html#TheTruest"><span class="id" title="inductive">TheTruest</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#TheTruest"><span class="id" title="inductive">TheTruest</span></a>.<br/>

<br/>
</div>

<div class="doc">
This proposition dangerously resembles the type <span class="inlinecode"><span class="id" title="var">nat</span></span>. It appears to
    have an infinite amount of proofs constructred by two constructors,
    one of which corresponds to <span class="inlinecode">0</span> and the other to <span class="inlinecode"><span class="id" title="var">S</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="TheTruest_True"><span class="id" title="lemma">TheTruest_True</span></a> : <a class="idref" href="Seminar.html#TheTruest"><span class="id" title="inductive">TheTruest</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="TheTruest_contractible"><span class="id" title="lemma">TheTruest_contractible</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Seminar.html#TheTruest"><span class="id" title="inductive">TheTruest</span></a>, <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
</div>

<div class="doc">
This is not really the case. Since all the proofs are equal to each
    other, there in fact is only a single proof. So even though this
    proposition has two constructors one of which is recursive, it
    resembles <span class="inlinecode"><span class="id" title="var">unit</span></span> more than <span class="inlinecode"><span class="id" title="var">nat</span></span>, to which it would be equivalent
    if it lived in <span class="inlinecode"><span class="id" title="keyword">Set</span></span> or <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.

<div class="paragraph"> </div>

    This leads us to ask a somewhat contrived question: for propositions,
    are all constructors besides one useless? Or rather, does a single one
    suffice to make a proposition true? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="BePatient"><span class="id" title="inductive">BePatient</span></a> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="the_longest_proof"><span class="id" title="constructor">the_longest_proof</span></a> : <a class="idref" href="Seminar.html#BePatient"><span class="id" title="inductive">BePatient</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#BePatient"><span class="id" title="inductive">BePatient</span></a>.<br/>

<br/>
</div>

<div class="doc">
The above proposition has a single constructor, so we could be led
    to believe it's true. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="BePatient_false"><span class="id" title="lemma">BePatient_false</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="Seminar.html#BePatient"><span class="id" title="inductive">BePatient</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="BePatient_False"><span class="id" title="lemma">BePatient_False</span></a> : <a class="idref" href="Seminar.html#BePatient"><span class="id" title="inductive">BePatient</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">
However it happens that this proposition is not at all true. How is
    this possible? It has a constructor, so it must be true... not quite.
    Recall that we can build terms of inductive types by applying their
    constructors only a <i>finite</i> number of times.

<div class="paragraph"> </div>

    The "word" finite is crucial here. If we try to apply the constructor
    <span class="inlinecode"><span class="id" title="var">the_longest_proof</span></span> repeatedly, our only hope at finishing is if we
    do it <i>ad infinitum</i>. This is exactly the thing that is forbidden by
    the definition of inductive types.

<div class="paragraph"> </div>

    So, a proposition with one constructor can be false. We could add
    more constructors like <span class="inlinecode"><span class="id" title="var">the_longest_proof</span></span> and they wouldn't help
    if all of them were recursive. Thus we have proven (but only at the
    metatheoretical level) that a false proposition can have any number
    of constructors: 0 (<span class="inlinecode"><span class="id" title="var">False</span></span>), 1 (<span class="inlinecode"><span class="id" title="var">BePatient</span></span>), 2 or more (<span class="inlinecode"><span class="id" title="var">BePatient</span></span>
    on steroids with more constructors).

<div class="paragraph"> </div>

    But what about nonrecursive constructors? Can a propositiona with a
    nonrecursive constructor be false? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="LatentFalsity"><span class="id" title="inductive">LatentFalsity</span></a> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="I_am_true"><span class="id" title="constructor">I_am_true</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#LatentFalsity"><span class="id" title="inductive">LatentFalsity</span></a>.<br/>

<br/>
</div>

<div class="doc">
Well, this one has one nonrecursive constructor, so again we could be
    led to believe it's true... but beware. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="LatentFalsity_false"><span class="id" title="lemma">LatentFalsity_false</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="Seminar.html#LatentFalsity"><span class="id" title="inductive">LatentFalsity</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="LatentFalsity_False"><span class="id" title="lemma">LatentFalsity_False</span></a> : <a class="idref" href="Seminar.html#LatentFalsity"><span class="id" title="inductive">LatentFalsity</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">
This proposition is false because its only constructor takes a proof
    of <span class="inlinecode"><span class="id" title="var">False</span></span> as an argument. Since there isn't one, this constructor can
    never be used to build a proof of <span class="inlinecode"><span class="id" title="var">LatentFalsity</span></span>.

<div class="paragraph"> </div>

    Our voyage into the land of constructors looks rather grimm. We have
    met false propositions with any number of constructors, recursive or
    not. We have also seen that true propositions can have one or more
    constructors.

<div class="paragraph"> </div>

    The only certainty we discovered is that a proposition without any
    constructors must necessarily be false. As soon as it has at least
    one, it can be provable or not depending on how they look like. 
<div class="paragraph"> </div>

<a name="lab150"></a><h4 class="section">Exercise</h4>

<div class="paragraph"> </div>

 Find a simple heuristic for deciding (at the metatheoretical level)
    whether an inductive proposition can be proven or not. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab151"></a><h4 class="section">Exercise</h4>

<div class="paragraph"> </div>

 Prove that <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Does <span class="inlinecode"><span class="id" title="var">TheTruest</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> hold? If yes,
    under what assumptions? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab152"></a><h1 class="section">On induction principles</h1>

<div class="paragraph"> </div>

 We're not done yet — the differences that were described above have
    some more consequences. In this subchapter we will be interested in
    induction principles, which correspond to natural deduction's
    elimination rules. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Empty_set_ind"><span class="id" title="definition">Empty_set_ind</span></a>.<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;Empty_set_ind<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;(P&nbsp;:&nbsp;Empty_set&nbsp;-&gt;&nbsp;Prop)&nbsp;(e&nbsp;:&nbsp;Empty_set),&nbsp;P&nbsp;e&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit_ind"><span class="id" title="definition">unit_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;unit_ind<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;Prop,&nbsp;P&nbsp;tt&nbsp;-&gt;&nbsp;forall&nbsp;u&nbsp;:&nbsp;unit,&nbsp;P&nbsp;u&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool_ind"><span class="id" title="definition">bool_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;bool_ind<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Prop,&nbsp;P&nbsp;true&nbsp;-&gt;&nbsp;P&nbsp;false&nbsp;-&gt;&nbsp;forall&nbsp;b&nbsp;:&nbsp;bool,&nbsp;P&nbsp;b&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
An induction principle for a type <span class="inlinecode"><span class="id" title="var">T</span></span> is a tool we can use to define
    dependent functions whose domain is <span class="inlinecode"><span class="id" title="var">T</span></span>. Even though Coq automagically
    generates for us one principle for each <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> definition we make,
    they are neither built-in nor unique.

<div class="paragraph"> </div>

    Quite the opposite is true. Induction principles can be constructed by
    hand using only pattern matching and recursion. Usually there can be
    many different principles for each type: for dependent and non-dependent
    functions, for true induction or just for case analysis, they can even
    differ by their order of taking arguments.

<div class="paragraph"> </div>

    We will call the principles Coq generates us "standard" and the ones we
    write ourselves "non-standard" or "custom". In this subchapter we will
    first see how the standard principles are generated for ordinary types,
    then we will see some non-standard principles for types and finally we
    will learn the principles for propositions differ from these for types. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool_rect"><span class="id" title="definition">bool_rect</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;bool_rect&nbsp;=&nbsp;<br/>
fun&nbsp;(P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Type)&nbsp;(f&nbsp;:&nbsp;P&nbsp;true)&nbsp;(f0&nbsp;:&nbsp;P&nbsp;false)&nbsp;(b&nbsp;:&nbsp;bool)&nbsp;=&gt;<br/>
if&nbsp;b&nbsp;as&nbsp;b0&nbsp;return&nbsp;(P&nbsp;b0)&nbsp;then&nbsp;f&nbsp;else&nbsp;f0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Type,&nbsp;P&nbsp;true&nbsp;-&gt;&nbsp;P&nbsp;false&nbsp;-&gt;&nbsp;forall&nbsp;b&nbsp;:&nbsp;bool,&nbsp;P&nbsp;b&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Note: Coq actually generates for us three principles for each definition
    we make. For type <span class="inlinecode"><span class="id" title="var">T</span></span> these are called <span class="inlinecode"><span class="id" title="var">T_rect</span></span>, <span class="inlinecode"><span class="id" title="var">T_rec</span></span> and <span class="inlinecode"><span class="id" title="var">T_ind</span></span>.
    They differ only in the sort of the type that depends on <span class="inlinecode"><span class="id" title="var">T</span></span>: for <span class="inlinecode"><span class="id" title="var">T_rect</span></span>
    this is <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, for <span class="inlinecode"><span class="id" title="var">T_rec</span></span> it's Set and for <span class="inlinecode"><span class="id" title="var">T_ind</span></span> it's <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. The
    two latter are implemented by simply calling <span class="inlinecode"><span class="id" title="var">T_rect</span></span>. This somehow
    justifies that I told you before Coq only generates one principle for
    each type.

<div class="paragraph"> </div>

    Let's look at the type first: <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>
    <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>. First comes <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, which is the
    family of types depending on <span class="inlinecode"><span class="id" title="var">bool</span></span> that will be our codomain. Then
    we have <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">f0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> — these correspond exactly to
    the constructors of <span class="inlinecode"><span class="id" title="var">bool</span></span>. At the end there's <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>
    which is the type of the dependent function we can define using this
    principle.

<div class="paragraph"> </div>

    This principle effectively states that in order to define a function
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> we have to provide the values <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> and
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>. This isn't very surprising: when we define functions from
    <span class="inlinecode"><span class="id" title="var">bool</span></span>, we do this by pattern matching on the argument and doing two
    separate things for <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">false</span></span> and we prove properties of
    <span class="inlinecode"><span class="id" title="var">bool</span></span> using case analysis.

<div class="paragraph"> </div>

    When we look at the definition we can see an <span class="inlinecode"><span class="id" title="keyword">if</span></span> here. This is just a
    syntactic sugar for <span class="inlinecode"><span class="id" title="keyword">match</span></span>, which proves that the principle is derived
    using pattern matching.

<div class="paragraph"> </div>

    So, what's the purpose of induction principles if in theory we can do
    just as well without them, using only <span class="inlinecode"><span class="id" title="keyword">fix</span></span> and <span class="inlinecode"><span class="id" title="keyword">match</span></span>? The answer is
    that they are a matter of abstraction and thus convenience. Reasoning
    by induction is a very common thing and thus packaging it into these
    induction principles helps reusability. It is also easier to manipulate
    them using tactics than to directly use <span class="inlinecode"><span class="id" title="keyword">fix</span></span> or <span class="inlinecode"><span class="id" title="keyword">match</span></span> from <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span>.
    This supports automation and thus gives us convenience.

<div class="paragraph"> </div>

    Let's now see how to implement a non-standard induction principle. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="bool_ind'"><span class="id" title="definition">bool_ind'</span></a><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">f</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>) (<span class="id" title="var">t</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> =&gt; <a class="idref" href="Seminar.html#t"><span class="id" title="variable">t</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> =&gt; <a class="idref" href="Seminar.html#f"><span class="id" title="variable">f</span></a><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Aaaaand here it is. Not very surprising. The only thing that makes it
    different from the rule <span class="inlinecode"><span class="id" title="var">bool_ind</span></span> is the order of arguments: it takes
    that of type <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> first, whereas <span class="inlinecode"><span class="id" title="var">bool_ind</span></span>'s first argument has
    type <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="bool_ind''"><span class="id" title="definition">bool_ind''</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>), <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We can also define the principle non-manually, by simply proving it as
    a theorem. This doesn't make much difference now, but for more complex
    principles it is often easier to establish them that way.

<div class="paragraph"> </div>

    But how to use such a principle? Standard induction on the term <span class="inlinecode"><span class="id" title="var">t</span></span> is
    usually performed by using the tactic <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>. Our non-standard
    induction can be likewise performed with the tactic <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode"><span class="id" title="keyword">using</span></span>
    <span class="inlinecode"><span class="id" title="var">our_principle</span></span>.

<div class="paragraph"> </div>

    Let's see both principles in action.   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="negb_involutive'"><span class="id" title="lemma">negb_involutive'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>. <span class="id" title="var">all</span>: <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">b</span> <span class="id" title="keyword">using</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool_ind"><span class="id" title="definition">bool_ind</span></a>; <span class="id" title="var">cbn</span>. <span class="id" title="var">all</span>: <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">b</span> <span class="id" title="keyword">using</span> <a class="idref" href="Seminar.html#bool_ind'"><span class="id" title="definition">bool_ind'</span></a>; <span class="id" title="var">cbn</span>. <span class="id" title="var">all</span>: <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Here we see that the tactic <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> is in fact equivalent to
    <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">bool_ind</span></span>, in which the standard induction principle
    is named explicitly. In these two equivalent cases, our first subgoal
    is <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> and the second is <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span>. On the contrary,
    when we use our custom principle, our first goal is <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span>
    and the second is <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>.

<div class="paragraph"> </div>

    So, our nonstandard principles are no different from the standard ones,
    we just have to create them manually and type a bit more in order to
    use them.

<div class="paragraph"> </div>

    But how does the tactic <span class="inlinecode"><span class="id" title="tactic">induction</span></span> work under the hood? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="negb_involutive''"><span class="id" title="lemma">negb_involutive''</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool_ind"><span class="id" title="definition">bool_ind</span></a>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Seminar.html#bool_ind'"><span class="id" title="definition">bool_ind'</span></a>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">induction</span></span> isn't mysterious at all. It just applies the induction
    principle we want to use or the default one if we don't have an <span class="inlinecode"><span class="id" title="keyword">using</span></span>
    clause.

<div class="paragraph"> </div>

    To finish our considerations, let's have a look at a full-fledged
    induction principle (one that really has induction in it). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat_ind"><span class="id" title="definition">nat_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;-&gt;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
It's basically the same story as before, but it has recursion. First
    we see the dependent codomain <span class="inlinecode"><span class="id" title="var">P</span></span> and two arguments that correspond
    to <span class="inlinecode"><span class="id" title="var">nat</span></span>'s constructors.

<div class="paragraph"> </div>

    The second argument is of particular interest to us: if it were
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>, we would only have a case-analysis
    principle. However, it also has the premise <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, which makes it
    recursive.

<div class="paragraph"> </div>

    We can sum up this subchapter with the following intuition about
    induction. Inductive types are collections of trees made by
    applying their constructors a finite number of times. In order for
    such constructions to be finite there must be some base cases,
    like <span class="inlinecode">0</span> for <span class="inlinecode"><span class="id" title="var">nat</span></span> and <span class="inlinecode"><span class="id" title="var">nil</span></span> for <span class="inlinecode"><span class="id" title="var">list</span></span>.

<div class="paragraph"> </div>

    We are interested in proving that all terms of a type <span class="inlinecode"><span class="id" title="var">T</span></span> have some
    property <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. In the standard case we can do this by
    proving that the bases cases have the property and that this type's
    constructors preserve this property.

<div class="paragraph"> </div>

    In the less standard case, we can find other ways of generating all
    terms of <span class="inlinecode"><span class="id" title="var">T</span></span>, like <span class="inlinecode">0</span>, <span class="inlinecode">1</span> and <span class="inlinecode">+</span> <span class="inlinecode">2</span> for <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
<div class="paragraph"> </div>

<a name="lab153"></a><h1 class="section">On induction principles v2 (TODO)</h1>

<div class="paragraph"> </div>

 Let's for a moment put aside the differences between propositions and
    types and have some philosophical thinking about induction. Let's say
    we have a collection of things <span class="inlinecode"><span class="id" title="var">T</span></span> and we want to prove that all
    elements of <span class="inlinecode"><span class="id" title="var">T</span></span> have some property <span class="inlinecode"><span class="id" title="var">P</span></span>. How could we accomplish this
    task? It's a general, philosophical question, not one specific to
    Coq.

<div class="paragraph"> </div>

    Say we have a collection which consists of an old dishwasher, the
    number π, some weird symbols written on a clay tablet and your
    granny's graduation hat. How could we prove that each of these has
    some property <span class="inlinecode"><span class="id" title="var">P</span></span>, like "x was created by aliens"?

<div class="paragraph"> </div>

    Well, you probably thought about checking each case separately. This
    is a perfectly sane idea, but it's based on an implicit assumption
    which we have to uncover. This assumption says that our collection is
    finite. But what if the collection is infinite?

<div class="paragraph"> </div>

    This is really a question concerning the "inner nature" of the objects
    we consider. If we have an infinite amount of objects whose inner
    natures are different from each other and we want to be done with our
    proving in finite time and using finite resources, then we're doomed.

<div class="paragraph"> </div>

    Having said this, what if the collections of interest are Coq types?
    Is the situation here hopeless too? It turns out that the answer is
    no. Coq types can be described as collection of objects that share an
    inner nature. 
<div class="paragraph"> </div>

<a name="lab154"></a><h4 class="section">Exercise</h4>

<div class="paragraph"> </div>

 In case of <span class="inlinecode"><span class="id" title="var">nat</span></span>, we can customize our induction principle more than
    by just changing the order of the arguments. Prove this principle
    for doing "induction by 2's". Then implement it manually using <span class="inlinecode"><span class="id" title="keyword">fix</span></span>.
    Which one was easier? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="nat_ind_2"><span class="id" title="definition">nat_ind_2</span></a><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">H0</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> 0) (<span class="id" title="var">H1</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> 1)<br/>
&nbsp;&nbsp;(<span class="id" title="var">HSS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>)))<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>

<br/>
</div>
