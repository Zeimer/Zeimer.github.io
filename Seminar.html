<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-88023543-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<h1 class="libtitle">Seminar: Induction</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 This chapter is written in English because its main purpose is to serve
    as notes for my seminar talk whose topic was "Inductive predicates". It
    is a bit broader than that and covers all forms of structural induction,
    including functional induction, and even more. It does not touch the
    topic of well-founded induction.

<div class="paragraph"> </div>

    The grading policy is at the end. 
<div class="paragraph"> </div>

<a name="lab228"></a><h1 class="section">Inductive propositions and types with a grain of axioms</h1>

<div class="paragraph"> </div>

 Let's start with inductive propositions: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;False&nbsp;:&nbsp;Prop&nbsp;:=&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;True&nbsp;:&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;I&nbsp;:&nbsp;True&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">False</span></span> and <span class="inlinecode"><span class="id" title="var">True</span></span> have very simple definitions. <span class="inlinecode"><span class="id" title="var">False</span></span> doesn't have
    any constructors and <span class="inlinecode"><span class="id" title="var">True</span></span> does have one, called <span class="inlinecode"><span class="id" title="var">I</span></span>. This name is
    arbitrary — it has to be there, because constructors can't be nameless,
    but doesn't really matter, because we're only interested in its existence,
    not name.

<div class="paragraph"> </div>

    The definitions are not that interesting if you have seen them already,
    so let's have a look at something weirder: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="VeryTrue"><span class="id" title="inductive">VeryTrue</span></a> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="proof"><span class="id" title="constructor">proof</span></a> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="other_proof"><span class="id" title="constructor">other_proof</span></a> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a>.<br/>

<br/>
</div>

<div class="doc">
How is this one different from <span class="inlinecode"><span class="id" title="var">True</span></span>? Well, <span class="inlinecode"><span class="id" title="var">False</span></span>, <span class="inlinecode"><span class="id" title="var">True</span></span> and
    <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> can be likened to <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>, <span class="inlinecode"><span class="id" title="var">unit</span></span> and <span class="inlinecode"><span class="id" title="var">bool</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Empty_set"><span class="id" title="inductive">Empty_set</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;Empty_set&nbsp;:&nbsp;Set&nbsp;:=&nbsp;.*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;unit&nbsp;:&nbsp;Set&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;tt&nbsp;:&nbsp;unit&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;bool&nbsp;:&nbsp;Set&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true&nbsp;:&nbsp;bool<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The similarities are striking — these two series of types from a
    high-level point of view look (nearly) the same. The dissimilarities
    are more subtle.

<div class="paragraph"> </div>

    Besides names the only difference lies in the sorts — <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> and
    <span class="inlinecode"><span class="id" title="keyword">Set</span></span> — but it's a colossal one.

<div class="paragraph"> </div>

    Note: if a proof isn't there, it's an exercise. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="bool_inhabited"><span class="id" title="lemma">bool_inhabited</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="VeryTrue_inhabited"><span class="id" title="lemma">VeryTrue_inhabited</span></a> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a>.<br/>

<br/>
</div>

<div class="doc">
First off, both <span class="inlinecode"><span class="id" title="var">bool</span></span> and <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span>, which correspond in the series,
    are inhabited. This means that <span class="inlinecode"><span class="id" title="var">bool</span></span> has an element and <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> is
    indeed true. No surprise here. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="unit_contractible"><span class="id" title="lemma">unit_contractible</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>, <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="bool_not_contractible"><span class="id" title="lemma">bool_not_contractible</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
</div>

<div class="doc">
Secondly, <span class="inlinecode"><span class="id" title="var">unit</span></span> is contractible and <span class="inlinecode"><span class="id" title="var">bool</span></span> is not. This means roughly
    that <span class="inlinecode"><span class="id" title="var">unit</span></span> has one element and <span class="inlinecode"><span class="id" title="var">bool</span></span> has more than one (in fact it
    has two). We could believe that this is also the case for <span class="inlinecode"><span class="id" title="var">True</span></span> and
    <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span>, but it's not that simple. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="True_contractible"><span class="id" title="lemma">True_contractible</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>, <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="VeryTrue_not_contractible"><span class="id" title="lemma">VeryTrue_not_contractible</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <a class="idref" href="Seminar.html#proof"><span class="id" title="constructor">proof</span></a>, <a class="idref" href="Seminar.html#other_proof"><span class="id" title="constructor">other_proof</span></a>. <span class="id" title="tactic">inversion</span> 1.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Even though <span class="inlinecode"><span class="id" title="var">True</span></span> has the same property that holds for <span class="inlinecode"><span class="id" title="var">unit</span></span>,
    it looks like the trickery of <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> is not enough to prove
    that <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> is contractible. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.ProofIrrelevance.html#"><span class="id" title="library">ProofIrrelevance</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="VeryTrue_contractible"><span class="id" title="lemma">VeryTrue_contractible</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a>, <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
</div>

<div class="doc">
No, it's not about lack of trickery — it may simply be not true. In
    fact, it's axiom-dependent. In vanilla Coq we can't do much, but if
    we assume the Axiom of Proof Irrelevance, we can prove that both
    constructors of <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> construct the very same proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.ProofIrrelevance.html#proof_irrelevance"><span class="id" title="axiom">proof_irrelevance</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;proof_irrelevance&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(P&nbsp;:&nbsp;Prop)&nbsp;(p1&nbsp;p2&nbsp;:&nbsp;P),&nbsp;p1&nbsp;=&nbsp;p2&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The Axiom of Proof Irrelevance states that all proofs of any proposition
    are equal. This is exactly the statement we wanted to prove. You may
    wonder if we're allowed to assume such an axiom, but it was proved
    that this axiom is consistent with the Calculus of Inductive Constructions
    (so, it won't introduce any contradictions to Coq).

<div class="paragraph"> </div>

    But before we go on we have to clarify what was meant by "proof" in the
    above statement in order to avoid falling into an equivocation lurking
    in the darkness out there.

<div class="paragraph"> </div>

    In the context of Coq the word "proof" can mean two things:
<ul class="doclist">
<li> "proofterm". Proofterm is just a term. To prove <span class="inlinecode"><span class="id" title="var">P</span></span> we have to
      construct <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> and this <span class="inlinecode"><span class="id" title="var">p</span></span> is the proofterm that proves <span class="inlinecode"><span class="id" title="var">P</span></span>.

</li>
<li> "proofscript". A proofscript is the text that appears between the
      theorem statement and the keyword <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 What I meant by "all proofs of any proposition are equal" could be
    better rephrased as "all proofterms of any proposition are equal". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.FinFun.html#"><span class="id" title="library">Logic.FinFun</span></a>.<br/>

<br/>
</div>

<div class="doc">
Note: module FinFun contains definitions of injections, surjections and
    bijections.

<div class="paragraph"> </div>

    These are not the only differences. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="no_bij_unit_bool"><span class="id" title="lemma">no_bij_unit_bool</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">f</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.FinFun.html#Bijective"><span class="id" title="definition">Bijective</span></a> <a class="idref" href="Seminar.html#f"><span class="id" title="variable">f</span></a>.<br/>

<br/>
</div>

<div class="doc">
Even though there are functions going from <span class="inlinecode"><span class="id" title="var">unit</span></span> to <span class="inlinecode"><span class="id" title="var">bool</span></span> and the
    other way around too, they are in no sense equivalences. Particularly,
    <span class="inlinecode"><span class="id" title="var">unit</span></span> is not in bijction with <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="unit_not_bool"><span class="id" title="lemma">unit_not_bool</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>

<br/>
</div>

<div class="doc">
Since Leibniz it is known that two equal things must also have the
    same properties. Using this fact we can prove that <span class="inlinecode"><span class="id" title="var">unit</span></span> is not
    equal to <span class="inlinecode"><span class="id" title="var">bool</span></span> (since they differ in the property of being in
    bijection with <span class="inlinecode"><span class="id" title="var">unit</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="VeryTrue_True"><span class="id" title="lemma">VeryTrue_True</span></a> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> and <span class="inlinecode"><span class="id" title="var">True</span></span> are, however, logically equivalent. This really
    shouldn't surprise us, because both can be proved without any assumptions.
    But this is not all that's true about their relationship. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="bij_VeryTrue_True"><span class="id" title="lemma">bij_VeryTrue_True</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">f</span> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.FinFun.html#Bijective"><span class="id" title="definition">Bijective</span></a> <a class="idref" href="Seminar.html#f"><span class="id" title="variable">f</span></a>.<br/>

<br/>
</div>

<div class="doc">
From the Axiom of Proof Irrelevance it follows that <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> and
    <span class="inlinecode"><span class="id" title="var">True</span></span> are in bijection with each other. This too isn't that much
    of a surprise because we have shown before that they both are
    contractible, i.e. both have only a single element. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="Classical"><span class="id" title="module">Classical</span></a>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.ClassicalFacts.html#"><span class="id" title="library">ClassicalFacts</span></a>.<br/>

<br/>
</div>

<div class="doc">
There's another axiom we can assume: the Axiom of Propositional
    Extensionality, which lives in the module <span class="inlinecode"><span class="id" title="var">ClassicalFacts</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.ClassicalFacts.html#prop_extensionality"><span class="id" title="definition">prop_extensionality</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;prop_extensionality&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Prop,&nbsp;A&nbsp;&lt;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;=&nbsp;B&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
This axiom states that if two propositions are logically equivalent,
    then they are equal. It also has been proved that adding it to Coq
    is consistent (even if we already have proof irrelevance). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span> <a name="Classical.prop_ext"><span class="id" title="axiom">prop_ext</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.ClassicalFacts.html#prop_extensionality"><span class="id" title="definition">prop_extensionality</span></a>.<br/>

<br/>
</div>

<div class="doc">
Note: assuming this axiom is technically realized differently than
    assuming <span class="inlinecode"><span class="id" title="var">proof_irrelevance</span></span>. To assume <span class="inlinecode"><span class="id" title="var">proof_irrelevance</span></span>, we only
    had to import the relevant module and the axiom was sitting there
    waiting for us. However, to assume <span class="inlinecode"><span class="id" title="var">prop_extensionality</span></span> we have to
    write it out explicitly after importing the module. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Classical.VeryTrue_is_True"><span class="id" title="lemma">VeryTrue_is_True</span></a> : <a class="idref" href="Seminar.html#VeryTrue"><span class="id" title="inductive">VeryTrue</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
</div>

<div class="doc">
Using this axiom, we can prove that <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> and <span class="inlinecode"><span class="id" title="var">True</span></span> are not only
    logically equivalent and in bijection with each other, but actually
    equal. Propositions are very different from ordinary types. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Classical"><span class="id" title="module">Classical</span></a>.<br/>

<br/>
</div>

<div class="doc">
Let's try to sum up the above lesson using slogans and metaphors.
    An often repeated phrase is "propositions as types". By this it is
    most often meant that proposition can be represented by types and
    logic can be reduced to operations on types.

<div class="paragraph"> </div>

    This is mostly accurate, but as we have seen, proposition and types
    are not exactly the same thing in Coq. We can imagine that a type is
    just a bag of dots. The bag is the type proper and the dots are just
    repeated applications of the type's constructors.

<div class="paragraph"> </div>

    We can then in search of dots put our hand into the bag and if there
    are some, we can pull them out. If there are many of them, we can
    distinguish them by looking at them or doing more complicated operations.

<div class="paragraph"> </div>

    Propositions can be thought of as bags of dots in the same way, but if
    we put our hand into the bag, only two things can possibly happen:
<ul class="doclist">
<li> We pull out a big blob of glue with some dots glued to it. We can't
      unglue them, but we know there are some dots

</li>
<li> There's nothing 
</li>
</ul>

<div class="paragraph"> </div>

 The moral of this story is as follows: in case of types (those terms
    whose type is <span class="inlinecode"><span class="id" title="keyword">Set</span></span> or <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, to be more precise) we are interested
    in what the terms look like, how many are there and so on. In the
    case of propositions (terms whose type is <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>) we can possibly
    only be interested in whether there are any terms (proofs) or not. 
<div class="paragraph"> </div>

<a name="lab229"></a><h4 class="section">Exercise (easy)</h4>

<div class="paragraph"> </div>

 Prove that <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
<div class="paragraph"> </div>

<a name="lab230"></a><h1 class="section">On the number of constructors</h1>

<div class="paragraph"> </div>

 Let's consider how the truth of a proposition depends on the number
    of its constructors. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="TheTruest"><span class="id" title="inductive">TheTruest</span></a> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="ShortProof"><span class="id" title="constructor">ShortProof</span></a> : <a class="idref" href="Seminar.html#TheTruest"><span class="id" title="inductive">TheTruest</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="LongProof"><span class="id" title="constructor">LongProof</span></a> : <a class="idref" href="Seminar.html#TheTruest"><span class="id" title="inductive">TheTruest</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#TheTruest"><span class="id" title="inductive">TheTruest</span></a>.<br/>

<br/>
</div>

<div class="doc">
This proposition dangerously resembles the type <span class="inlinecode"><span class="id" title="var">nat</span></span>. It appears to
    have an infinite amount of proofs constructred by two constructors,
    one of which corresponds to <span class="inlinecode">0</span> and the other to <span class="inlinecode"><span class="id" title="var">S</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="TheTruest_True"><span class="id" title="lemma">TheTruest_True</span></a> : <a class="idref" href="Seminar.html#TheTruest"><span class="id" title="inductive">TheTruest</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="TheTruest_contractible"><span class="id" title="lemma">TheTruest_contractible</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Seminar.html#TheTruest"><span class="id" title="inductive">TheTruest</span></a>, <a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
</div>

<div class="doc">
This is not really the case. Since all the proofs are equal to each
    other, there in fact is only a single proof. So even though this
    proposition has two constructors one of which is recursive, it
    resembles <span class="inlinecode"><span class="id" title="var">unit</span></span> more than <span class="inlinecode"><span class="id" title="var">nat</span></span>, to which it would be equivalent
    if it lived in <span class="inlinecode"><span class="id" title="keyword">Set</span></span> or <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.

<div class="paragraph"> </div>

    This leads us to ask a somewhat contrived question: for propositions,
    are all constructors besides one useless? Or rather, does a single one
    suffice to make a proposition true? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="BePatient"><span class="id" title="inductive">BePatient</span></a> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="the_longest_proof"><span class="id" title="constructor">the_longest_proof</span></a> : <a class="idref" href="Seminar.html#BePatient"><span class="id" title="inductive">BePatient</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#BePatient"><span class="id" title="inductive">BePatient</span></a>.<br/>

<br/>
</div>

<div class="doc">
The above proposition has a single constructor, so we could be led
    to believe it's true. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="BePatient_false"><span class="id" title="lemma">BePatient_false</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="Seminar.html#BePatient"><span class="id" title="inductive">BePatient</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="BePatient_False"><span class="id" title="lemma">BePatient_False</span></a> : <a class="idref" href="Seminar.html#BePatient"><span class="id" title="inductive">BePatient</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">
However it happens that this proposition is not at all true. How is
    this possible? It has a constructor, so it must be true... not quite.
    Recall that we can build terms of inductive types by applying their
    constructors only a <i>finite</i> number of times.

<div class="paragraph"> </div>

    The "word" finite is crucial here. If we try to apply the constructor
    <span class="inlinecode"><span class="id" title="var">the_longest_proof</span></span> repeatedly, our only hope at finishing is if we
    do it <i>ad infinitum</i>. This is exactly the thing that is forbidden by
    the definition of inductive types.

<div class="paragraph"> </div>

    So, a proposition with one constructor can be false. We could add
    more constructors like <span class="inlinecode"><span class="id" title="var">the_longest_proof</span></span> and they wouldn't help
    if all of them were recursive. Thus we have proven (but only at the
    metatheoretical level) that a false proposition can have any number
    of constructors: 0 (<span class="inlinecode"><span class="id" title="var">False</span></span>), 1 (<span class="inlinecode"><span class="id" title="var">BePatient</span></span>), 2 or more (<span class="inlinecode"><span class="id" title="var">BePatient</span></span>
    on steroids with more constructors).

<div class="paragraph"> </div>

    But what about nonrecursive constructors? Can a propositiona with a
    nonrecursive constructor be false? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="LatentFalsity"><span class="id" title="inductive">LatentFalsity</span></a> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="I_am_true"><span class="id" title="constructor">I_am_true</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#LatentFalsity"><span class="id" title="inductive">LatentFalsity</span></a>.<br/>

<br/>
</div>

<div class="doc">
Well, this one has one nonrecursive constructor, so again we could be
    led to believe it's true... but beware. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="LatentFalsity_false"><span class="id" title="lemma">LatentFalsity_false</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="Seminar.html#LatentFalsity"><span class="id" title="inductive">LatentFalsity</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="LatentFalsity_False"><span class="id" title="lemma">LatentFalsity_False</span></a> : <a class="idref" href="Seminar.html#LatentFalsity"><span class="id" title="inductive">LatentFalsity</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">
This proposition is false because its only constructor takes a proof
    of <span class="inlinecode"><span class="id" title="var">False</span></span> as an argument. Since there isn't one, this constructor can
    never be used to build a proof of <span class="inlinecode"><span class="id" title="var">LatentFalsity</span></span>.

<div class="paragraph"> </div>

    Our voyage into the land of constructors looks rather grimm. We have
    met false propositions with any number of constructors, recursive or
    not. We have also seen that true propositions can have one or more
    constructors.

<div class="paragraph"> </div>

    The only certainty we discovered is that a proposition without any
    constructors must necessarily be false. As soon as it has at least
    one, it can be provable or not depending on how they look like. 
<div class="paragraph"> </div>

<a name="lab231"></a><h4 class="section">Exercise (easy)</h4>

<div class="paragraph"> </div>

 Does <span class="inlinecode"><span class="id" title="var">TheTruest</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">VeryTrue</span></span> hold? If yes, under what assumptions? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab232"></a><h4 class="section">Exercise (medium)</h4>

<div class="paragraph"> </div>

 Find a simple heuristic for deciding (at the metatheoretical level)
    whether an inductive proposition can be proven or not. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab233"></a><h1 class="section">Induction and induction principles for types</h1>

<div class="paragraph"> </div>

 Let's say we want to prove that all elements of a type <span class="inlinecode"><span class="id" title="var">T</span></span> have some
    property. How can we go about it? There are three possibilites that
    depend on the particular form of <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    First of all, if <span class="inlinecode"><span class="id" title="var">T</span></span> is finite, then we can prove our desired statement
    just by considering each element of <span class="inlinecode"><span class="id" title="var">T</span></span> separately. This reasoning can
    be captured by a case analysis principle. Such a principle is a theorem
    of the form <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">xN</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span>,</span>
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>, where <span class="inlinecode"><span class="id" title="var">x1</span></span>, ..., <span class="inlinecode"><span class="id" title="var">xN</span></span> are all the elements of <span class="inlinecode"><span class="id" title="var">T</span></span>.

<div class="paragraph"> </div>

    Let's see an example case analysis principle for <span class="inlinecode"><span class="id" title="var">bool</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool_ind"><span class="id" title="definition">bool_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;bool_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;true&nbsp;-&gt;&nbsp;P&nbsp;false&nbsp;-&gt;&nbsp;forall&nbsp;b&nbsp;:&nbsp;bool,&nbsp;P&nbsp;b&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Note: <span class="inlinecode"><span class="id" title="var">bool_ind</span></span> is the case analysis principle for <span class="inlinecode"><span class="id" title="var">bool</span></span> that Coq
    automatically generated for us. The suffix <span class="inlinecode"><span class="id" title="var">_ind</span></span> stands for induction,
    since case analysis principles are a special case of induction principles.
    Because induction principles can be used not only to prove that all terms
    have some property, but also to define a dependent function, Coq actually
    generates us three principles for each definition we make.

<div class="paragraph"> </div>

    For type <span class="inlinecode"><span class="id" title="var">T</span></span> these are called <span class="inlinecode"><span class="id" title="var">T_rect</span></span>, <span class="inlinecode"><span class="id" title="var">T_rec</span></span> and <span class="inlinecode"><span class="id" title="var">T_ind</span></span>. They differ
    only in the sort of the type that depends on <span class="inlinecode"><span class="id" title="var">T</span></span>: for <span class="inlinecode"><span class="id" title="var">T_rect</span></span> this is
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, for <span class="inlinecode"><span class="id" title="var">T_rec</span></span> it's Set and for <span class="inlinecode"><span class="id" title="var">T_ind</span></span> it's <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. The two latter
    are implemented by simply calling <span class="inlinecode"><span class="id" title="var">T_rect</span></span>.

<div class="paragraph"> </div>

    We see that in order to prove that all terms of type <span class="inlinecode"><span class="id" title="var">bool</span></span> have some
    property, we only have to prove that <span class="inlinecode"><span class="id" title="var">true</span></span> has it and that <span class="inlinecode"><span class="id" title="var">false</span></span>
    also has it. This is because these two are the only terms of type <span class="inlinecode"><span class="id" title="var">bool</span></span>.
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool_rect"><span class="id" title="definition">bool_rect</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;bool_rect&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;(P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;:&nbsp;P&nbsp;true)&nbsp;(f0&nbsp;:&nbsp;P&nbsp;false)&nbsp;(b&nbsp;:&nbsp;bool)&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;b&nbsp;as&nbsp;b0&nbsp;return&nbsp;(P&nbsp;b0)&nbsp;then&nbsp;f&nbsp;else&nbsp;f0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Type,&nbsp;P&nbsp;true&nbsp;-&gt;&nbsp;P&nbsp;false&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;b&nbsp;:&nbsp;bool,&nbsp;P&nbsp;b&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
When we look at the definition we can see an <span class="inlinecode"><span class="id" title="keyword">if</span></span> here. This is just a
    syntactic sugar for <span class="inlinecode"><span class="id" title="keyword">match</span></span>, which shows us that the principle is not
    magical or built-in and can be derived manually using pattern matching.

<div class="paragraph"> </div>

    But how to use this principle to prove something? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="negb_involutive'"><span class="id" title="lemma">negb_involutive'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool_ind"><span class="id" title="definition">bool_ind</span></a>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Since an induction principle is just a normal theorem, we can apply it
    like a theorem. This is precisely what the <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> tactic does — it
    applies for us the standard case analysis principle associated with the
    type of its argument.

<div class="paragraph"> </div>

    Let's get back to our question of how to prove that all terms of some
    type have some property. The above was just the finite case for inductive
    types. But what if our type is infinite?

<div class="paragraph"> </div>

    This is the second case. In general, if our type is infinite and we want
    to be done with our proving in finite time and using finite resources,
    then we're doomed. A representative example of this case are functions
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> — there are so many of them that we can't prove anything
    nontrivial about all of them.

<div class="paragraph"> </div>

    Not all hope is lost, however. The third case is: our type is infinite,
    but defined inductively. In this case we can do as much as in the finite
    case. Even though we can't check each element of <span class="inlinecode"><span class="id" title="var">T</span></span> separately, we know
    that it is "finitely generated", meaning that it can be constructed by
    applying one of finitely many constructors of <span class="inlinecode"><span class="id" title="var">T</span></span> a finite number of
    times.

<div class="paragraph"> </div>

    It turns out this is enough for us. Let's see how the induction principle
    for <span class="inlinecode"><span class="id" title="var">nat</span></span> looks like. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat_ind"><span class="id" title="definition">nat_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nat_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;-&gt;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
To prove that all natural numbers have the property <span class="inlinecode"><span class="id" title="var">P</span></span>, we only have
    to prove that <span class="inlinecode">0</span> has it and that <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> has it under the assumption that
    <span class="inlinecode"><span class="id" title="var">n</span></span> does. This is because these two constructors are everything we need
    in order to generate all natural numbers.

<div class="paragraph"> </div>

    The second argument is of particular interest to us: if it were
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>, we would only have a case analysis
    principle. However, it also has the premise <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, which makes it
    recursive. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat_rect"><span class="id" title="definition">nat_rect</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nat_rect&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;(P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Type)&nbsp;(f&nbsp;:&nbsp;P&nbsp;0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f0&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fix&nbsp;F&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;:&nbsp;P&nbsp;n&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;as&nbsp;n0&nbsp;return&nbsp;(P&nbsp;n0)&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;f<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;n0&nbsp;=&gt;&nbsp;f0&nbsp;n0&nbsp;(F&nbsp;n0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Type,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;-&gt;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
As we see, this principle too is neither magical nor built-in. It can
    be derived manually using just pattern matching and recursion. This is
    the case for all induction principles of inductive types: they can be
    derived manually using <span class="inlinecode"><span class="id" title="keyword">match</span></span> and <span class="inlinecode"><span class="id" title="keyword">fix</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus_assoc'"><span class="id" title="lemma">plus_assoc'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">(</span></a><a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">(</span></a><a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat_ind"><span class="id" title="definition">nat_ind</span></a>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat_ind"><span class="id" title="definition">nat_ind</span></a><br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">(</span></a><a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">(</span></a><a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHa</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
As in the case of <span class="inlinecode"><span class="id" title="var">bool_ind</span></span>, we can use our induction principle just
    by applying it. This time however it is a bit harder: simply doing
    <span class="inlinecode"><span class="id" title="tactic">apply</span></span> is weird, because it produces three goals, first of which is
    equivalent to the original one, the second is a trivial implication and
    the third asks us for a natural number.

<div class="paragraph"> </div>

    It works that way because Coq can't guess what is the <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>
    that we want to use <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> with. We can solve this problem by giving
    it manually, just as in our second try.

<div class="paragraph"> </div>

    We also see that the tactic <span class="inlinecode"><span class="id" title="tactic">induction</span></span> is there to do just this for us
    automatically: it correctly identifies the <span class="inlinecode"><span class="id" title="var">P</span></span> we want to use and then
    applies the induction principle. 
<div class="paragraph"> </div>

<a name="lab234"></a><h4 class="section">Exercise (medium)</h4>

<div class="paragraph"> </div>

 Find a simple metatheoretic algorithm for generating standard induction
    principles for any inductive type <span class="inlinecode"><span class="id" title="var">T</span></span>. 
<div class="paragraph"> </div>

<a name="lab235"></a><h1 class="section">Parameters and indices</h1>

<div class="paragraph"> </div>

 It's high time to see how to define inductive predicates, relations and,
    more generally, families of types. There are two ways: using parameters
    and indices. After we study both in separation, we will compare them.

<div class="paragraph"> </div>

    A parametric family of inductive types looks like this: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;option&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Some&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;option&nbsp;A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;None&nbsp;:&nbsp;option&nbsp;A&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Because <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> appears before the final colon, <span class="inlinecode"><span class="id" title="var">option</span></span> is not
    a type, but a family of types, parametrized by a type <span class="inlinecode"><span class="id" title="var">A</span></span>. We can see
    this with the <span class="inlinecode"><span class="id" title="keyword">Check</span></span> command. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;option&nbsp;:&nbsp;Type&nbsp;-&gt;&nbsp;Type&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Parametric definitions basically tell Coq to define a separate inductive
    type for every possible value of the parameter. In the constructors of
    the type family, the parameter is fixed: every time it appears, it has
    to be the same as in the header of the inductive definition.

<div class="paragraph"> </div>

    This is sometimes a limitation, but often it's just fine. The most common
    use of parameters is the one presented above: defining polymorphic types,
    containers, relations and predicates. We can easily find more examples of
    such a usage: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#prod"><span class="id" title="inductive">prod</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;prod&nbsp;(A&nbsp;B&nbsp;:&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;pair&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;*&nbsp;B&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#sum"><span class="id" title="inductive">sum</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;sum&nbsp;(A&nbsp;B&nbsp;:&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;inl&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;+&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;inr&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;+&nbsp;B&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#sigT"><span class="id" title="inductive">sigT</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;sigT&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;existT&nbsp;:&nbsp;forall&nbsp;x&nbsp;:&nbsp;A,&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;{x&nbsp;:&nbsp;A&nbsp;&amp;&nbsp;P&nbsp;x}&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#and"><span class="id" title="inductive">and</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;and&nbsp;(A&nbsp;B&nbsp;:&nbsp;Prop)&nbsp;:&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;conj&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#or"><span class="id" title="inductive">or</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;or&nbsp;(A&nbsp;B&nbsp;:&nbsp;Prop)&nbsp;:&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;or_introl&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;\/&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;or_intror&nbsp;:&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;\/&nbsp;B&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;ex&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Prop)&nbsp;:&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;ex_intro&nbsp;:&nbsp;forall&nbsp;x&nbsp;:&nbsp;A,&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;exists&nbsp;y,&nbsp;P&nbsp;y&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
We see that parameters are engouh to implement a whole bunch of most
    common polymorphic types like products, sums and dependent pairs.

<div class="paragraph"> </div>

    On the other hand, we can define fully general indexed families of
    types like this: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="even"><span class="id" title="inductive">even</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="even0"><span class="id" title="constructor">even0</span></a> : <a class="idref" href="Seminar.html#even"><span class="id" title="inductive">even</span></a> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="evenSS"><span class="id" title="constructor">evenSS</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#even"><span class="id" title="inductive">even</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#even"><span class="id" title="inductive">even</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>)).<br/>

<br/>
</div>

<div class="doc">
Here we have nothing before the final colon (the one after <span class="inlinecode"><span class="id" title="var">even</span></span>),
    so there aren't any parameters. However, after the colon we see
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, which means <span class="inlinecode"><span class="id" title="var">even</span></span> is a family of propositions indexed
    by a natural number, i.e. a predicate on <span class="inlinecode"><span class="id" title="var">nat</span></span>. We can verify this
    with the command <span class="inlinecode"><span class="id" title="keyword">Check</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#even"><span class="id" title="inductive">even</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
In the constructors of <span class="inlinecode"><span class="id" title="var">even</span></span>, the index is not fixed: in <span class="inlinecode"><span class="id" title="var">even0</span></span> it
    is <span class="inlinecode">0</span>, whereas in <span class="inlinecode"><span class="id" title="var">evenSS</span></span> it is <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>, which is different from
    <span class="inlinecode">0</span>. Because of this, indexed families are more general than parametric
    families. 
<div class="paragraph"> </div>

<a name="lab236"></a><h4 class="section">Exercise (easy)</h4>

<div class="paragraph"> </div>

 These exercises are stolen from the first chapter of Essentials of
    Programming Languages (exercises 1.1, 1.2). Each one is in a separate
    module in order to avoid name clashes. Do them.

<div class="paragraph"> </div>

    You can use the tactic <span class="inlinecode"><span class="id" title="tactic">omega</span></span>, which can solve arithmetical goals with
    <span class="inlinecode">0</span>, <span class="inlinecode"><span class="id" title="var">S</span></span>, <span class="inlinecode">+</span> and multiplication by a constant. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.omega.Omega.html#"><span class="id" title="library">Omega</span></a>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a name="Ex1_1"><span class="id" title="module">Ex1_1</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Ex1_1.P"><span class="id" title="inductive">P</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex1_1.c0"><span class="id" title="constructor">c0</span></a> : <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex1_1.c1"><span class="id" title="constructor">c1</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>))).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex1_1.P_char"><span class="id" title="lemma">P_char</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#Ex1_1.P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 3 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Ex1_1"><span class="id" title="module">Ex1_1</span></a>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a name="Ex1_2"><span class="id" title="module">Ex1_2</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Ex1_2.P"><span class="id" title="inductive">P</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex1_2.c0"><span class="id" title="constructor">c0</span></a> : <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex1_2.c1"><span class="id" title="constructor">c1</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> (2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex1_2.c2"><span class="id" title="constructor">c2</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> (3 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex1_2.P_char"><span class="id" title="lemma">P_char</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#Ex1_2.P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> <span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 3 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Ex1_2"><span class="id" title="module">Ex1_2</span></a>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a name="Ex1_3"><span class="id" title="module">Ex1_3</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Ex1_3.P"><span class="id" title="inductive">P</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex1_3.c0"><span class="id" title="constructor">c0</span></a> : <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> 0 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex1_3.c1"><span class="id" title="constructor">c1</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> (1 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) (2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex1_3.P_char"><span class="id" title="lemma">P_char</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#Ex1_3.P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Ex1_3"><span class="id" title="module">Ex1_3</span></a>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a name="Ex1_4"><span class="id" title="module">Ex1_4</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Ex1_4.P"><span class="id" title="inductive">P</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex1_4.c0"><span class="id" title="constructor">c0</span></a> : <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> 0 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex1_4.c1"><span class="id" title="constructor">c1</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) (<a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex1_4.P_char"><span class="id" title="lemma">P_char</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#Ex1_4.P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Ex1_4"><span class="id" title="module">Ex1_4</span></a>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a name="Ex2_1"><span class="id" title="module">Ex2_1</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Ex2_1.P"><span class="id" title="inductive">P</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex2_1.c0"><span class="id" title="constructor">c0</span></a> : <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> 0 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex2_1.c1"><span class="id" title="constructor">c1</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> (1 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) (7 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex2_1.P_char"><span class="id" title="lemma">P_char</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#Ex2_1.P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 7 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Ex2_1"><span class="id" title="module">Ex2_1</span></a>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a name="Ex2_2"><span class="id" title="module">Ex2_2</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Ex2_2.P"><span class="id" title="inductive">P</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex2_2.c0"><span class="id" title="constructor">c0</span></a> : <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> 0 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex2_2.c1"><span class="id" title="constructor">c1</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) (2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>).<br/>

<br/>
<span class="id" title="keyword">Function</span> <span class="id" title="var">pow2</span> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span> =&gt; 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#pow2"><span class="id" title="definition">pow2</span></a> <span class="id" title="var">n'</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex2_2.P_char"><span class="id" title="lemma">P_char</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#Ex2_2.P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#Ex2_2.pow2"><span class="id" title="definition">pow2</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Ex2_2"><span class="id" title="module">Ex2_2</span></a>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a name="Ex2_3"><span class="id" title="module">Ex2_3</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Ex2_3.P"><span class="id" title="inductive">P</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex2_3.c0"><span class="id" title="constructor">c0</span></a> : <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> 0 0 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex2_3.c1"><span class="id" title="constructor">c1</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a> (<a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a>).<br/>

<br/>
<span class="id" title="keyword">Function</span> <span class="id" title="var">fib</span> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n''</span> <span class="id" title="keyword">as</span> <span class="id" title="var">n'</span>) =&gt; <a class="idref" href="Seminar.html#fib"><span class="id" title="definition">fib</span></a> <span class="id" title="var">n'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#fib"><span class="id" title="definition">fib</span></a> <span class="id" title="var">n''</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex2_3.P_char"><span class="id" title="lemma">P_char</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#Ex2_3.P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#Ex2_3.fib"><span class="id" title="definition">fib</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#Ex2_3.fib"><span class="id" title="definition">fib</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a>).<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Ex2_3"><span class="id" title="module">Ex2_3</span></a>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a name="Ex2_4"><span class="id" title="module">Ex2_4</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Ex2_4.P"><span class="id" title="inductive">P</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex2_4.c0"><span class="id" title="constructor">c0</span></a> : <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> 0 1 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Ex2_4.c1"><span class="id" title="constructor">c1</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="inductive">P</span></a> (1 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a>) (2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>) (<a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex2_4.P_char"><span class="id" title="lemma">P_char</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#Ex2_4.P"><span class="id" title="inductive">P</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Ex2_4"><span class="id" title="module">Ex2_4</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab237"></a><h4 class="section">Exercise (easy)</h4>

<div class="paragraph"> </div>

 This exercise is also stolen from Essentials of Programming Languages
    (besides the last part of it, which is mine).

<div class="paragraph"> </div>

    Define two inductives predicates <span class="inlinecode"><span class="id" title="var">T</span></span> and <span class="inlinecode"><span class="id" title="var">T'</span></span>, such that:
<ul class="doclist">
<li> they both satisfy the property <span class="inlinecode"><span class="id" title="var">P</span></span>

</li>
<li> they are not equal

</li>
<li> <span class="inlinecode"><span class="id" title="var">T</span></span> is contained in <span class="inlinecode"><span class="id" title="var">T'</span></span>  
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="Ex3"><span class="id" title="module">Ex3</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="Ex3.P"><span class="id" title="definition">P</span></a> (<span class="id" title="var">R</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Seminar.html#R"><span class="id" title="variable">R</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#R"><span class="id" title="variable">R</span></a> (3 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>).<br/>

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex3.P_T"><span class="id" title="lemma">P_T</span></a> : <a class="idref" href="Seminar.html#Ex3.P"><span class="id" title="definition">P</span></a> <a class="idref" href="Seminar.html#Ex3.T"><span class="id" title="inductive">T</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex3.P_T'"><span class="id" title="lemma">P_T'</span></a> : <a class="idref" href="Seminar.html#Ex3.P"><span class="id" title="definition">P</span></a> <a class="idref" href="Seminar.html#Ex3.T'"><span class="id" title="inductive">T'</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex3.T_not_T'"><span class="id" title="lemma">T_not_T'</span></a> : <a class="idref" href="Seminar.html#Ex3.T"><span class="id" title="inductive">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="Seminar.html#Ex3.T'"><span class="id" title="inductive">T'</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Ex3.T_sub_T'"><span class="id" title="lemma">T_sub_T'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#Ex3.T"><span class="id" title="inductive">T</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#Ex3.T'"><span class="id" title="inductive">T'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Ex3"><span class="id" title="module">Ex3</span></a>.<br/>

<br/>
</div>

<div class="doc">
Parameters and indices are not mutually exclusive. They can be combined
    freely. A typical example of such usage is the less or equal order
    relation on the natural numbers. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#le"><span class="id" title="inductive">le</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;le&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;le_n&nbsp;:&nbsp;n&nbsp;&lt;=&nbsp;n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;le_S&nbsp;:&nbsp;forall&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=&nbsp;m&nbsp;-&gt;&nbsp;n&nbsp;&lt;=&nbsp;S&nbsp;m&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
In the definition of <span class="inlinecode"><span class="id" title="var">le</span></span>, the parameter <span class="inlinecode"><span class="id" title="var">n</span></span> is fixed in all constructors,
    but the index varies: in <span class="inlinecode"><span class="id" title="var">le_n</span></span> it is <span class="inlinecode"><span class="id" title="var">n</span></span>, but in <span class="inlinecode"><span class="id" title="var">le_S</span></span> it is first <span class="inlinecode"><span class="id" title="var">m</span></span>
    and then <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>. Because of this it can't be rewritten using parameters
    only, but it can be rewritten using only indices. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="le'"><span class="id" title="inductive">le'</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="le'_n"><span class="id" title="constructor">le'_n</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#le'"><span class="id" title="inductive">le'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="le'_S"><span class="id" title="constructor">le'_S</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#le'"><span class="id" title="inductive">le'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#le'"><span class="id" title="inductive">le'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>).<br/>

<br/>
</div>

<div class="doc">
We see that in the definition of <span class="inlinecode"><span class="id" title="var">le'</span></span> we have to quantify over <span class="inlinecode"><span class="id" title="var">n</span></span> in
    each constructor separately in order to use it. This is a disadvantage
    of indexed families: if the index doesn't vary, we have to write more
    code when compared to a definition using a parameter instead. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="le_le'"><span class="id" title="lemma">le_le'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#9b077c369e19739ef880736ba34623ff"><span class="id" title="notation">&lt;=</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="Seminar.html#le'"><span class="id" title="inductive">le'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="le_plus"><span class="id" title="lemma">le_plus</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#le"><span class="id" title="inductive">le</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#le"><span class="id" title="inductive">le</span></a> (<a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a>) (<a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="le'_plus"><span class="id" title="lemma">le'_plus</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#le'"><span class="id" title="inductive">le'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#le'"><span class="id" title="inductive">le'</span></a> (<a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a>) (<a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a>).<br/>

<br/>
</div>

<div class="doc">
We can easily prove that both definitions yield equivalent relations.
    Moreover, it is equally easy to prove both <span class="inlinecode"><span class="id" title="var">le_plus</span></span> and <span class="inlinecode"><span class="id" title="var">le'_plus</span></span>.
    So, which of these two definitions is better? The answer is that <span class="inlinecode"><span class="id" title="var">le</span></span>
    is better. To see it, let's take a look at the induction principles. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#le_ind"><span class="id" title="definition">le_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;le_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;(forall&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;m))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=&nbsp;n0&nbsp;-&gt;&nbsp;P&nbsp;n0&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#le'_ind"><span class="id" title="definition">le'_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;le'_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;n)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le'&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;(S&nbsp;m))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;le'&nbsp;n&nbsp;n0&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;n0&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Don't wory if you don't understand these principles yet. We will come
    back to them later. The only thing to you need to notice now is that
    <span class="inlinecode"><span class="id" title="var">le'_ind</span></span> is more complex than <span class="inlinecode"><span class="id" title="var">le_ind</span></span>.

<div class="paragraph"> </div>

    Because using parameters means writing less code while having simpler
    induction principles, we should prefer them wherever possible. There
    isn't much more to be said: knowing whether to use parameters or
    indices comes with practice. The only simple heuristic is that often
    you will want types (and propositions) to be parameters.

<div class="paragraph"> </div>

    If you don't know which one to use, you may use indices first and then
    check whether any one of them is fixed throughout the definition. If
    there is one, you can refactor it into a parameter.

<div class="paragraph"> </div>

    Let's now proceed to learn about induction principles for families of
    types. 
<div class="paragraph"> </div>

<a name="lab238"></a><h1 class="section">Induction principles for type families</h1>

<div class="paragraph"> </div>

 Now that we know how to define parametric and indexed families of types
    and how to derive standard recursion principles for ordinary inductive
    types, the next natural question to consider is how to derive induction
    principles for families of types. Let's take the next step on our path
    to enlightenment.

<div class="paragraph"> </div>

    Let's start by looking at parametric families. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="MonomorphicList"><span class="id" title="module">MonomorphicList</span></a>.<br/>

<br/>
</div>

<div class="doc">
We will make a new module in order not pollute the global namespace.
    The name <span class="inlinecode"><span class="id" title="var">MonomorphicList</span></span> means that we're going to define lists
    that can hold elements of only a single type. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Parameter</span> <a name="MonomorphicList.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
</div>

<div class="doc">
We will call this type <span class="inlinecode"><span class="id" title="var">A</span></span>. The command <span class="inlinecode"><span class="id" title="keyword">Parameter</span></span> is a synonym of
    <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span>, <span class="inlinecode"><span class="id" title="keyword">Hypothesis</span></span> and a few more. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="MonomorphicList.listA"><span class="id" title="inductive">listA</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MonomorphicList.nilA"><span class="id" title="constructor">nilA</span></a> : <a class="idref" href="Seminar.html#listA"><span class="id" title="inductive">listA</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="MonomorphicList.consA"><span class="id" title="constructor">consA</span></a> : <a class="idref" href="Seminar.html#MonomorphicList.A"><span class="id" title="axiom">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#listA"><span class="id" title="inductive">listA</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#listA"><span class="id" title="inductive">listA</span></a>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">listA</span></span> is just like <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> (note the lack of space in the first
    name), but it's not parametric. Rather, the <span class="inlinecode"><span class="id" title="var">A</span></span> is fixed. Let's
    compare the induction principle for <span class="inlinecode"><span class="id" title="var">listA</span></span> with that of <span class="inlinecode"><span class="id" title="var">list</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#MonomorphicList.listA_ind"><span class="id" title="definition">listA_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;listA_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;listA&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;nilA&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(a&nbsp;:&nbsp;A)&nbsp;(l&nbsp;:&nbsp;listA),&nbsp;P&nbsp;l&nbsp;-&gt;&nbsp;P&nbsp;(consA&nbsp;a&nbsp;l))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;l&nbsp;:&nbsp;listA,&nbsp;P&nbsp;l&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list_ind"><span class="id" title="definition">list_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;list_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(P&nbsp;:&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;nil&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(a&nbsp;:&nbsp;A)&nbsp;(l&nbsp;:&nbsp;list&nbsp;A),&nbsp;P&nbsp;l&nbsp;-&gt;&nbsp;P&nbsp;(a&nbsp;::&nbsp;l)*)</span><br/>

<br/>
</div>

<div class="doc">
The principle <span class="inlinecode"><span class="id" title="var">listA_ind</span></span> says that in order to prove that all <span class="inlinecode"><span class="id" title="var">listA</span></span>s
    have some property <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">listA</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, it is necessary to prove that
    <span class="inlinecode"><span class="id" title="var">P</span></span> holds for <span class="inlinecode"><span class="id" title="var">nilA</span></span> and that if it holds for <span class="inlinecode"><span class="id" title="var">l</span></span>, then it holds for
    <span class="inlinecode"><span class="id" title="var">consA</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> where <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> is arbitrary. Not a big surprise.

<div class="paragraph"> </div>

    If we look at the principle for <span class="inlinecode"><span class="id" title="var">list</span></span>, it says nearly the same. The
    only difference is that the type <span class="inlinecode"><span class="id" title="var">A</span></span> is not fixed. It is a parameter
    and this is reflected in the principle: the first quantifier says
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span>.

<div class="paragraph"> </div>

    When it comes to induction principles for parametric families, this is
    it: quantifiers have to first quantify over the parameters of the type
    family. The rest of the principle is as usual. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#MonomorphicList"><span class="id" title="module">MonomorphicList</span></a>.<br/>

<br/>
</div>

<div class="doc">
We have described only maximal principles for parametric families, but
    don't worry: the minimal ones work exactly the same way, so let's move
    on to indexed families. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="IndexedList"><span class="id" title="module">IndexedList</span></a>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="IndexedList.ilist"><span class="id" title="inductive">ilist</span></a> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="IndexedList.inil"><span class="id" title="constructor">inil</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <a class="idref" href="Seminar.html#ilist"><span class="id" title="inductive">ilist</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="IndexedList.icons"><span class="id" title="constructor">icons</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>, <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#ilist"><span class="id" title="inductive">ilist</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#ilist"><span class="id" title="inductive">ilist</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>.<br/>

<br/>
</div>

<div class="doc">
We will continue the above comparison by looking at the induction
    principle of a polymorphic list type, but written using indices
    instead of parameters. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#IndexedList.icons"><span class="id" title="constructor">icons</span></a> <span class="id" title="var">_</span> 5 (<a class="idref" href="Seminar.html#IndexedList.icons"><span class="id" title="constructor">icons</span></a> <span class="id" title="var">_</span> 42 (<a class="idref" href="Seminar.html#IndexedList.inil"><span class="id" title="constructor">inil</span></a> <span class="id" title="var">_</span>)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;icons&nbsp;nat&nbsp;5&nbsp;(icons&nbsp;nat&nbsp;42&nbsp;(inil&nbsp;nat))&nbsp;:&nbsp;ilist&nbsp;nat&nbsp;*)</span><br/>

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#IndexedList.icons"><span class="id" title="constructor">icons</span></a> <span class="id" title="var">_</span> 42 (<a class="idref" href="Seminar.html#IndexedList.icons"><span class="id" title="constructor">icons</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> (<a class="idref" href="Seminar.html#IndexedList.inil"><span class="id" title="constructor">inil</span></a> <span class="id" title="var">_</span>)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;term&nbsp;"icons&nbsp;bool&nbsp;true&nbsp;(inil&nbsp;bool)"&nbsp;has&nbsp;type&nbsp;"ilist&nbsp;bool"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;it&nbsp;is&nbsp;expected&nbsp;to&nbsp;have&nbsp;type&nbsp;"ilist&nbsp;nat".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
This type is just like the ordinary <span class="inlinecode"><span class="id" title="var">list</span></span>: we can have lists of
    elements of any type we like, but we can't put elements of different
    types in the same list. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#IndexedList.ilist_ind"><span class="id" title="definition">ilist_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ilist_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;forall&nbsp;T&nbsp;:&nbsp;Type,&nbsp;ilist&nbsp;T&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;P&nbsp;A&nbsp;(inil&nbsp;A))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(a&nbsp;:&nbsp;A)&nbsp;(i&nbsp;:&nbsp;ilist&nbsp;A),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;A&nbsp;i&nbsp;-&gt;&nbsp;P&nbsp;A&nbsp;(icons&nbsp;A&nbsp;a&nbsp;i))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(T&nbsp;:&nbsp;Type)&nbsp;(i&nbsp;:&nbsp;ilist&nbsp;T),&nbsp;P&nbsp;T&nbsp;i&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The principle is much more complex than that for ordinary <span class="inlinecode"><span class="id" title="var">list</span></span>s.
    First thing to notice is that there is no quantification over the
    type <span class="inlinecode"><span class="id" title="var">T</span></span> at the beginning of the principle: <span class="inlinecode"><span class="id" title="var">T</span></span> in theory can be
    different each time it appears, so we can't quantify it once and
    for all (even if in reality it is always the same).

<div class="paragraph"> </div>

    Because of this, we havy to quantify over it each time separately.
    This can be seen in the type of the predicate <span class="inlinecode"><span class="id" title="var">P</span></span>. It is a predicate
    on <span class="inlinecode"><span class="id" title="var">ilist</span></span> <span class="inlinecode"><span class="id" title="var">T</span></span>, but in order to be well-typed it has to quantify over
    <span class="inlinecode"><span class="id" title="var">T</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>.

<div class="paragraph"> </div>

    Then the principle looks very similar to that of <span class="inlinecode"><span class="id" title="var">list</span></span>, but as we said
    before, the case for each constructor has to quantify over <span class="inlinecode"><span class="id" title="var">T</span></span> (here
    called <span class="inlinecode"><span class="id" title="var">A</span></span>) separately. The end of the principle is also similar, but
    once again a quantification over <span class="inlinecode"><span class="id" title="var">T</span></span> appears.

<div class="paragraph"> </div>

    This is it: induction principles for indexed families are about having
    to quantify over the indices separately each time they appear somewhere. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#IndexedList"><span class="id" title="module">IndexedList</span></a>.<br/>

<br/>
</div>

<div class="doc">
The last thing are definitions having both parameters and indices. They
    adhere to the above rules: in their principles parameters are quantified
    over right at the start and the indices are quantified over separately
    each time they appear. 
<div class="paragraph"> </div>

<a name="lab239"></a><h1 class="section">Maximal and minimal principles</h1>

<div class="paragraph"> </div>

 If you look carefully at the induction principle for <span class="inlinecode"><span class="id" title="var">le</span></span>, it seems not
    to follow the rules we saw above. This is because propositions (and all
    families of propositions) are treated a bit differently from ordinary
    types (and type families). Our goal in this subchapter will be to learn
    about this difference.

<div class="paragraph"> </div>

    Let's compare the induction principles for <span class="inlinecode"><span class="id" title="var">prod</span></span> and <span class="inlinecode"><span class="id" title="var">sum</span></span> (which live
    in <span class="inlinecode"><span class="id" title="keyword">Type</span></span>) with <span class="inlinecode"><span class="id" title="var">and</span></span> and <span class="inlinecode"><span class="id" title="var">or</span></span>, their counterparts living in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.
    Before we start, I have to admit that I lied to you once more.

<div class="paragraph"> </div>

    I told you that for every inductive type we define, Coq generates us
    three induction principles. This is actually the case only for types
    living in <span class="inlinecode"><span class="id" title="keyword">Set</span></span> and <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. For these in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, only one induction
    principles is generated.

<div class="paragraph"> </div>

    Therefore, in our comparison we will compare the principles <span class="inlinecode"><span class="id" title="var">prod_rect</span></span>
    and <span class="inlinecode"><span class="id" title="var">sum_rect</span></span> to <span class="inlinecode"><span class="id" title="var">and_ind</span></span> and <span class="inlinecode"><span class="id" title="var">or_ind</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#prod_rect"><span class="id" title="definition">prod_rect</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;prod_rect&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;B&nbsp;:&nbsp;Type)&nbsp;(P&nbsp;:&nbsp;A&nbsp;*&nbsp;B&nbsp;-&gt;&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(a&nbsp;:&nbsp;A)&nbsp;(b&nbsp;:&nbsp;B),&nbsp;P&nbsp;(a,&nbsp;b))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;p&nbsp;:&nbsp;A&nbsp;*&nbsp;B,&nbsp;P&nbsp;p&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#sum_rect"><span class="id" title="definition">sum_rect</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;sum_rect&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;B&nbsp;:&nbsp;Type)&nbsp;(P&nbsp;:&nbsp;A&nbsp;+&nbsp;B&nbsp;-&gt;&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;a&nbsp;:&nbsp;A,&nbsp;P&nbsp;(inl&nbsp;a))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;b&nbsp;:&nbsp;B,&nbsp;P&nbsp;(inr&nbsp;b))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;s&nbsp;:&nbsp;A&nbsp;+&nbsp;B,&nbsp;P&nbsp;s&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#and_ind"><span class="id" title="definition">and_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;and_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;P&nbsp;:&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;P)&nbsp;-&gt;&nbsp;A&nbsp;/\&nbsp;B&nbsp;-&gt;&nbsp;P&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#or_ind"><span class="id" title="definition">or_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;or_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;A&nbsp;B&nbsp;P&nbsp;:&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A&nbsp;-&gt;&nbsp;P)&nbsp;-&gt;&nbsp;(B&nbsp;-&gt;&nbsp;P)&nbsp;-&gt;&nbsp;A&nbsp;\/&nbsp;B&nbsp;-&gt;&nbsp;P&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
We could have expected them to be very alike, since the only differences
    between <span class="inlinecode"><span class="id" title="var">prod</span></span>/<span class="inlinecode"><span class="id" title="var">and</span></span> and <span class="inlinecode"><span class="id" title="var">sum</span></span>/<span class="inlinecode"><span class="id" title="var">or</span></span> (and the associated principles) are
    in the sorts. Yet they are very different. Why is this?

<div class="paragraph"> </div>

    In order to answer, we have to introduce the distinction between maximal
    and minimal induction principles. All principles you have seen until now
    (not including <span class="inlinecode"><span class="id" title="var">and_ind</span></span>/<span class="inlinecode"><span class="id" title="var">or_ind</span></span>) were maximal principles. When we define
    an inductive type or family living in <span class="inlinecode"><span class="id" title="keyword">Set</span></span> or <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, a maximal principle
    is generated for it by default. But when its sort is <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a minimal
    principle is generated.

<div class="paragraph"> </div>

    It is not the case however that maximal principles are unique to <span class="inlinecode"><span class="id" title="keyword">Set</span></span>s
    and <span class="inlinecode"><span class="id" title="keyword">Type</span></span>s and minimal principles are unique to <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>s. We can have
    both for an inductive type of any sort. To understand the distinction,
    let's generate minimal principles for <span class="inlinecode"><span class="id" title="var">prod</span></span> and <span class="inlinecode"><span class="id" title="var">sum</span></span>.

<div class="paragraph"> </div>

    We can do this with the command <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span>. By the way, here's a joke:
    Scheme is not a programming language, <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> is just a Coq command
    for generating induction principles. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Scheme</span> <a name="prod_rect_min"><span class="id" title="definition">prod_rect_min</span></a> := <span class="id" title="var">Minimality</span> <span class="id" title="keyword">for</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#prod"><span class="id" title="inductive">prod</span></a> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Scheme</span> <a name="sum_rect_min"><span class="id" title="definition">sum_rect_min</span></a> := <span class="id" title="var">Minimality</span> <span class="id" title="keyword">for</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#sum"><span class="id" title="inductive">sum</span></a> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#prod_rect_min"><span class="id" title="definition">prod_rect_min</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;prod_ind_min&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;B&nbsp;:&nbsp;Type)&nbsp;(P&nbsp;:&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;P)&nbsp;-&gt;&nbsp;A&nbsp;*&nbsp;B&nbsp;-&gt;&nbsp;P&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#sum_rect_min"><span class="id" title="definition">sum_rect_min</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;sum_ind_min&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;B&nbsp;:&nbsp;Type)&nbsp;(P&nbsp;:&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A&nbsp;-&gt;&nbsp;P)&nbsp;-&gt;&nbsp;(B&nbsp;-&gt;&nbsp;P)&nbsp;-&gt;&nbsp;A&nbsp;+&nbsp;B&nbsp;-&gt;&nbsp;P&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
These are much more like the principles for <span class="inlinecode"><span class="id" title="var">and</span></span>/<span class="inlinecode"><span class="id" title="var">or</span></span> than the maximal
    principles for <span class="inlinecode"><span class="id" title="var">prod</span></span>/<span class="inlinecode"><span class="id" title="var">sum</span></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">prod_rect</span></span> tells us that in order to define a dependent function
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span>, we have to provide a dependent function
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">(<span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span>),</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">a</span>,</span> <span class="inlinecode"><span class="id" title="var">b</span>)</span>. On the other hand, <span class="inlinecode"><span class="id" title="var">prod_rect_min</span></span>
    tells us that in order to define a nondependent function <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>
    we have to provide another nondependent function <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>.

<div class="paragraph"> </div>

    Likewise <span class="inlinecode"><span class="id" title="var">sum_rect</span></span> tells us that in order to define a dependent
    function <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">B</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> we have to provide two dependent
    functions <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">inl</span></span> <span class="inlinecode"><span class="id" title="var">a</span>)</span> and <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">inr</span></span> <span class="inlinecode"><span class="id" title="var">b</span>)</span>.
    On the other hand, <span class="inlinecode"><span class="id" title="var">sum_rect_min</span></span> tells us that in order to define
    a nondependent function <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> we have to provide two
    nondependent functions <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>.

<div class="paragraph"> </div>

    This is it! The distinction between maximal and minimal principles
    boils down to the fact that maximal principles are for defining
    dependent functions (and proving predicates), whereas the minimal
    ones are for nondependent functions (and proving propositions).

<div class="paragraph"> </div>

    So, maximal principles are more general than minimal principles.
    The last question that remains is: why are the less general
    principles generated by Coq, if it can generate the more general
    ones?

<div class="paragraph"> </div>

    To answer this, let's first have a look at the maximal principles
    for <span class="inlinecode"><span class="id" title="var">and</span></span> and <span class="inlinecode"><span class="id" title="var">or</span></span>. These can be generated with a different variant
    of the command <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Scheme</span> <a name="and_ind_max"><span class="id" title="definition">and_ind_max</span></a> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#and"><span class="id" title="inductive">and</span></a> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Prop</span>.<br/>
<span class="id" title="keyword">Scheme</span> <a name="or_ind_max"><span class="id" title="definition">or_ind_max</span></a> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#or"><span class="id" title="inductive">or</span></a> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#and_ind_max"><span class="id" title="definition">and_ind_max</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;and_ind_max&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;B&nbsp;:&nbsp;Prop)&nbsp;(P&nbsp;:&nbsp;A&nbsp;/\&nbsp;B&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(a&nbsp;:&nbsp;A)&nbsp;(b&nbsp;:&nbsp;B),&nbsp;P&nbsp;(conj&nbsp;a&nbsp;b))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;a&nbsp;:&nbsp;A&nbsp;/\&nbsp;B,&nbsp;P&nbsp;a&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#or_ind_max"><span class="id" title="definition">or_ind_max</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;or_ind_max&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;B&nbsp;:&nbsp;Prop)&nbsp;(P&nbsp;:&nbsp;A&nbsp;\/&nbsp;B&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;a&nbsp;:&nbsp;A,&nbsp;P&nbsp;(or_introl&nbsp;a))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;b&nbsp;:&nbsp;B,&nbsp;P&nbsp;(or_intror&nbsp;b))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;o&nbsp;:&nbsp;A&nbsp;\/&nbsp;B,&nbsp;P&nbsp;o&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
We now see another side of the coin: the maximal principles are not
    only more general, but also more complex. So, the question boils down
    to why should we prefer simplicity over generality.

<div class="paragraph"> </div>

    The last thing we have to do is notice that the generality is really
    just the ability to prove properties of proofs of propositions. They
    are uninteresting because when we assume proof irrelevance, for any
    property <span class="inlinecode"><span class="id" title="var">P</span></span>, either all proofs have it or none has.

<div class="paragraph"> </div>

    However, what if we don't assume proof irrelevance? Even though Coq
    is not proof irrelevant by default — we saw we have to explicitly
    assume irrelevance if we want it — it is proof irrelevant at the
    philosophical level.

<div class="paragraph"> </div>

    This is because we can't use proofs to construct programs. We can only
    use proofs to construct other proofs and, as we saw, when it comes to
    proofs the only thing that matters is whether they exist or not. In
    other words, Coq's philosophical proof irrelevance comes from the fact
    that it was designed to allow the actual proof irrelevance.

<div class="paragraph"> </div>

    To sum it up: the mere ability to assume irrelevance makes investigating
    properties of proofs uninteresting and therefore we are not interested
    in having maximal induction principles generated for propositions by
    default. We instead prefer minimal principles. 
<div class="paragraph"> </div>

<a name="lab240"></a><h4 class="section">Exercise (medium)</h4>

<div class="paragraph"> </div>

 Come up with a (metatheoretical) algorithm that can derive a minimal
    principle from a maximal one. Start by comparing maximal and minimal
    principles for some types other than <span class="inlinecode"><span class="id" title="var">prod</span></span> and <span class="inlinecode"><span class="id" title="var">sum</span></span>. Make sure it
    also works for indexed families.

<div class="paragraph"> </div>

    Do you now understand why the induction principle for <span class="inlinecode"><span class="id" title="var">le</span></span> looks the
    way it does? 
<div class="paragraph"> </div>

<a name="lab241"></a><h1 class="section">Mutual induction</h1>

<div class="paragraph"> </div>

 There's one more kind of induction we haven't covered yet: mutual
    induction. It is a very straightforward generalization of ordinary
    induction.

<div class="paragraph"> </div>

    When we define and inductive type (or an inductive family), we can
    make references to everything we have defined before and also to the
    thing we are currently defining. But we are defining only one thing
    at time. Recall the definition of <span class="inlinecode"><span class="id" title="var">even</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="Seminar.html#even"><span class="id" title="inductive">even</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;even&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;even0&nbsp;:&nbsp;even&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;evenSS&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;even&nbsp;n&nbsp;-&gt;&nbsp;even&nbsp;(S&nbsp;(S&nbsp;n))&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
We have a predicate for even numbers, but what about odd numbers? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="odd"><span class="id" title="inductive">odd</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="odd1"><span class="id" title="constructor">odd1</span></a> : <a class="idref" href="Seminar.html#odd"><span class="id" title="inductive">odd</span></a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="oddSS"><span class="id" title="constructor">oddSS</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#odd"><span class="id" title="inductive">odd</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#odd"><span class="id" title="inductive">odd</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>)).<br/>

<br/>
</div>

<div class="doc">
Looks fine. These definitions say that an even number is either zero
    or <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, where <span class="inlinecode"><span class="id" title="var">n</span></span> is even and that an odd number is either one or
    <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, where <span class="inlinecode"><span class="id" title="var">n</span></span> is odd.

<div class="paragraph"> </div>

    In English we can give a different, but equivalent definition of both
    even and odd numbers at once:
<ul class="doclist">
<li> 0 is even

</li>
<li> if n is even, then n + 1 is odd

</li>
<li> if n is odd, then n + 1 is even 
</li>
</ul>

<div class="paragraph"> </div>

 In the above paragraph, we defined evenness and oddness not separately,
    but together. This kind of definition is not specific to English (or any
    other natural language for that matter) — it is also possible to use it
    in Coq and it's called mutual induction. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="even'"><span class="id" title="inductive">even'</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="even'_0"><span class="id" title="constructor">even'_0</span></a> : <a class="idref" href="Seminar.html#even'"><span class="id" title="inductive">even'</span></a> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="even'_S"><span class="id" title="constructor">even'_S</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#odd'"><span class="id" title="inductive">odd'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#even'"><span class="id" title="inductive">even'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>)<br/>
<br/>
<span class="id" title="keyword">with</span> <a name="odd'"><span class="id" title="inductive">odd'</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="odd'_S"><span class="id" title="constructor">odd'_S</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#even'"><span class="id" title="inductive">even'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#odd'"><span class="id" title="inductive">odd'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>).<br/>

<br/>
</div>

<div class="doc">
In definitions by mutual induction the first definition is introduced
    by the keyword <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> and each subsequent one by the keyword <span class="inlinecode"><span class="id" title="keyword">with</span></span>.
    The dot we have to put only after the last definition finishes. It's
    just like the ordinary <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> definitions, but in the constructors
    of a type <span class="inlinecode"><span class="id" title="var">T</span></span> we can reference all the other types that we are defining
    simultaneously.

<div class="paragraph"> </div>

    The inductive definition of <span class="inlinecode"><span class="id" title="var">even'</span></span> and <span class="inlinecode"><span class="id" title="var">odd'</span></span> mimics what we have seen
    above (we just have to call our predicates <span class="inlinecode"><span class="id" title="var">even'</span></span> and <span class="inlinecode"><span class="id" title="var">odd'</span></span> because
    the names <span class="inlinecode"><span class="id" title="var">even</span></span> and <span class="inlinecode"><span class="id" title="var">odd</span></span> are already taken).

<div class="paragraph"> </div>

    Let's see how good this definition is when compared to the previous
    non-inductive definitions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="even_2n"><span class="id" title="lemma">even_2n</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#even"><span class="id" title="inductive">even</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="odd_2n_1"><span class="id" title="lemma">odd_2n_1</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#odd"><span class="id" title="inductive">odd</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1.<br/>

<br/>
</div>

<div class="doc">
The ordinary ones are easy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="even'_2n"><span class="id" title="lemma">even'_2n</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#even'"><span class="id" title="inductive">even'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 0. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
This proof attempt fails because we lack the necessary inductive
    hypothesis saying something alone the lines of
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">odd'</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">k</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>. Let's
    try to prove this as a theorem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="odd'_2n_1"><span class="id" title="lemma">odd'_2n_1</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#odd'"><span class="id" title="inductive">odd'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 0. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
We have the same problem here. An induction hypothesis is missing that
    would look just like the theorem <span class="inlinecode"><span class="id" title="var">even'_2n</span></span> we wanted to prove above.
    So, if the induction doesn't work as well as we would like it to, let's
    check the induction principles of <span class="inlinecode"><span class="id" title="var">even'</span></span> and <span class="inlinecode"><span class="id" title="var">odd'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#even'_ind"><span class="id" title="definition">even'_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even'_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;odd'&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;even'&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
A careful glance reveals that there's no induction in this induction
    principle! If you check <span class="inlinecode"><span class="id" title="var">odd'_ind</span></span>, you will see the same thing: no
    induction there.

<div class="paragraph"> </div>

    This doesn't have any deep philosophical reasons. It's just that for
    some mystical reason Coq by default decides to generate nonmutual
    induction principles even for mutually inductive types. We can easily
    fix it. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Scheme</span> <a name="even'_odd'_ind"><span class="id" title="definition">even'_odd'_ind</span></a> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <a class="idref" href="Seminar.html#even'"><span class="id" title="inductive">even'</span></a> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Prop</span><br/>
<span class="id" title="keyword">with</span> <a name="odd'_even'_ind"><span class="id" title="definition">odd'_even'_ind</span></a> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <a class="idref" href="Seminar.html#odd'"><span class="id" title="inductive">odd'</span></a> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#even'_odd'_ind"><span class="id" title="definition">even'_odd'_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even'_odd'_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;even'&nbsp;n&nbsp;-&gt;&nbsp;Prop)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P0&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;odd'&nbsp;n&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;even'_0&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(o&nbsp;:&nbsp;odd'&nbsp;n),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P0&nbsp;n&nbsp;o&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n)&nbsp;(even'_S&nbsp;n&nbsp;o))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(e&nbsp;:&nbsp;even'&nbsp;n),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;n&nbsp;e&nbsp;-&gt;&nbsp;P0&nbsp;(S&nbsp;n)&nbsp;(odd'_S&nbsp;n&nbsp;e))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(e&nbsp;:&nbsp;even'&nbsp;n),&nbsp;P&nbsp;n&nbsp;e&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
This is exactly what we need. First, we have two predicates, <span class="inlinecode"><span class="id" title="var">P</span></span> and <span class="inlinecode"><span class="id" title="var">P0</span></span>.
    <span class="inlinecode"><span class="id" title="var">P</span></span> is the one we will be proving. It will be automatically inferred by
    Coq. <span class="inlinecode"><span class="id" title="var">P0</span></span> is the induction hypothesis that was missing in our last attempt
    There are three cases in the principle. This is because our definition had
    three constructors: two for <span class="inlinecode"><span class="id" title="var">even'</span></span> and one for <span class="inlinecode"><span class="id" title="var">odd'</span></span>.

<div class="paragraph"> </div>

    Notice that this principle is maximal. There's also the other principle
    — <span class="inlinecode"><span class="id" title="var">odd'_even'_ind</span></span>. It's there because when we define stuff by mutual
    induction, we have to mutually generate the induction principles too.

<div class="paragraph"> </div>

    Let's see how to use this principle. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="even'_2n"><span class="id" title="lemma">even'_2n</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#even'"><span class="id" title="inductive">even'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1 <span class="id" title="keyword">using</span> <a class="idref" href="Seminar.html#even'_odd'_ind"><span class="id" title="definition">even'_odd'_ind</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">with</span> (<span class="id" title="var">P0</span> := <span class="id" title="keyword">fun</span> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<span class="id" title="var">H</span> : <a class="idref" href="Seminar.html#odd'"><span class="id" title="inductive">odd'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 0. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">IHeven'</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">k</span> <span class="id" title="var">IH</span>]. <span class="id" title="tactic">exists</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">k</span>). <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">IHeven'</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">k</span> <span class="id" title="var">IH</span>]. <span class="id" title="tactic">exists</span> <span class="id" title="var">k</span>. <span class="id" title="tactic">omega</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It was much easier this time. To prove the theorem we use <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode">1</span>
    as before, but this time we add the clause <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">even'_odd'_ind</span></span> which
    tells Coq which induction principle to use. Then we use the <span class="inlinecode"><span class="id" title="keyword">with</span></span>
    clause to tell Coq how <span class="inlinecode"><span class="id" title="var">P0</span></span> should look like. We don't have to tell it
    about <span class="inlinecode"><span class="id" title="var">P</span></span> because it can infer it from the goal.

<div class="paragraph"> </div>

    Note that the <span class="inlinecode"><span class="id" title="keyword">with</span></span> keyword here has nothing to do with the <span class="inlinecode"><span class="id" title="keyword">with</span></span> we
    used in the inductive definition. It's just a coincidence of names. We
    have three cases that we solve easily. This shape of induction was what
    we expected at the very beginnig. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="odd'_2n_1"><span class="id" title="lemma">odd'_2n_1</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#odd'"><span class="id" title="inductive">odd'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1.<br/>

<br/>
</div>

<div class="doc">
The second proof is quite similar. But how does the two proofs compare?
    The ones for <span class="inlinecode"><span class="id" title="var">even</span></span> and <span class="inlinecode"><span class="id" title="var">odd</span></span> were 14 lines long in total (at least for
    me) and weren't too hard. Quite the opposite. The ones for <span class="inlinecode"><span class="id" title="var">even'</span></span> and
    <span class="inlinecode"><span class="id" title="var">odd'</span></span> were 18 lines long in total and we're harder to carry out: we
    had to manually specify the predicates Coq couldn't infer from context.

<div class="paragraph"> </div>

    So, is mutual induction useless? Not really. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="even'_2n'"><span class="id" title="lemma">even'_2n'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#even'"><span class="id" title="inductive">even'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a><br/>
<span class="id" title="keyword">with</span> <a name="odd'_2n_1'"><span class="id" title="lemma">odd'_2n_1'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#odd'"><span class="id" title="inductive">odd'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 0. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">odd'_2n_1'</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">k</span> <span class="id" title="var">IH</span>]. <span class="id" title="tactic">exists</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">k</span>). <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">even'_2n'</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">k</span> <span class="id" title="var">IH</span>]. <span class="id" title="tactic">exists</span> <span class="id" title="var">k</span>. <span class="id" title="tactic">omega</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The above alternative proof is only 11 lines long, which is better
    than the proofs for <span class="inlinecode"><span class="id" title="var">even</span></span> and <span class="inlinecode"><span class="id" title="var">odd</span></span> (but don't take it too seriously
    — proof length measured in lines of code need not be a good measure of
    easiness).

<div class="paragraph"> </div>

    These theorems are similar to the previous ones, but this time we stated
    and proved both of them at once. We also didn't need to use <span class="inlinecode"><span class="id" title="tactic">induction</span></span> 
    (and thus write any predicates explicitly in any place other than the
    theorem statement). This is because using the command <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> in the
    above way adds the inductive hypotheses we need to our context.

<div class="paragraph"> </div>

    We then proceed as above, but with <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> inside of induction.
    We also have to write a bit more in order to destruct our inductive
    hypotheses, but that's not a problem.

<div class="paragraph"> </div>

    So, is mutual induction useful, if it can give us shorter proofs? I don't
    know a good answer to this question. I can only tell you that I haven't
    seen it used too often. 
<div class="paragraph"> </div>

<a name="lab242"></a><h1 class="section">Custom induction principles</h1>

<div class="paragraph"> </div>

 We saw in the previous sections how induction principles look like and
    that Coq generates us one (or rather, three) for every inductive
    definition we make. We also saw that these principles can be derived
    by hand.

<div class="paragraph"> </div>

    Another fact is that these principles are not unique — quite the
    opposite. Usually there can be many different principles for each
    type: for dependent and non-dependent functions, for true induction
    or just for case analysis, they can even differ by their order of
    taking arguments.

<div class="paragraph"> </div>

    But even more is possible. Induction principles don't need, in general,
    to be associated with any particular type. We can thus have principles
    for proving facts about relations of type <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>
    or proving properties of the function <span class="inlinecode"><span class="id" title="var">plus</span></span>.

<div class="paragraph"> </div>

    We will call the principles Coq generates us "standard" and the ones we
    write ourselves "non-standard" or "custom". In this subchapter we will
    learn to devise and implement non-standard principles and to use them
    with standard tactics like <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" title="tactic">induction</span></span>.

<div class="paragraph"> </div>

    We will also learn about the basics of functional induction, a powerful
    tool for proving properties of recursive functions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="bool_ind'"><span class="id" title="definition">bool_ind'</span></a><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">f</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>) (<span class="id" title="var">t</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>) (<span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> =&gt; <a class="idref" href="Seminar.html#t"><span class="id" title="variable">t</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> =&gt; <a class="idref" href="Seminar.html#f"><span class="id" title="variable">f</span></a><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
This is a nonstandard case analysis principle for <span class="inlinecode"><span class="id" title="var">bool</span></span>. The only thing
    that makes it different from the principle <span class="inlinecode"><span class="id" title="var">bool_ind</span></span> is the order of
    arguments: it takes  that of type <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> first, whereas <span class="inlinecode"><span class="id" title="var">bool_ind</span></span>'s
    first argument has type <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>. It is obvious that it is correct,
    because we can prove <span class="inlinecode"><span class="id" title="var">P</span></span> for <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">false</span></span> in any order we like. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="bool_ind''"><span class="id" title="definition">bool_ind''</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>), <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We can also use the tactic language to simply prove the principle as a
    theorem. This doesn't make much difference now, but for more complex
    principles it is often easier to establish them that way.

<div class="paragraph"> </div>

    But how do we use such nonstndard principles? Standard case analysis on
    the term <span class="inlinecode"><span class="id" title="var">t</span></span> is usually performed by using the tactic <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>. Our
    nonstandard one can be likewise performed with the tactic <span class="inlinecode"><span class="id" title="var">destrct</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>
    <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">our_principle</span></span>. Of course it can also be used directly with <span class="inlinecode"><span class="id" title="tactic">apply</span></span>,
    but we already saw that it isn't the best possibility.

<div class="paragraph"> </div>

    Let's see both principles in action. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="negb_involutive''"><span class="id" title="lemma">negb_involutive''</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>. <span class="id" title="var">all</span>: <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span> <span class="id" title="keyword">using</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool_ind"><span class="id" title="definition">bool_ind</span></a>; <span class="id" title="var">cbn</span>. <span class="id" title="var">all</span>: <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span> <span class="id" title="keyword">using</span> <a class="idref" href="Seminar.html#bool_ind'"><span class="id" title="definition">bool_ind'</span></a>; <span class="id" title="var">cbn</span>. <span class="id" title="var">all</span>: <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span> <span class="id" title="keyword">using</span> <a class="idref" href="Seminar.html#bool_ind''"><span class="id" title="definition">bool_ind''</span></a>; <span class="id" title="var">cbn</span>. <span class="id" title="var">all</span>: <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Here we see that the tactic <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> is in fact equivalent to
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> <span class="inlinecode"><span class="id" title="var">bool_ind</span></span>, in which the standard induction principle
    is named explicitly. In these two equivalent cases, our first subgoal
    is <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> and the second is <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span>. On the contrary,
    when we use one of our custom principles, our first goal is of the form
    <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">false</span></span> and the second is <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>.

<div class="paragraph"> </div>

    Let's see a custom principle for <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="nat_ind_2"><span class="id" title="definition">nat_ind_2</span></a><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">H0</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> 0) (<span class="id" title="var">H1</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> 1)<br/>
&nbsp;&nbsp;(<span class="id" title="var">HSS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>)))<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <a class="idref" href="Seminar.html#H0"><span class="id" title="variable">H0</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; <a class="idref" href="Seminar.html#H1"><span class="id" title="variable">H1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span>) =&gt; <a class="idref" href="Seminar.html#HSS"><span class="id" title="variable">HSS</span></a> <span class="id" title="var">n'</span> (<a class="idref" href="Seminar.html#nat_ind_2"><span class="id" title="definition">nat_ind_2</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#H0"><span class="id" title="variable">H0</span></a> <a class="idref" href="Seminar.html#H1"><span class="id" title="variable">H1</span></a> <a class="idref" href="Seminar.html#HSS"><span class="id" title="variable">HSS</span></a> <span class="id" title="var">n'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="nat_ind_2'"><span class="id" title="definition">nat_ind_2'</span></a><br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">H0</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> 0) (<span class="id" title="var">H1</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> 1)<br/>
&nbsp;&nbsp;(<span class="id" title="var">HSS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>)))<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| [| <span class="id" title="var">n'</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">HSS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">nat_ind_2'</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
In case of <span class="inlinecode"><span class="id" title="var">nat</span></span>, we can customize our induction principle more than
    by just changing the order of the arguments. For example, we can do
    "induction by 2's". This means that rather than starting at <span class="inlinecode">0</span> and
    applying <span class="inlinecode"><span class="id" title="var">S</span></span> once in each step, we have two base cases, <span class="inlinecode">0</span> and <span class="inlinecode">1</span>,
    and we apply <span class="inlinecode"><span class="id" title="var">S</span></span> twice in each step.

<div class="paragraph"> </div>

    This principle is correct because we can generate all natural numbers
    this way: starting from <span class="inlinecode">0</span> and applying <span class="inlinecode"><span class="id" title="var">S</span></span> twice in each step we
    can generate all even numbers, whereas starting from <span class="inlinecode">1</span> and applying
    <span class="inlinecode"><span class="id" title="var">S</span></span> twice in each step we can generate all odd numbers. Because each
    natural number is either even or odd, we see that our custom principle
    covers all cases.

<div class="paragraph"> </div>

    We also see that when our principles have recursion, defining them with
    tactics is easier than without tactics. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Div2.html#"><span class="id" title="library">Div2</span></a>.<br/>

<br/>
</div>

<div class="doc">
Div2 is a module that contains the function <span class="inlinecode"><span class="id" title="var">div2</span></span>, which performs
    integer division by two. Here is its definition: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Div2.html#div2"><span class="id" title="abbreviation">div2</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;fix&nbsp;div2&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;:&nbsp;nat&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1&nbsp;=&gt;&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;(S&nbsp;n')&nbsp;=&gt;&nbsp;S&nbsp;(div2&nbsp;n')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Note: we use <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span> instead of <span class="inlinecode"><span class="id" title="keyword">Print</span></span> because <span class="inlinecode"><span class="id" title="var">div2</span></span> is only
    a notation.

<div class="paragraph"> </div>

    We see that <span class="inlinecode"><span class="id" title="var">div2</span></span> is defined differently than <span class="inlinecode"><span class="id" title="var">plus</span></span> or <span class="inlinecode"><span class="id" title="var">mult</span></span>. These
    two have just two cases in their respective <span class="inlinecode"><span class="id" title="keyword">match</span></span>es: <span class="inlinecode">0</span> and <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>,
    whereas <span class="inlinecode"><span class="id" title="var">div2</span></span> has <span class="inlinecode">0</span>, <span class="inlinecode">1</span> and <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>. Let's try proving some
    theorem.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="lt_div2'"><span class="id" title="lemma">lt_div2'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Div2.html#div2"><span class="id" title="abbreviation">div2</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n'</span>; <span class="id" title="var">cbn</span> <span class="id" title="keyword">in</span> *; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| | <span class="id" title="var">n'</span>] <span class="id" title="keyword">using</span> <a class="idref" href="Seminar.html#nat_ind_2"><span class="id" title="definition">nat_ind_2</span></a>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n'</span> <span class="id" title="keyword">as</span> [| [| <span class="id" title="var">n''</span>]]; <span class="id" title="var">cbn</span> <span class="id" title="keyword">in</span> *; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#lt"><span class="id" title="definition">lt</span></a> <span class="id" title="keyword">in</span> *. <span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Le.html#le_n_S"><span class="id" title="lemma">le_n_S</span></a>. <span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#le_S"><span class="id" title="constructor">le_S</span></a>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHn'</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Le.html#le_n_S"><span class="id" title="lemma">le_n_S</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Le.html#le_0_n"><span class="id" title="abbreviation">le_0_n</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Trying induction on <span class="inlinecode"><span class="id" title="var">n</span></span> using the standard induction principle doesn't
    help us much. A kind of a "mismatch" occurs: when we have <span class="inlinecode"><span class="id" title="var">n'</span></span> in the
    hypothesis, we have <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">...</span> in the goal and vice versa. This
    is because the shape of induction in the standard principle is different
    from the shape of recursion that was used to define <span class="inlinecode"><span class="id" title="var">div2</span></span>. If we use
    the custom principle, we get rid of that problem and we are able to prove
    the goal easily.

<div class="paragraph"> </div>

    So, our nonstandard principles are no different from the standard ones,
    we just have to create them manually and type a bit more in order to
    use them... or do we? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#"><span class="id" title="library">List</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="swap_blocks"><span class="id" title="definition">swap_blocks</span></a> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">]</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="Seminar.html#swap_blocks"><span class="id" title="definition">swap_blocks</span></a> <span class="id" title="var">t</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Compute</span> <a class="idref" href="Seminar.html#swap_blocks"><span class="id" title="definition">swap_blocks</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#f83abbde7679bdbfec6afddd39d41e15"><span class="id" title="notation">[</span></a>1<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#f83abbde7679bdbfec6afddd39d41e15"><span class="id" title="notation">;</span></a> 2<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#f83abbde7679bdbfec6afddd39d41e15"><span class="id" title="notation">;</span></a> 3<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#f83abbde7679bdbfec6afddd39d41e15"><span class="id" title="notation">;</span></a> 4<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#f83abbde7679bdbfec6afddd39d41e15"><span class="id" title="notation">;</span></a> 5<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#f83abbde7679bdbfec6afddd39d41e15"><span class="id" title="notation">]</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;<span class="inlinecode">[2;</span> <span class="inlinecode">1;</span> <span class="inlinecode">4;</span> <span class="inlinecode">3;</span> <span class="inlinecode">5]</span>&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Note: <span class="inlinecode"><span class="id" title="keyword">Compute</span></span> is equivalent to <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span>, but shorter.

<div class="paragraph"> </div>

    This is a function that swaps places of adjacent elements in a list.
    It is easy to see that it is an involution, which means that applying
    it twice gives us the original list. Let's try to prove that. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="swap_blocks_involutive"><span class="id" title="lemma">swap_blocks_involutive</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#swap_blocks"><span class="id" title="definition">swap_blocks</span></a> (<a class="idref" href="Seminar.html#swap_blocks"><span class="id" title="definition">swap_blocks</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">h</span> <span class="id" title="var">t</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">t</span>; <span class="id" title="var">cbn</span> <span class="id" title="keyword">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
We see that we have the same problem we had with <span class="inlinecode"><span class="id" title="var">div2</span></span>. If we have <span class="inlinecode"><span class="id" title="var">t</span></span>
    in the induction hypothesis, then it's going to appear inside a <span class="inlinecode"><span class="id" title="keyword">match</span></span>
    in the goal. We could prove this theorem by writing a custom induction
    principle for lists, but what if we are too lazy to do that?

<div class="paragraph"> </div>

    Don't worry, there's a solution called <span class="inlinecode"><span class="id" title="var">functional</span></span> <span class="inlinecode"><span class="id" title="tactic">induction</span></span>. It is a
    tactic which performs induction that fits the recursive structure of our
    function perfectly. We can use it like this: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Functional Scheme</span> <span class="id" title="var">swap_blocks_ind</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">swap_blocks</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#swap_blocks_ind"><span class="id" title="lemma">swap_blocks_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;swap_blocks_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(P&nbsp;:&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;l&nbsp;:&nbsp;list&nbsp;A,&nbsp;l&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;-&gt;&nbsp;P&nbsp;<span class="inlinecode">[]</span>&nbsp;<span class="inlinecode">[]</span>)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(l&nbsp;:&nbsp;list&nbsp;A)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(l0&nbsp;:&nbsp;list&nbsp;A),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l&nbsp;=&nbsp;x&nbsp;::&nbsp;l0&nbsp;-&gt;&nbsp;l0&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;-&gt;&nbsp;P&nbsp;<span class="inlinecode">[<span class="id" title="var">x</span>]</span>&nbsp;<span class="inlinecode">[<span class="id" title="var">x</span>]</span>)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(l&nbsp;:&nbsp;list&nbsp;A)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(l0&nbsp;:&nbsp;list&nbsp;A),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l&nbsp;=&nbsp;x&nbsp;::&nbsp;l0&nbsp;-&gt;&nbsp;forall&nbsp;(y&nbsp;:&nbsp;A)&nbsp;(t&nbsp;:&nbsp;list&nbsp;A),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l0&nbsp;=&nbsp;y&nbsp;::&nbsp;t&nbsp;-&gt;&nbsp;P&nbsp;t&nbsp;(swap_blocks&nbsp;t)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;(x&nbsp;::&nbsp;y&nbsp;::&nbsp;t)&nbsp;(y&nbsp;::&nbsp;x&nbsp;::&nbsp;swap_blocks&nbsp;t))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;l&nbsp;:&nbsp;list&nbsp;A,&nbsp;P&nbsp;l&nbsp;(swap_blocks&nbsp;l)&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The command <span class="inlinecode"><span class="id" title="var">Functional</span></span> <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> generates an induction principle that
    fits the shape of our function's recursion. The principle may look
    intimidating, but if you take a closer look, it just repeats the cases
    found in the <span class="inlinecode"><span class="id" title="keyword">match</span></span> in <span class="inlinecode"><span class="id" title="var">swap_blocks</span></span>' definition. We can use it like
    this: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="swap_blocks_involutive"><span class="id" title="lemma">swap_blocks_involutive</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#swap_blocks"><span class="id" title="definition">swap_blocks</span></a> (<a class="idref" href="Seminar.html#swap_blocks"><span class="id" title="definition">swap_blocks</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">functional</span> <span class="id" title="tactic">induction</span> @<a class="idref" href="Seminar.html#swap_blocks"><span class="id" title="definition">swap_blocks</span></a> <span class="id" title="var">A</span> <span class="id" title="var">l</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHl0</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A piece of cake, wasn't it? But we can be even more lazy: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Function</span> <span class="id" title="var">swap_blocks'</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">]</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">[</span></a><span class="id" title="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">x</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="Seminar.html#swap_blocks'"><span class="id" title="definition">swap_blocks'</span></a> <span class="id" title="var">t</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="swap_blocks'_involutive"><span class="id" title="lemma">swap_blocks'_involutive</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#swap_blocks'"><span class="id" title="definition">swap_blocks'</span></a> (<a class="idref" href="Seminar.html#swap_blocks'"><span class="id" title="definition">swap_blocks'</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">functional</span> <span class="id" title="tactic">induction</span> @<a class="idref" href="Seminar.html#swap_blocks'"><span class="id" title="definition">swap_blocks'</span></a> <span class="id" title="var">A</span> <span class="id" title="var">l</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHl0</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We can replace the command <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> with <span class="inlinecode"><span class="id" title="keyword">Function</span></span> to make Coq
    generate us the same principle that the <span class="inlinecode"><span class="id" title="var">Functional</span></span> <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> command
    (and many other things, too). 
<div class="paragraph"> </div>

<a name="lab243"></a><h4 class="section">Exercise (easy)</h4>

<div class="paragraph"> </div>

 Prove the following nonstandard induction principles for lists. What
    do they mean? Give an informal description. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="list_ind_rev"><span class="id" title="lemma">list_ind_rev</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">Hnil</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Hsnoc</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">[</span></a><a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">]</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="list_ind_app"><span class="id" title="lemma">list_ind_app</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Hnil</span> : <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a>) (<span class="id" title="var">Hsingl</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">[</span></a><a class="idref" href="Seminar.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">]</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">IH</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> <span class="id" title="var">l'</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#l'"><span class="id" title="variable">l'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Seminar.html#l'"><span class="id" title="variable">l'</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab244"></a><h4 class="section">Exercise (easy)</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Function</span> <span class="id" title="var">take</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>, <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0, <span class="id" title="var">_</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span>, <span class="id" title="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="Seminar.html#take"><span class="id" title="definition">take</span></a> <span class="id" title="var">n'</span> <span class="id" title="var">t</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">take</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> takes at most <span class="inlinecode"><span class="id" title="var">n</span></span> initial elements from the list <span class="inlinecode"><span class="id" title="var">l</span></span>.
    Prove some of its properties using standard induction principles
    and then reprove them using functional induction. Which method is
    easier?

<div class="paragraph"> </div>

    If you are not lazy, write a custom induction principle that would
    fit <span class="inlinecode"><span class="id" title="var">take</span></span>'s recursion structure. Which method requires least work
    to get things done? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="take_length'"><span class="id" title="lemma">take_length'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#length"><span class="id" title="definition">length</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#9b077c369e19739ef880736ba34623ff"><span class="id" title="notation">&lt;=</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#take"><span class="id" title="definition">take</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="length_take"><span class="id" title="lemma">length_take</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#9b077c369e19739ef880736ba34623ff"><span class="id" title="notation">&lt;=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#length"><span class="id" title="definition">length</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#length"><span class="id" title="definition">length</span></a> (<a class="idref" href="Seminar.html#take"><span class="id" title="definition">take</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="length_take'"><span class="id" title="lemma">length_take'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#length"><span class="id" title="definition">length</span></a> (<a class="idref" href="Seminar.html#take"><span class="id" title="definition">take</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#9b077c369e19739ef880736ba34623ff"><span class="id" title="notation">&lt;=</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
<a name="lab245"></a><h1 class="section">Case analysis on non-inductive types</h1>

<div class="paragraph"> </div>

 Two subchapters ago we have said the we can prove that all elements of
    a finite type have some property by using case analysis, but actually
    we only did this for an inductive type.

<div class="paragraph"> </div>

    In this subchapter, we will see that we can do case analysis on a finite
    type even when it is not defined inductively (we won't define "finite"
    formally here). But before we do that, we have to discuss the equality
    of functions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="S_plus_1_l_eq"><span class="id" title="lemma">S_plus_1_l_eq</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; 1 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
By default, <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> holds only when <span class="inlinecode"><span class="id" title="var">x</span></span> and <span class="inlinecode"><span class="id" title="var">y</span></span> are convertible, meaning
    both reduce to the same thing when computed. This is a very weak notion
    of equality that is often not satisfying. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="S_plus_1_r_eq"><span class="id" title="lemma">S_plus_1_r_eq</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="var">Fail</span> <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="S_plus_1_r_ext_eq"><span class="id" title="lemma">S_plus_1_r_ext_eq</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#plus_n_Sm"><span class="id" title="lemma">plus_n_Sm</span></a>, &lt;- <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#plus_n_O"><span class="id" title="lemma">plus_n_O</span></a>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
When trying to prove that <span class="inlinecode"><span class="id" title="var">S</span></span> equals <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>, Coq tells
    us it is 'Unable to unify "n + 1" with "S n"'. These terms are not
    not convertible terms and thus the two functions can't be proven equal.
    This is very disappointing because we can easily show that they compute
    they very same thing.

<div class="paragraph"> </div>

    Here comes our saviour: the Axiom of Functional Extensionality. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.FunctionalExtensionality.html#"><span class="id" title="library">FunctionalExtensionality</span></a>.<br/>

<br/>
<span class="id" title="keyword">Check</span> @<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.FunctionalExtensionality.html#functional_extensionality"><span class="id" title="lemma">functional_extensionality</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;@functional_extensionality&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(A&nbsp;B&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;g&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x&nbsp;:&nbsp;A,&nbsp;f&nbsp;x&nbsp;=&nbsp;g&nbsp;x)&nbsp;-&gt;&nbsp;f&nbsp;=&nbsp;g&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
This axiom asserts that if two functions compute the same value for
    each argument, then they are equal. This axiom has been proven
    consistent with Coq's logic, so we can use it safely. Note: there
    also is a version of this axiom for dependent functions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="S_plus_1_r_eq"><span class="id" title="lemma">S_plus_1_r_eq</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> =&gt; <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">extensionality</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Seminar.html#S_plus_1_r_ext_eq"><span class="id" title="lemma">S_plus_1_r_ext_eq</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
If we need to prove two functions equal, we can use the <span class="inlinecode"><span class="id" title="tactic">extensionality</span></span>
    tactic, which applies the axiom for us. We are then left to prove that
    both functions compute the same thing.

<div class="paragraph"> </div>

    One last thing we need is to define the constant function: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="const"><span class="id" title="definition">const</span></a> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">b</span> : <a class="idref" href="Seminar.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">_</span> : <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="Seminar.html#B"><span class="id" title="variable">B</span></a> := <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>.<br/>

<br/>
</div>

<div class="doc">
Armed with the axiom and this definition, we can proceed to the clou
    of this subchapter: we will establish a case analysis principle for
    boolean functions.

<div class="paragraph"> </div>

    How many ways are there to assign two values to two arguments? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="bool_fun_char"><span class="id" title="lemma">bool_fun_char</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> @<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#id"><span class="id" title="definition">id</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="Seminar.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="Seminar.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="Seminar.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">case_eq</span> (<span class="id" title="var">f</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>); <span class="id" title="var">case_eq</span> (<span class="id" title="var">f</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>); <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>; <span class="id" title="tactic">right</span>; <span class="id" title="tactic">left</span>. <span class="id" title="tactic">extensionality</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>. <span class="id" title="tactic">extensionality</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>; <span class="id" title="tactic">left</span>. <span class="id" title="tactic">extensionality</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">do</span> 3 <span class="id" title="tactic">right</span>. <span class="id" title="tactic">extensionality</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Well, you guessed it right — there are only four: identity, negation
    and two constant ones. We can prove this easily by looking at the
    values of <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="bool_fun_ind"><span class="id" title="lemma">bool_fun_ind</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> (@<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#id"><span class="id" title="definition">id</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Seminar.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="Seminar.html#const"><span class="id" title="definition">const</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#f"><span class="id" title="variable">f</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> (<a class="idref" href="Seminar.html#bool_fun_char"><span class="id" title="lemma">bool_fun_char</span></a> <span class="id" title="var">f</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">H'</span> | [<span class="id" title="var">H'</span> | [<span class="id" title="var">H'</span> | <span class="id" title="var">H'</span>]]];<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The last thing left is to pack the above lemma into a case analysis
    principle. We will call it <span class="inlinecode"><span class="id" title="var">bool_fun_ind</span></span>, even though it has nothing
    to do with induction.

<div class="paragraph"> </div>

    This is it! We can now do case analysis when proving properties of
    boolean functions. But there's a problem: I can't think of any useful
    property of boolean functions that can be proved by case analysis but
    not with some other method. 
<div class="paragraph"> </div>

<a name="lab246"></a><h4 class="section">Exercise (medium)</h4>

<div class="paragraph"> </div>

 Try to come up with such a property. 
<div class="paragraph"> </div>

<a name="lab247"></a><h1 class="section">Functions and functional relations</h1>

<div class="paragraph"> </div>

 After you have learned about the commands <span class="inlinecode"><span class="id" title="keyword">Function</span></span> and <span class="inlinecode"><span class="id" title="var">Functional</span></span>
    <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span>, you may be left wondering, how they work. We will try to
    answer this question now, but it will be easier if we first see how
    we can use inductive families to represent functions.

<div class="paragraph"> </div>

    First we have to explicitly spell out what a function is. There are two
    widely used definitions:
<ul class="doclist">
<li> the computer scientist's one, which equates functions with algorithms.
      They are always computable, which means we can implement and run them
      on a computer to get the result. Coq functions are of this kind.

</li>
<li> the mathematician's one, which equates functions with functional
      relations, which are relations with additional properties. These need
      not be computable. 
</li>
</ul>

<div class="paragraph"> </div>

 The second meaning of "function" stems from set theory and is widely
    used in mathematics. Here a function is synonyomous with its graph.
    A graph of a function is a relation that relates the function's inputs
    to its output.

<div class="paragraph"> </div>

    Let's see an example underlining the difference between these two. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Function</span> <span class="id" title="var">div2</span> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span>) =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <span class="id" title="var">n'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Note: we use <span class="inlinecode"><span class="id" title="keyword">Function</span></span> only to get the functional induction principle
    so that we will later be able to compare it to our own.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">div2</span></span> is an ordinary structurally recursive function. Nothing fancy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="div2_rel"><span class="id" title="inductive">div2_rel</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="div2_rel_even"><span class="id" title="constructor">div2_rel_even</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#div2_rel"><span class="id" title="inductive">div2_rel</span></a> (2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="div2_rel_odd"><span class="id" title="constructor">div2_rel_odd</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#div2_rel"><span class="id" title="inductive">div2_rel</span></a> (2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#697e4695610f677ae98a52af81f779d2"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1) <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">div2_rel</span></span> is an inductive relation defined like this:
<ul class="doclist">
<li> the result of dividing <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">n</span></span> by <span class="inlinecode">2</span> is <span class="inlinecode"><span class="id" title="var">n</span></span>

</li>
<li> the result of dividing <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> by <span class="inlinecode">2</span> is <span class="inlinecode"><span class="id" title="var">n</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 The difference is quite stark: the recursive one (<span class="inlinecode"><span class="id" title="var">div2</span></span>) tells us how
    to divide a number by two (how to compute the result). The inductive one
    (<span class="inlinecode"><span class="id" title="var">div2_rel</span></span>) tells us what is the relation between inputs and outputs of
    a function that divide its argument by two. Nonetheless these two
    formulations of division are somehow equivalent. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="div2_rel_SS"><span class="id" title="lemma">div2_rel_SS</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#div2_rel"><span class="id" title="inductive">div2_rel</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#div2_rel"><span class="id" title="inductive">div2_rel</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>)) (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>).<br/>

<br/>
</div>

<div class="doc">
This is just a lemma for the proper proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="div2_rel_correct"><span class="id" title="lemma">div2_rel_correct</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#div2_rel"><span class="id" title="inductive">div2_rel</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>.<br/>

<br/>
</div>

<div class="doc">
This theorem states that <span class="inlinecode"><span class="id" title="var">div2_rel</span></span> contains the graph of <span class="inlinecode"><span class="id" title="var">div2</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="div2_rel_complete"><span class="id" title="lemma">div2_rel_complete</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#div2_rel"><span class="id" title="inductive">div2_rel</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>.<br/>

<br/>
</div>

<div class="doc">
And this one says that the graph of <span class="inlinecode"><span class="id" title="var">div2</span></span> contains <span class="inlinecode"><span class="id" title="var">div2_rel</span></span>. Thus
    <span class="inlinecode"><span class="id" title="var">div2_rel</span></span> really is the graph of <span class="inlinecode"><span class="id" title="var">div2</span></span>. <span class="inlinecode"><span class="id" title="var">div2_rel</span></span> may also be
    thought of as a specification for <span class="inlinecode"><span class="id" title="var">div2</span></span>, but specifying functions
    isn't everything we can achieve using inductive relations. Another
    thing is specifying partial functions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="Zfact"><span class="id" title="module">Zfact</span></a>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.ZArith.html#"><span class="id" title="library">ZArith</span></a>.<br/>

<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">Z</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Zfact.Zfact"><span class="id" title="inductive">Zfact</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Zfact.Zfact_0"><span class="id" title="constructor">Zfact_0</span></a> : <a class="idref" href="Seminar.html#Zfact"><span class="id" title="inductive">Zfact</span></a> 0 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Zfact.Zfact_S"><span class="id" title="constructor">Zfact_S</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">k</span> <span class="id" title="var">r</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#Zfact"><span class="id" title="inductive">Zfact</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="Seminar.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#Zfact"><span class="id" title="inductive">Zfact</span></a> (<a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a3448b794f7a26d611ad36492b5d640b"><span class="id" title="notation">+</span></a> 1) (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#88e34ed7a73f02772126289867960764"><span class="id" title="notation">(</span></a><a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a3448b794f7a26d611ad36492b5d640b"><span class="id" title="notation">+</span></a> 1<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#88e34ed7a73f02772126289867960764"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#88e34ed7a73f02772126289867960764"><span class="id" title="notation">*</span></a> <a class="idref" href="Seminar.html#r"><span class="id" title="variable">r</span></a>).<br/>

<br/>
</div>

<div class="doc">
This looks like a specification for the factorial function. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Zfact.Zfact_nonneg"><span class="id" title="lemma">Zfact_nonneg</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#Zfact.Zfact"><span class="id" title="inductive">Zfact</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#Z.of_nat"><span class="id" title="definition">Z.of_nat</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#Z.of_nat"><span class="id" title="definition">Z.of_nat</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Factorial.html#fact"><span class="id" title="definition">fact</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>)).<br/>

<br/>
</div>

<div class="doc">
And indeed, for nonnegative integers it is exactly the factorial
    function. But what about the negative ones? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="Zfact.Zfact_neg"><span class="id" title="lemma">Zfact_neg</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a>, <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#273beba4f3453dbb29192b3ac740bb71"><span class="id" title="notation">&lt;</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a> <a class="idref" href="Seminar.html#Zfact.Zfact"><span class="id" title="inductive">Zfact</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a>.<br/>

<br/>
</div>

<div class="doc">
It turns out that if <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">0</span>, then it isn't related to any result at
    all and therefore this relation can't be a graph of any function that
    is definable in Coq. We may call this the "programming newbie's
    factorial".

<div class="paragraph"> </div>

    This example clearly shows that definitions by recursion and induction
    differ. The latter can describe more things than the former (another
    example would be nonterminating functions — something that's not there
    in Coq, but is very frequent in other programming languages), but this
    comes at the cost of computability — we can't compute with <span class="inlinecode"><span class="id" title="var">Zfact</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#Zfact"><span class="id" title="module">Zfact</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab248"></a><h4 class="section">Exercise (easy)</h4>

<div class="paragraph"> </div>

 Consider the following function on natural numbers:
<ul class="doclist">
<li> f(0) = 1

</li>
<li> f(1) = 1

</li>
<li> f(n) = f(n/2) if n is even

</li>
<li> f(n) = f(3n + 1) if n is odd 
</li>
</ul>

<div class="paragraph"> </div>

 Is this function definable in Coq? Implement it using recursion or
    induction, whichever is easier. Then show that f(42) = 1. Can you
    prove that f(n) = 1 for all n? 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Now that we know inductive relations can represent graphs of functions,
    we can ask ourselves: what's the point of it? And what does it have to
    do with functional induction? Well, it turns out that quite a lot...

<div class="paragraph"> </div>

    Consider this alternative definition of <span class="inlinecode"><span class="id" title="var">div2</span></span>'s graph. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="R_div2'"><span class="id" title="inductive">R_div2'</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="R_div2'_0"><span class="id" title="constructor">R_div2'_0</span></a> : <a class="idref" href="Seminar.html#R_div2'"><span class="id" title="inductive">R_div2'</span></a> 0 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="R_div2'_1"><span class="id" title="constructor">R_div2'_1</span></a> : <a class="idref" href="Seminar.html#R_div2'"><span class="id" title="inductive">R_div2'</span></a> 1 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="R_div2'_2"><span class="id" title="constructor">R_div2'_2</span></a> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">r</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#R_div2'"><span class="id" title="inductive">R_div2'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#R_div2'"><span class="id" title="inductive">R_div2'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>)) (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#r"><span class="id" title="variable">r</span></a>).<br/>

<br/>
</div>

<div class="doc">
Note: in the names of the following functions we utilize the naming
    conventions of <span class="inlinecode"><span class="id" title="keyword">Function</span></span> and <span class="inlinecode"><span class="id" title="var">Functional</span></span> <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span>, but add a <span class="inlinecode">'</span> at
    the end.

<div class="paragraph"> </div>

    No doubt this is the graph of <span class="inlinecode"><span class="id" title="var">div2</span></span>, because this definition follows
    precisely <span class="inlinecode"><span class="id" title="var">div2</span></span>'s definition: there's one constructor for each case
    in its pattern match. Therefore, unlike the original <span class="inlinecode"><span class="id" title="var">div2_rel</span></span>, it is
    not well suited for a specification of <span class="inlinecode"><span class="id" title="var">div2</span></span>.

<div class="paragraph"> </div>

    So, what's the point? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#R_div2'_ind"><span class="id" title="definition">R_div2'_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;R_div2'_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;0&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;1&nbsp;0&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;r&nbsp;:&nbsp;nat,&nbsp;R_div2'&nbsp;n&nbsp;r&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;n&nbsp;r&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;(S&nbsp;n))&nbsp;(S&nbsp;r))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;R_div2'&nbsp;n&nbsp;n0&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;n0&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#div2_ind"><span class="id" title="definition">div2_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;div2_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;n&nbsp;=&nbsp;0&nbsp;-&gt;&nbsp;P&nbsp;0&nbsp;0)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;n&nbsp;=&nbsp;S&nbsp;n0&nbsp;-&gt;&nbsp;n0&nbsp;=&nbsp;0&nbsp;-&gt;&nbsp;P&nbsp;1&nbsp;0)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;S&nbsp;n0&nbsp;-&gt;&nbsp;forall&nbsp;n'&nbsp;:&nbsp;nat,&nbsp;n0&nbsp;=&nbsp;S&nbsp;n'&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;n'&nbsp;(Init.Nat.div2&nbsp;n')&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;(S&nbsp;(S&nbsp;n'))&nbsp;(S&nbsp;(Init.Nat.div2&nbsp;n')))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;(Init.Nat.div2&nbsp;n)&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The point is that <span class="inlinecode"><span class="id" title="var">R_div2'_ind</span></span>, the induction principle for the graph
    of <span class="inlinecode"><span class="id" title="var">div2</span></span> is very much like <span class="inlinecode"><span class="id" title="var">div2_ind</span></span>, the functional induction principle
    for <span class="inlinecode"><span class="id" title="var">div2</span></span>. This fact is overshadowed by weirdness of <span class="inlinecode"><span class="id" title="var">div2_ind</span></span> (it was,
    after all, generated automagically). There's something very deep going on
    here.

<div class="paragraph"> </div>

    Let's ask ourselves a related question: how to prove a property of a given
    function f by induction?

<div class="paragraph"> </div>

    The simple answer is: we have to apply the right induction principle and
    then finish the proof. But which induction principle is the right one?
    A philosophical answer would be: the one that best matches the function's
    recursion shape. But which one is it?

<div class="paragraph"> </div>

    Recall that every induction principle tells us how to use a value of some
    inductively defined type (or type family) to define dependent functions.
    Therefore, every induction principle is associated to some type or type
    family. So the question boils down to this: which inductive type has the
    most similar shape to that of f's recursion shape?

<div class="paragraph"> </div>

    The ultimate answer is: the graph of f (using the definition that follows
    exactly f's recursion's shape). Now that you know this illuminating fact,
    let's see how to derive the functional induction principle for <span class="inlinecode"><span class="id" title="var">div2</span></span> by
    hand. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="Seminar.html#R_div2"><span class="id" title="inductive">R_div2</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;R_div2&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Set&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;R_div2_0&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;0&nbsp;-&gt;&nbsp;R_div2&nbsp;0&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;R_div2_1&nbsp;:&nbsp;forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;S&nbsp;n0&nbsp;-&gt;&nbsp;n0&nbsp;=&nbsp;0&nbsp;-&gt;&nbsp;R_div2&nbsp;1&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;R_div2_2&nbsp;:&nbsp;forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;S&nbsp;n0&nbsp;-&gt;&nbsp;forall&nbsp;n'&nbsp;:&nbsp;nat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n0&nbsp;=&nbsp;S&nbsp;n'&nbsp;-&gt;&nbsp;forall&nbsp;_res&nbsp;:&nbsp;nat,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R_div2&nbsp;n'&nbsp;_res&nbsp;-&gt;&nbsp;R_div2&nbsp;(S&nbsp;(S&nbsp;n'))&nbsp;(S&nbsp;_res)&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The first thing the commands <span class="inlinecode"><span class="id" title="keyword">Function</span></span> and <span class="inlinecode"><span class="id" title="var">Functional</span></span> <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> do is
    define the graph of the function in question. <span class="inlinecode"><span class="id" title="var">R_div2</span></span> is the graph
    of <span class="inlinecode"><span class="id" title="var">div2</span></span> as generated by <span class="inlinecode"><span class="id" title="var">Functional</span></span> <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span>. It's a bit clumsier than
    our definition (note that, for example, the quantified variable <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>
    in the constructor <span class="inlinecode"><span class="id" title="var">R_div2_0</span></span> is not used), but also more general (note
    that its sort is <span class="inlinecode"><span class="id" title="keyword">Set</span></span>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="R_div2'_correct"><span class="id" title="lemma">R_div2'_correct</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#R_div2'"><span class="id" title="inductive">R_div2'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| | <span class="id" title="var">n'</span>] <span class="id" title="keyword">using</span> <a class="idref" href="Seminar.html#nat_ind_2"><span class="id" title="definition">nat_ind_2</span></a>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">subst</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="R_div2'_complete"><span class="id" title="lemma">R_div2'_complete</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#R_div2'"><span class="id" title="inductive">R_div2'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Then we prove that <span class="inlinecode"><span class="id" title="var">R_div2'</span></span> really is a graph of <span class="inlinecode"><span class="id" title="var">div2</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#R_div2_correct"><span class="id" title="lemma">R_div2_correct</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;R_div2_correct&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;_res&nbsp;:&nbsp;nat,&nbsp;_res&nbsp;=&nbsp;div2&nbsp;n&nbsp;-&gt;&nbsp;R_div2&nbsp;n&nbsp;_res&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="Seminar.html#R_div2_complete"><span class="id" title="lemma">R_div2_complete</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;R_div2_complete&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;_res&nbsp;:&nbsp;nat,&nbsp;R_div2&nbsp;n&nbsp;_res&nbsp;-&gt;&nbsp;_res&nbsp;=&nbsp;div2&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Functional</span></span> <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> doesn't do it, but <span class="inlinecode"><span class="id" title="keyword">Function</span></span> does. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="div2_ind'"><span class="id" title="lemma">div2_ind'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> 0 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> 1 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> (<a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>)) (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>))<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> (<a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Seminar.html#R_div2'_ind"><span class="id" title="definition">R_div2'_ind</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Seminar.html#R_div2'_complete"><span class="id" title="lemma">R_div2'_complete</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H2</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H1</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Seminar.html#R_div2'_correct"><span class="id" title="lemma">R_div2'_correct</span></a>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We can prove the induction principle for <span class="inlinecode"><span class="id" title="var">div2</span></span> by using the induction
    principle for <span class="inlinecode"><span class="id" title="var">R_div2'</span></span> and the fact that <span class="inlinecode"><span class="id" title="var">R_div2'</span></span> is the graph of
    <span class="inlinecode"><span class="id" title="var">div2</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="div2_equation'"><span class="id" title="lemma">div2_equation'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span>) =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <span class="id" title="var">n'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
In general to prove <span class="inlinecode"><span class="id" title="var">div2_ind'</span></span> we could need <span class="inlinecode"><span class="id" title="var">div2_equation'</span></span>, which is
    called a fixed point equation for <span class="inlinecode"><span class="id" title="var">div2</span></span>. Here it wasn't needed, because
    it can be obtained by just unfolding <span class="inlinecode"><span class="id" title="var">div2</span></span>, but in general, when defining
    stuff by well-founded recursion, we wouldn't get that equation for free.
    We would have to prove it. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="lt_div2''"><span class="id" title="lemma">lt_div2''</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="Seminar.html#div2_ind'"><span class="id" title="lemma">div2_ind'</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n0</span> <span class="id" title="keyword">as</span> [| [| <span class="id" title="var">n'</span>]]; <span class="id" title="var">cbn</span> <span class="id" title="keyword">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Lt.html#lt_n_S"><span class="id" title="lemma">lt_n_S</span></a>. <span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Lt.html#lt_trans"><span class="id" title="abbreviation">lt_trans</span></a> <span class="id" title="keyword">with</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span>)); <span class="id" title="tactic">omega</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="var">functional</span> <span class="id" title="tactic">induction</span> @<a class="idref" href="Seminar.html#div2"><span class="id" title="definition">div2</span></a> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n'</span> <span class="id" title="keyword">as</span> [| [| <span class="id" title="var">n</span>]]; <span class="id" title="var">cbn</span> <span class="id" title="keyword">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Lt.html#lt_n_S"><span class="id" title="lemma">lt_n_S</span></a>. <span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Lt.html#lt_trans"><span class="id" title="abbreviation">lt_trans</span></a> <span class="id" title="keyword">with</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span>)); <span class="id" title="tactic">omega</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Here is an example use of the induction principle we crafted for
    ourselves. Applying it works exactly like using the tactic <span class="inlinecode"><span class="id" title="var">functional</span></span>
    <span class="inlinecode"><span class="id" title="tactic">induction</span></span>. 
<div class="paragraph"> </div>

<a name="lab249"></a><h4 class="section">Exercise (easy)</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="div2l"><span class="id" title="definition">div2l</span></a> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">[</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#64ee52ab9627fca8d637e2f1207a2990"><span class="id" title="notation">]</span></a> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="Seminar.html#div2l"><span class="id" title="definition">div2l</span></a> <span class="id" title="var">t</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Here's a function <span class="inlinecode"><span class="id" title="var">div2l</span></span>, that divides a list by 2 (whatever that means).
    Define its graph by induction, prove it really is its graph. Derive the
    fixed point equation and functional induction principle for <span class="inlinecode"><span class="id" title="var">div2l</span></span> by
    hand. Then prove the theorem. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="div2l_length"><span class="id" title="lemma">div2l_length</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">&lt;&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#length"><span class="id" title="definition">length</span></a> (<a class="idref" href="Seminar.html#div2l"><span class="id" title="definition">div2l</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#length"><span class="id" title="definition">length</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab250"></a><h1 class="section">Generalizing the induction hypothesis</h1>

<div class="paragraph"> </div>

 Proof by induction is not always straightforward. An often encountered
    obstacle is the induction hypothesis' lack of generality. This lack of
    generality can actually arise in two independent ways:
<ul class="doclist">
<li> bad use of tactics

</li>
<li> too weak theorem statement 
</li>
</ul>

<div class="paragraph"> </div>

 This subchapter will be about dealing with them. Let's start with
    the first possibility. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="plus'"><span class="id" title="definition">plus'</span></a> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">m'</span> =&gt; <a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) <span class="id" title="var">m'</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
This is a tail recursive version of <span class="inlinecode">+</span>. Let's try to prove something
    about it. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus'_S"><span class="id" title="lemma">plus'_S</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHm'</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
We failed, but what happened? We tried to prove the theorem by induction
    on <span class="inlinecode"><span class="id" title="var">m</span></span>, because it is the main argument of <span class="inlinecode"><span class="id" title="var">plus'</span></span>. The base case was
    trivial, but we got stuck in the inductive step case. We can in no way
    help ourselves by applying or rewriting the induction hypothesis.

<div class="paragraph"> </div>

    This is because <span class="inlinecode"><span class="id" title="var">n</span></span> is fixed in the induction hypothesis and it is so
    because when we did <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, all the things being quantified over
    before <span class="inlinecode"><span class="id" title="var">m</span></span> got introduced into the context. We can solve this problem
    easily by using the tactic <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus'_S"><span class="id" title="lemma">plus'_S</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHm'</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span>)). <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The first line of the proof script has the effect of swapping <span class="inlinecode"><span class="id" title="var">n</span></span> and
    <span class="inlinecode"><span class="id" title="var">m</span></span> in the theorem statement. Because of this, when we do <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>,
    the induction hypothesis quantifies over <span class="inlinecode"><span class="id" title="var">n</span></span>, so we can instantiate it
    with <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> and finish the proof. Last time we weren't able to do that,
    because <span class="inlinecode"><span class="id" title="var">n</span></span> was fixed. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus'_S_v2"><span class="id" title="lemma">plus'_S_v2</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A different way of solving the same problem is to simply change the
    theorem statement. It is easier and quicker than trying to achieve
    the same effect through <span class="inlinecode"><span class="id" title="tactic">intros</span></span> and <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span>, but I
    don't consider it to be a good one. I recommend that the order of
    quantification over the arguments should follow the order of the
    arguments in the function's definition. 
<div class="paragraph"> </div>

<a name="lab251"></a><h4 class="section">Exercise (easy)</h4>

<div class="paragraph"> </div>

 Prove <span class="inlinecode"><span class="id" title="var">plus'_assoc_1</span></span> without generalizing the induction hypothesis.
    Prove <span class="inlinecode"><span class="id" title="var">plus'_assoc_2</span></span> by generalizing the induction hypothesis.
    Prove <span class="inlinecode"><span class="id" title="var">plus'_assoc_3</span></span>, which quantifies over <span class="inlinecode"><span class="id" title="var">c</span></span> first.

<div class="paragraph"> </div>

    Which proof was the easiest one? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus'_assoc_1"><span class="id" title="lemma">plus'_assoc_1</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> (<a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> (<a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus'_assoc_2"><span class="id" title="lemma">plus'_assoc_2</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> (<a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> (<a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus'_assoc_3"><span class="id" title="lemma">plus'_assoc_3</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">c</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> (<a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> (<a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="Seminar.html#c"><span class="id" title="variable">c</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab252"></a><h4 class="section">Exercise (hard)</h4>

<div class="paragraph"> </div>

 Write a tactic <span class="inlinecode"><span class="id" title="var">gen_ind</span></span> that performs induction on its argument after
    having generalized the induction hypothesis. Make sure you can prove
    the theorem <span class="inlinecode"><span class="id" title="var">plus'_S_v3</span></span> with it. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="plus'_S_v3"><span class="id" title="lemma">plus'_S_v3</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a>) <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> (<a class="idref" href="Seminar.html#plus'"><span class="id" title="definition">plus'</span></a> <a class="idref" href="Seminar.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="Seminar.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">gen_ind</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The first kind of situation in which our induction hypothesis was
    not general enough arised from careless use of <span class="inlinecode"><span class="id" title="tactic">intros</span></span> and <span class="inlinecode"><span class="id" title="tactic">induction</span></span>.
    It was neither deep nor fundamental and we easily mitigated it by simple
    tactic manipulation.

<div class="paragraph"> </div>

    The second kind of genrallessness is more fundamental and arises when
    we are trying to prove a too weak theorem. It may appear paradoxical at
    first, but sometimes proving a stronger theorem is easier than proving
    a weaker one. Let's see this in an example. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#rev"><span class="id" title="definition">rev</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;rev&nbsp;=&nbsp;fun&nbsp;A&nbsp;:&nbsp;Type&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fix&nbsp;rev&nbsp;(l&nbsp;:&nbsp;list&nbsp;A)&nbsp;:&nbsp;list&nbsp;A&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;l&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="inlinecode">[]</span>&nbsp;=&gt;&nbsp;<span class="inlinecode">[]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x&nbsp;::&nbsp;l'&nbsp;=&gt;&nbsp;rev&nbsp;l'&nbsp;++&nbsp;<span class="inlinecode">[<span class="id" title="var">x</span>]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;list&nbsp;A&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Recall that <span class="inlinecode"><span class="id" title="var">rev</span></span> is a function that reverses its argument. It is very
    inefficient: it's running time is O(n^2). Let's try to improve on that
    by writing a tail recursive version. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="rev_acc"><span class="id" title="definition">rev_acc</span></a> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l</span> <span class="id" title="var">acc</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a> =&gt; <a class="idref" href="Seminar.html#acc"><span class="id" title="variable">acc</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">t</span> =&gt; <a class="idref" href="Seminar.html#rev_acc"><span class="id" title="definition">rev_acc</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="Seminar.html#acc"><span class="id" title="variable">acc</span></a>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">rev_acc</span></span> works by putting its argument's head to the accumulator until
    its argument is empty, in which case it returns the accumulator. It's
    clear that if we call it with an empty accumulator, then in result we
    will get its argument reversed. Let's try to prove that. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="rev_acc_spec_weak"><span class="id" title="lemma">rev_acc_spec_weak</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Seminar.html#rev_acc"><span class="id" title="definition">rev_acc</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#rev"><span class="id" title="definition">rev</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">h</span> <span class="id" title="var">t</span>]; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
The proof failed miserably. Our goal mentions <span class="inlinecode"><span class="id" title="var">rev_acc</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">[<span class="id" title="var">h</span>]</span>, but
    the induction hypothesis is about <span class="inlinecode"><span class="id" title="var">rev_acc</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">[]</span>. There is no way
    to solve this problem the way we did before: by rearranging the
    order of quantifications or by using <span class="inlinecode"><span class="id" title="tactic">generalize</span></span> <span class="inlinecode"><span class="id" title="tactic">dependent</span></span>.

<div class="paragraph"> </div>

    This is a problem of fundamentally different nature — the induction
    hypothesis is too weak because the theorem itself is too weak. To
    go around this, we have to devise a stronger version of the theorem,
    but how to do this?

<div class="paragraph"> </div>

    Let's take a glance at the arguments <span class="inlinecode"><span class="id" title="var">rev_acc</span></span>: the second one is <span class="inlinecode">[]</span>.
    Let's try to generalize the theorem to an arbitrary <span class="inlinecode"><span class="id" title="var">acc</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>.
    If we run <span class="inlinecode"><span class="id" title="var">rev_acc</span></span> with an arbitrary accumulator, it will prepend its
    reversed argument to the accumulator and then return it. Let's try this
    as our theorem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="rev_acc_spec_strong"><span class="id" title="lemma">rev_acc_spec_strong</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> <span class="id" title="var">acc</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#rev_acc"><span class="id" title="definition">rev_acc</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="Seminar.html#acc"><span class="id" title="variable">acc</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#rev"><span class="id" title="definition">rev</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#5d35a99a6abff1d64bf70538feb70e36"><span class="id" title="notation">++</span></a> <a class="idref" href="Seminar.html#acc"><span class="id" title="variable">acc</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">h</span> <span class="id" title="var">t</span>]; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHt</span>. <span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#app_assoc"><span class="id" title="lemma">app_assoc</span></a>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This time our induction hypothesis talks about a general <span class="inlinecode"><span class="id" title="var">acc</span></span> and not
    just <span class="inlinecode">[]</span>, so we can easily use it with <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>. Now we can derive the
    weaker version of the theorem we first tried to prove. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="rev_acc_spec_weak"><span class="id" title="lemma">rev_acc_spec_weak</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Seminar.html#rev_acc"><span class="id" title="definition">rev_acc</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#rev"><span class="id" title="definition">rev</span></a> <a class="idref" href="Seminar.html#l"><span class="id" title="variable">l</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="Seminar.html#rev_acc_spec_strong"><span class="id" title="lemma">rev_acc_spec_strong</span></a>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#app_nil_r"><span class="id" title="lemma">app_nil_r</span></a>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The technique presented above allows us to explain the paradoxical fact
    that proving a stronger theorem may be easier than proving a weaker one,
    at least in the case of proofs by induction.

<div class="paragraph"> </div>

    The explanation is: the stronger the theorem, the stronger the induction
    hypothesis. Sometimes the increase in the induction hypothesis' strength
    will be greater than the increase in the theorem's difficulty and thus
    the proof will be easier. Other times, the stronger theorem will actually
    be harder to prove. 
<div class="paragraph"> </div>

<a name="lab253"></a><h4 class="section">Exercise (easy)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">app'</span></span> is a tail recursive version of <span class="inlinecode"><span class="id" title="var">app</span></span>. Prove that they are equal. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="revapp"><span class="id" title="definition">revapp</span></a> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a> :=<br/>
<span class="id" title="keyword">match</span> <a class="idref" href="Seminar.html#l1"><span class="id" title="variable">l1</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a> =&gt; <a class="idref" href="Seminar.html#l2"><span class="id" title="variable">l2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">t</span> =&gt; <a class="idref" href="Seminar.html#revapp"><span class="id" title="definition">revapp</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">h</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <a class="idref" href="Seminar.html#l2"><span class="id" title="variable">l2</span></a>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="app'"><span class="id" title="definition">app'</span></a> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Seminar.html#revapp"><span class="id" title="definition">revapp</span></a> (<a class="idref" href="Seminar.html#revapp"><span class="id" title="definition">revapp</span></a> <a class="idref" href="Seminar.html#l1"><span class="id" title="variable">l1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#145bedf8a5d4a541831f3f70db03085c"><span class="id" title="notation">[]</span></a>) <a class="idref" href="Seminar.html#l2"><span class="id" title="variable">l2</span></a>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="app'_spec"><span class="id" title="lemma">app'_spec</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Seminar.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#app'"><span class="id" title="definition">app'</span></a> <a class="idref" href="Seminar.html#l1"><span class="id" title="variable">l1</span></a> <a class="idref" href="Seminar.html#l2"><span class="id" title="variable">l2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#app"><span class="id" title="definition">app</span></a> <a class="idref" href="Seminar.html#l1"><span class="id" title="variable">l1</span></a> <a class="idref" href="Seminar.html#l2"><span class="id" title="variable">l2</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab254"></a><h1 class="section">Technical shortcomings of <span class="inlinecode"><span class="id" title="tactic">induction</span></span></h1>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="tactic">induction</span></span> is a very smart tactic: it can introduce quantified
    variables into the context, infer the predicate we're trying to
    prove and many more. But there is one situation in which its
    behaviour is really stupid and unexpected.

<div class="paragraph"> </div>

    Let's see a somewhat complicated example, taken from Coq'Art.
    We will define a simple imperative programming language and
    then try to prove a fact by induction. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="little_semantics"><span class="id" title="section">little_semantics</span></a>.<br/>

<br/>
<span class="id" title="keyword">Axioms</span> <a name="Var"><span class="id" title="axiom">Var</span></a> <a name="aExp"><span class="id" title="axiom">aExp</span></a> <a name="bExp"><span class="id" title="axiom">bExp</span></a> : <span class="id" title="keyword">Set</span>.<br/>

<br/>
</div>

<div class="doc">
Note: there's a reason for using <span class="inlinecode"><span class="id" title="keyword">Axioms</span></span> instead of, say, <span class="inlinecode"><span class="id" title="keyword">Variables</span></span>,
    that will be explained later.

<div class="paragraph"> </div>

    We will use <span class="inlinecode"><span class="id" title="var">Var</span></span> to represent variables, <span class="inlinecode"><span class="id" title="var">aExp</span></span> for arithmetic
    expressions and <span class="inlinecode"><span class="id" title="var">bExp</span></span> for boolean expressions.
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="instr"><span class="id" title="inductive">instr</span></a> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Skip"><span class="id" title="constructor">Skip</span></a> : <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Assign"><span class="id" title="constructor">Assign</span></a> : <a class="idref" href="Seminar.html#Var"><span class="id" title="axiom">Var</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#aExp"><span class="id" title="axiom">aExp</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Seq"><span class="id" title="constructor">Seq</span></a> : <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="While"><span class="id" title="constructor">While</span></a> : <a class="idref" href="Seminar.html#bExp"><span class="id" title="axiom">bExp</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a>.<br/>

<br/>
</div>

<div class="doc">
There are three kinds of instructions: the empty instruction <span class="inlinecode"><span class="id" title="var">Skip</span></span>,
    assignment <span class="inlinecode"><span class="id" title="var">Assign</span></span> and the while loop <span class="inlinecode"><span class="id" title="var">While</span></span>. They can be sequenced
    using <span class="inlinecode"><span class="id" title="var">Seq</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span><br/>
&nbsp;&nbsp;(<a name="state"><span class="id" title="axiom">state</span></a> : <span class="id" title="keyword">Set</span>)<br/>
&nbsp;&nbsp;(<a name="update"><span class="id" title="axiom">update</span></a> : <a class="idref" href="Seminar.html#state"><span class="id" title="variable">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#Var"><span class="id" title="axiom">Var</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="Seminar.html#state"><span class="id" title="variable">state</span></a>)<br/>
&nbsp;&nbsp;(<a name="evalA"><span class="id" title="axiom">evalA</span></a> : <a class="idref" href="Seminar.html#state"><span class="id" title="variable">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#aExp"><span class="id" title="axiom">aExp</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a>)<br/>
&nbsp;&nbsp;(<a name="evalB"><span class="id" title="axiom">evalB</span></a> : <a class="idref" href="Seminar.html#state"><span class="id" title="variable">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#bExp"><span class="id" title="axiom">bExp</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>).<br/>

<br/>
</div>

<div class="doc">
We also assume <span class="inlinecode"><span class="id" title="var">state</span></span> for representing the state of programs. This state
    will be updated with <span class="inlinecode"><span class="id" title="var">update</span></span>. We can "evaluate" arithmetic expressions
    using <span class="inlinecode"><span class="id" title="var">evalA</span></span> and boolean expressions using <span class="inlinecode"><span class="id" title="var">evalB</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="exec"><span class="id" title="inductive">exec</span></a> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="execSkip"><span class="id" title="constructor">execSkip</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">s</span> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a>, <a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="Seminar.html#Skip"><span class="id" title="constructor">Skip</span></a> <a class="idref" href="Seminar.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="execAssign"><span class="id" title="constructor">execAssign</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">s1</span> <span class="id" title="var">s2</span> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a>) (<span class="id" title="var">v</span> : <a class="idref" href="Seminar.html#Var"><span class="id" title="axiom">Var</span></a>) (<span class="id" title="var">a</span> : <a class="idref" href="Seminar.html#aExp"><span class="id" title="axiom">aExp</span></a>) (<span class="id" title="var">k</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#evalA"><span class="id" title="axiom">evalA</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#update"><span class="id" title="axiom">update</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Seminar.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="Seminar.html#k"><span class="id" title="variable">k</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="Seminar.html#s2"><span class="id" title="variable">s2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> (<a class="idref" href="Seminar.html#Assign"><span class="id" title="constructor">Assign</span></a> <a class="idref" href="Seminar.html#v"><span class="id" title="variable">v</span></a> <a class="idref" href="Seminar.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="Seminar.html#s2"><span class="id" title="variable">s2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="execSeq"><span class="id" title="constructor">execSeq</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">s1</span> <span class="id" title="var">s2</span> <span class="id" title="var">s3</span> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a>) (<span class="id" title="var">i1</span> <span class="id" title="var">i2</span> : <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Seminar.html#i1"><span class="id" title="variable">i1</span></a> <a class="idref" href="Seminar.html#s2"><span class="id" title="variable">s2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s2"><span class="id" title="variable">s2</span></a> <a class="idref" href="Seminar.html#i2"><span class="id" title="variable">i2</span></a> <a class="idref" href="Seminar.html#s3"><span class="id" title="variable">s3</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> (<a class="idref" href="Seminar.html#Seq"><span class="id" title="constructor">Seq</span></a> <a class="idref" href="Seminar.html#i1"><span class="id" title="variable">i1</span></a> <a class="idref" href="Seminar.html#i2"><span class="id" title="variable">i2</span></a>) <a class="idref" href="Seminar.html#s3"><span class="id" title="variable">s3</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="execWhileTrue"><span class="id" title="constructor">execWhileTrue</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">s1</span> <span class="id" title="var">s2</span> <span class="id" title="var">s3</span> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a>) (<span class="id" title="var">i</span> : <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a>) (<span class="id" title="var">be</span> : <a class="idref" href="Seminar.html#bExp"><span class="id" title="axiom">bExp</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#evalB"><span class="id" title="axiom">evalB</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Seminar.html#be"><span class="id" title="variable">be</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Seminar.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="Seminar.html#s2"><span class="id" title="variable">s2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s2"><span class="id" title="variable">s2</span></a> (<a class="idref" href="Seminar.html#While"><span class="id" title="constructor">While</span></a> <a class="idref" href="Seminar.html#be"><span class="id" title="variable">be</span></a> <a class="idref" href="Seminar.html#i"><span class="id" title="variable">i</span></a>) <a class="idref" href="Seminar.html#s3"><span class="id" title="variable">s3</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> (<a class="idref" href="Seminar.html#While"><span class="id" title="constructor">While</span></a> <a class="idref" href="Seminar.html#be"><span class="id" title="variable">be</span></a> <a class="idref" href="Seminar.html#i"><span class="id" title="variable">i</span></a>) <a class="idref" href="Seminar.html#s3"><span class="id" title="variable">s3</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="execWhileFalse"><span class="id" title="constructor">execWhileFalse</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">s</span> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a>) (<span class="id" title="var">i</span> : <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a>) (<span class="id" title="var">be</span> : <a class="idref" href="Seminar.html#bExp"><span class="id" title="axiom">bExp</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#evalB"><span class="id" title="axiom">evalB</span></a> <a class="idref" href="Seminar.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="Seminar.html#be"><span class="id" title="variable">be</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="Seminar.html#While"><span class="id" title="constructor">While</span></a> <a class="idref" href="Seminar.html#be"><span class="id" title="variable">be</span></a> <a class="idref" href="Seminar.html#i"><span class="id" title="variable">i</span></a>) <a class="idref" href="Seminar.html#s"><span class="id" title="variable">s</span></a>.<br/>

<br/>
</div>

<div class="doc">
This is the relation that describes how to execute programs. <span class="inlinecode"><span class="id" title="var">Skip</span></span> does
    nothing, <span class="inlinecode"><span class="id" title="var">Assign</span></span> and <span class="inlinecode"><span class="id" title="var">While</span></span> work as expected. <span class="inlinecode"><span class="id" title="var">Seq</span></span> <span class="inlinecode"><span class="id" title="var">i1</span></span> <span class="inlinecode"><span class="id" title="var">i2</span></span> means "execute
    i1 and then i2". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Constructors</span> <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a> <a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a>.<br/>

<br/>
</div>

<div class="doc">
We want to prove a rule for while from Hoare logic. It says, roughly,
    that if we execute a while loop and if a loop invariant <span class="inlinecode"><span class="id" title="var">P</span></span> holds
    before the loop and after each iteration, then after the last iteration
    <span class="inlinecode"><span class="id" title="var">P</span></span> also holds and moreover the condition of the while loop is false
    (for otherwise the loop wouldn't have terminated). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="HoareWhileRule"><span class="id" title="lemma">HoareWhileRule</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">b</span> : <a class="idref" href="Seminar.html#bExp"><span class="id" title="axiom">bExp</span></a>) (<span class="id" title="var">i</span> : <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a>) (<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">forall</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#evalB"><span class="id" title="axiom">evalB</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Seminar.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="Seminar.html#s2"><span class="id" title="variable">s2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#s2"><span class="id" title="variable">s2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="Seminar.html#While"><span class="id" title="constructor">While</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Seminar.html#i"><span class="id" title="variable">i</span></a>) <a class="idref" href="Seminar.html#s'"><span class="id" title="variable">s'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#s'"><span class="id" title="variable">s'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="Seminar.html#evalB"><span class="id" title="axiom">evalB</span></a> <a class="idref" href="Seminar.html#s'"><span class="id" title="variable">s'</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">H1</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">H1</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">subst</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">remember</span> (<a class="idref" href="Seminar.html#While"><span class="id" title="constructor">While</span></a> <span class="id" title="var">b</span> <span class="id" title="var">i</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">w</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">inversion</span> <span class="id" title="var">Heqw</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">eauto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We attempt to prove the theorem by induction on the hypothesis
    <span class="inlinecode"><span class="id" title="var">H1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">exec</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">(<span class="id" title="var">While</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">i</span>)</span> <span class="inlinecode"><span class="id" title="var">s'</span></span> as this seems to be the only reasonable
    option. However, we fail miserably: <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">H1</span></span> gives us 5 subgoals
    that we can't solve.

<div class="paragraph"> </div>

    Clearly <span class="inlinecode"><span class="id" title="var">H1</span></span> could have been created only with the constructors
    <span class="inlinecode"><span class="id" title="var">execWhileTrue</span></span> and <span class="inlinecode"><span class="id" title="var">execWhileFalse</span></span>, but <span class="inlinecode"><span class="id" title="tactic">induction</span></span> wants us to
    consider all 5 constructors. If we try <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, the same happens,
    but when we use <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, we get only 2 subgoals as expected. Why
    is this so?

<div class="paragraph"> </div>

    It's all very simple: if we do induction on a term whose type contains
    non-variables, <span class="inlinecode"><span class="id" title="tactic">induction</span></span> and <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> both mess up and "forget"
    the form of this particular term, leaving us with unprovable subgoals.

<div class="paragraph"> </div>

    In our case, the type of <span class="inlinecode"><span class="id" title="var">H1</span></span> is <span class="inlinecode"><span class="id" title="var">exec</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">(<span class="id" title="var">While</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">i</span>)</span> <span class="inlinecode"><span class="id" title="var">s'</span></span>. The arguments
    of <span class="inlinecode"><span class="id" title="var">exec</span></span> are <span class="inlinecode"><span class="id" title="var">s</span></span>, <span class="inlinecode"><span class="id" title="var">While</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> and <span class="inlinecode"><span class="id" title="var">s'</span></span>, of which <span class="inlinecode"><span class="id" title="var">s</span></span> and <span class="inlinecode"><span class="id" title="var">s'</span></span> are
    variables and <span class="inlinecode"><span class="id" title="var">While</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> is not. So, both <span class="inlinecode"><span class="id" title="tactic">induction</span></span> and <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>
    forget all information regarding the term <span class="inlinecode"><span class="id" title="var">While</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span>.

<div class="paragraph"> </div>

    The situation is easy to deal with: we have to replace the problematic
    term <span class="inlinecode"><span class="id" title="var">While</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> with a fresh variable <span class="inlinecode"><span class="id" title="var">w</span></span>, keeping an equality saying
    that <span class="inlinecode"><span class="id" title="var">w</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">While</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span>. This little bookkeeping saves us from losing
    the desired information.

<div class="paragraph"> </div>

    Two questions remain: why <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> succeeds, when <span class="inlinecode"><span class="id" title="tactic">induction</span></span> and
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> fail? The answer is: <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> was crafted specially for
    not losing information in such cases. So, why doesn't <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and
    <span class="inlinecode"><span class="id" title="tactic">induction</span></span> work that way?

<div class="paragraph"> </div>

    As for <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, if you want it not to lose information, you can
    use <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> anyway. As for <span class="inlinecode"><span class="id" title="tactic">induction</span></span>: it is supposed to be a
    basic and simple tactic, whereas <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> tends to generate very
    large proofterms. For example, in the above proofscript, after <span class="inlinecode"><span class="id" title="tactic">intros</span></span>
    the proofterm is only 4 lines long, but after <span class="inlinecode"><span class="id" title="tactic">intros</span>.</span> <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> <span class="inlinecode"><span class="id" title="var">H1</span></span> it
    is 214 lines long (you can check this yourself with the command <span class="inlinecode"><span class="id" title="keyword">Show</span></span>
    <span class="inlinecode"><span class="id" title="keyword">Proof</span></span>). This is the price of <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>. 
<div class="paragraph"> </div>

<a name="lab255"></a><h4 class="section">Exercise (hard)</h4>

<div class="paragraph"> </div>

 Write a tactic <span class="inlinecode"><span class="id" title="var">replace_nonvars</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> that replaces all nonvariables with
    variables in the hypothesis <span class="inlinecode"><span class="id" title="var">H</span></span> and adds appropriate equalities to the
    context. Combine this tactic with the tactic <span class="inlinecode"><span class="id" title="var">generalize_IH</span></span> that you
    implemented in one of the earlier exercises and some more tinkering to
    get a tactic <span class="inlinecode"><span class="id" title="var">ind</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>, which:
<ul class="doclist">
<li> generalizes the inductive hypothesis

</li>
<li> replaces nonvariables with variables in the inductive hypothesis

</li>
<li> does induction

</li>
<li> inverses and substitutes all necessary equalities

</li>
<li> cleans the mess it may have created in the context

</li>
<li> finishes off easy subgoals with some basic automation 
</li>
</ul>

<div class="paragraph"> </div>

 Your tactic should be able to solve <span class="inlinecode"><span class="id" title="var">HoareWhilRule'</span></span> as shown below.
    How big is the proofterm it generates? Measure it in lines (mine is
    314 lines). 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="HoareWhileRule'"><span class="id" title="lemma">HoareWhileRule'</span></a> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">b</span> : <a class="idref" href="Seminar.html#bExp"><span class="id" title="axiom">bExp</span></a>) (<span class="id" title="var">i</span> : <a class="idref" href="Seminar.html#instr"><span class="id" title="inductive">instr</span></a>) (<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">forall</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span> : <a class="idref" href="Seminar.html#state"><span class="id" title="axiom">state</span></a>, <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#evalB"><span class="id" title="axiom">evalB</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Seminar.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="Seminar.html#s2"><span class="id" title="variable">s2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#s2"><span class="id" title="variable">s2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="Seminar.html#exec"><span class="id" title="inductive">exec</span></a> <a class="idref" href="Seminar.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="Seminar.html#While"><span class="id" title="constructor">While</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Seminar.html#i"><span class="id" title="variable">i</span></a>) <a class="idref" href="Seminar.html#s'"><span class="id" title="variable">s'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Seminar.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="Seminar.html#s'"><span class="id" title="variable">s'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="Seminar.html#evalB"><span class="id" title="axiom">evalB</span></a> <a class="idref" href="Seminar.html#s'"><span class="id" title="variable">s'</span></a> <a class="idref" href="Seminar.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">ind</span> <span class="id" title="var">H1</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="Seminar.html#little_semantics"><span class="id" title="section">little_semantics</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab256"></a><h1 class="section">Grading</h1>

<div class="paragraph"> </div>

 To get a 3 you need to prove all theorems that are stated, but whose
    proofs are omitted, and solve all exercises which are marked as easy.

<div class="paragraph"> </div>

    To get a 4 you need to get a 3 and additionally solve all exercises
    which are marked as medium.

<div class="paragraph"> </div>

    To get a 5 you need to get a 4 and additionally solve all exercises
    which are marked as hard. 
</div>
<div class="code">
</div>
