<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-88023543-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<h1 class="libtitle">R3: Taktyki i automatyzacja</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 Matematycy uważają, że po osiągnięciu pewnego poziomu zaawansowania i
    obycia (nazywanego zazwyczaj "mathematical maturity") skrupulatne
    rozpisywanie każdego kroku dowodu przestaje mieć sens i pozwalają
    sobie zarzucić je na rzecz bardziej wysokopoziomowego opisu rozumowania.

<div class="paragraph"> </div>

    Myślę, że ta sytuacja ma miejsce w twoim przypadku — znasz już sporą
    część języka termów Coqa (zwanego Gallina) i potrafisz dowodzić różnych
    właściwości programów. Doszedłeś do punktu, w którym ręczne klepanie
    dowodów przestaje być produktywne, a staje się nudne i męczące.

<div class="paragraph"> </div>

    Niestety, natura dowodu formalnego nie pozwala nam od tak po prostu
    pominąć mało ciekawych kroków. Czy chcemy czy nie, aby Coq przyjął
    dowód, kroki te muszą zostać wykonane. Wcale nie znaczy to jednak,
    że to my musimy je wykonać — mogą zrobić to za nas programy.

<div class="paragraph"> </div>

    Te programy to oczywiście taktyki. Większość prymitywnych taktyk, jak
    <span class="inlinecode"><span class="id" title="tactic">intro</span></span>, <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, czy <span class="inlinecode"><span class="id" title="tactic">assumption</span></span> już znamy. Choć nie wiesz o tym,
    używaliśmy też wielokrotnie taktyk całkiem zaawansowanych, takich jak
    <span class="inlinecode"><span class="id" title="tactic">induction</span></span> czy <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, bez których nasze formalne życie byłoby
    drogą przez mękę.

<div class="paragraph"> </div>

    Wszystkie one są jednak taktykami wbudowanymi, danymi nam z góry przez
    Coqowych bogów i nie mamy wpływu na ich działanie. Jeżeli nie jesteśmy
    w stanie zrobić czegoś za ich pomocą, jesteśmy zgubieni. Czas najwyższy
    nauczyć się pisać własne taktyki, które pomogą nam wykonywać mało ciekawe
    kroki w dowodach, a w dalszej perspektywnie także przeprowadzać bardziej
    zaawansowane rozumowania zupełnie automatycznie.

<div class="paragraph"> </div>

    W tym rozdziale poznamy podstawy języka <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span>, który służy do tworzenia
    własnych taktyk. Jego składnię przedstawiono i skrupulatnie opisano tu:
    https://coq.inria.fr/refman/ltac.html

<div class="paragraph"> </div>

    Choć przykład znaczy więcej niż 0x3E8 stron manuala i postaram się
    dokładnie zilustrować każdy istotny moim zdaniem konstrukt języka
    <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span>, to i tak polecam zapoznać się z powyższym linkiem.

<div class="paragraph"> </div>

    Upewnij się też, że rozumiesz dokładnie, jak działają podstawowe
    kombinatory taktyk, które zostały omówione w rozdziale 1, gdyż nie
    będziemy omawiać ich drugi raz. 
<div class="paragraph"> </div>

<a name="lab154"></a><h1 class="section">Zarządzanie celami i selektory</h1>

<div class="paragraph"> </div>

 Dowodząc (lub konstruując cokolwiek za pomocą taktyk) mamy do rozwiązania
    jeden lub więcej celów. Cele są ponumerowane i domyślnie zawsze pracujemy
    nad tym, który ma numer 1.

<div class="paragraph"> </div>

    Jednak wcale nie musi tak być — możemy zaznaczyć inny cel i zacząć nad
    nim pracować. Służy do tego komenda <span class="inlinecode"><span class="id" title="var">Focus</span></span>. Cel o numerze n możemy
    zaznaczyć komendą <span class="inlinecode"><span class="id" title="var">Focus</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Jeżeli to zrobimy, wszystkie pozostałe cele
    chwilowo znikają. Do stanu domyślnego, w którym pracujemy nad celem nr 1
    i wszystkie cele są widoczne możemy wrócić za pomocą komendy <span class="inlinecode"><span class="id" title="var">Unfocus</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="R3.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="R3.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="R3.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Focus</span> 3.<br/>
&nbsp;&nbsp;<span class="id" title="var">Unfocus</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Focus</span> 2.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Komenda <span class="inlinecode"><span class="id" title="var">Focus</span></span> jest użyteczna głównie gdy któryś z dalszych celów jest
    łatwiejszy niż obecny. Możemy wtedy przełączyć się na niego, rozwiązać
    go i wyniesione stąd doświadczenie przenieść na trudniejsze cele. Jest
    wskazane, żeby po zakończeniu dowodu zrefaktoryzować go tak, aby komenda
    <span class="inlinecode"><span class="id" title="var">Focus</span></span> w nim nie występowała.

<div class="paragraph"> </div>

    Nie jest też tak, że zawsze musimy pracować nad celem o numerze 1. Możemy
    pracować na dowolnym zbiorze celów. Do wybierania celów, na które chcemy
    zadziałać taktykami, służą selektory. Jest ich kilka i mają taką składnię:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">n</span>:</span> <span class="inlinecode"><span class="id" title="var">t</span></span> — użyj taktyki t na n-tym celu. <span class="inlinecode">1:</span> <span class="inlinecode"><span class="id" title="var">t</span></span> jest równoważne <span class="inlinecode"><span class="id" title="var">t</span></span>.

</li>
<li> <span class="inlinecode"><span class="id" title="var">a</span>-<span class="id" title="var">b</span>:</span> <span class="inlinecode"><span class="id" title="var">t</span></span> — użyj taktyki t na wszystkich celach o numerach od a do b

</li>
<li> <span class="inlinecode"><span class="id" title="var">a1</span>-<span class="id" title="var">b1</span>,</span> <span class="inlinecode"><span class="id" title="var">a2</span>-<span class="id" title="var">b2</span>,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">aN</span>-<span class="id" title="var">bN</span>:</span> <span class="inlinecode"><span class="id" title="var">t</span></span> — użyj taktyki <span class="inlinecode"><span class="id" title="var">t</span></span> na wszystkich celach
      o numerach od a1 do b1, od a2 do b2, ..., od aN do bN (zamiast aK-bK
      możemy też użyć pojedynczej liczby)

</li>
<li> <span class="inlinecode"><span class="id" title="var">all</span>:</span> <span class="inlinecode"><span class="id" title="var">t</span></span> ­- użyj <span class="inlinecode"><span class="id" title="var">t</span></span> na wszystkich celach

</li>
<li> zamiast <span class="inlinecode"><span class="id" title="var">t</span></span>, w powyższych przypadkach możemy też użyć wyrażenia
      <span class="inlinecode">&gt;</span> <span class="inlinecode"><span class="id" title="var">t_1</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">t_n</span></span>, które aplikuje taktykę <span class="inlinecode"><span class="id" title="var">t_i</span></span> do i-tego celu
      zaznaczonego danym selektorem 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="R3.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="R3.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="R3.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1 <span class="id" title="keyword">as</span> [<span class="id" title="var">H</span> [<span class="id" title="var">H'</span> <span class="id" title="var">H''</span>]]. <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;3: <span class="id" title="tactic">assumption</span>. 2: <span class="id" title="tactic">assumption</span>. 1: <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1 <span class="id" title="keyword">as</span> [<span class="id" title="var">H</span> [<span class="id" title="var">H'</span> <span class="id" title="var">H''</span>]]. <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;1-2: <span class="id" title="tactic">assumption</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1 <span class="id" title="keyword">as</span> [<span class="id" title="var">H</span> [<span class="id" title="var">H'</span> <span class="id" title="var">H''</span>]]. <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;1-2, 3: <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1 <span class="id" title="keyword">as</span> [<span class="id" title="var">H</span> [<span class="id" title="var">H'</span> <span class="id" title="var">H''</span>]]. <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">all</span>: <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1 <span class="id" title="keyword">as</span> [<span class="id" title="var">H</span> [<span class="id" title="var">H'</span> <span class="id" title="var">H''</span>]]. <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">all</span>: [&gt; <span class="id" title="tactic">assumption</span> | <span class="id" title="tactic">assumption</span> | <span class="id" title="tactic">assumption</span>].<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Selektory przydają się głównie gdy chcemy napisać taktykę rozwiązującą
    wszystkie cele i sprawdzamy jej działanie na każdym celu z osobna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">n</span> := <span class="id" title="var">numgoals</span> <span class="id" title="keyword">in</span> <span class="id" title="tactic">idtac</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">all</span>: <span class="id" title="keyword">let</span> <span class="id" title="var">n</span> := <span class="id" title="var">numgoals</span> <span class="id" title="keyword">in</span> <span class="id" title="tactic">idtac</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Ilość celów możemy policzyć za pomocą taktyki <span class="inlinecode"><span class="id" title="var">numgoals</span></span>. Liczy ona
    wszystkie cele, na które działa, więc jeżeli nie użyjemy żadnego
    selektora, zwróci ona 1. Nie jest ona zbyt użyteczna (poza bardzo
    skomplikowanymi taktykami, które z jakichś powodów nie operują tylko na
    jednym celu, lecz na wszystkich).

<div class="paragraph"> </div>

    Z wiązaniem <span class="inlinecode"><span class="id" title="keyword">let</span></span> w kontekście taktyk spotkamy się już niedługo. 
<div class="paragraph"> </div>

<a name="lab155"></a><h1 class="section">Podstawy języka Ltac</h1>

<div class="paragraph"> </div>

 Ltac jest funkcyjnym językiem programowania, podobnie jak język termów
    Coqa (zwany Gallina), lecz te dwa języki są diametralnie różne:
<ul class="doclist">
<li> Ltac jest kompletny w sensie Turinga, a Gallina nie. W szczególności,
      taktyki mogą się zapętlać i nie rodzi to żadnych problemów natury
      logicznej.

</li>
<li> Ltac jest bardzo słabo typowany, podczas gdy Gallina dysponuje potężnym
      systemem typów.

</li>
<li> W Ltacu nie możemy definiować typów danych, a jedynie taktyki działające
      na kontekstach i celu, podczas gdy Gallina pozwala na definiowanie
      bardzo szerokiej klasy typów i działających na nich funkcji.

</li>
<li> Ltac, jako metajęzyk jezyka Gallina, posiada dostęp do różnych rzeczy,
      do których Gallina nie ma dostępu, takich jak dopasowanie termów
      dowolnego typu. Dla przykładu, w Ltacu możemy odróżnić termy <span class="inlinecode">4</span> oraz
      <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> pomimo tego, że są konwertowalne. 
</li>
</ul>

<div class="paragraph"> </div>

 W Ltacu możemy manipulować trzema rodzajami bytów: taktykami, termami
    Coqa oraz liczbami całkowitymi — te ostatnie nie są tym samym, co liczby
    całkowite Coqa i będziemy ich używać sporadycznie. Zanim zobaczymy
    przykład, przyjrzyjmy się taktyce <span class="inlinecode"><span class="id" title="tactic">pose</span></span> oraz konstruktowi <span class="inlinecode"><span class="id" title="keyword">let</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">nazwa</span> := 123).<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">pose</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> dodaje do kontekstu term o domyślnej nazwie, którego ciałem
    jest <span class="inlinecode"><span class="id" title="var">t</span></span>. Możemy też napisać <span class="inlinecode"><span class="id" title="tactic">pose</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">t</span></span>, dzięki czemu zyskujemy
    kontrolę nad nazwą termu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := 42 <span class="id" title="keyword">in</span> <span class="id" title="tactic">pose</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="keyword">constr</span>:(42) <span class="id" title="keyword">in</span> <span class="id" title="tactic">pose</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="tactic">auto</span> <span class="id" title="keyword">in</span> <span class="id" title="tactic">idtac</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
W Ltacu, podobnie jak w języku Gallina, mamy do dyspozycji konstrukt
    <span class="inlinecode"><span class="id" title="keyword">let</span></span>. Za jego pomocą możemy nadać nazwę dowolnemu wyrażeniu języka
    Ltac. Jego działanie jest podobne jak w języku Gallina, a więc nie
    ma co się nad nim rozwodzić. Jest też konstrukt <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">rec</span></span>, który
    odpowiada <span class="inlinecode"><span class="id" title="keyword">fix</span></span>owi Galliny.

<div class="paragraph"> </div>

    Spróbujmy dodać do kontekstu liczbę <span class="inlinecode">42</span>, nazwaną dowolnie. Komendą
    <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">42</span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="tactic">pose</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> nie udaje nam się tego osiągnąć. O przyczynie
    niepowodzenia Coq informuje nas wprost: zmienna <span class="inlinecode"><span class="id" title="var">x</span></span> nie jest termem.
    Czym zatem jest? Jak już się rzekło, Ltac posiada wbudowany typ liczb
    całkowitych, które nie są tym samym, co induktywnie zdefiniowane liczby
    całkowite Coqa. W tym kontekście <span class="inlinecode">42</span> jest więc liczbą całkowitą Ltaca,
    a zatem nie jest termem.

<div class="paragraph"> </div>

    Aby wymusić na Ltacu zinterpretowanie <span class="inlinecode">42</span> jako termu Coqa, musimy
    posłużyć się zapisem <span class="inlinecode"><span class="id" title="keyword">constr</span>:()</span>. Dzięki niemu argument znajdujący
    się w nawiasach zostanie zinterpretowany jako term. Efektem działania
    drugiej taktyki jest więc dodanie termu <span class="inlinecode">42</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> do kontekstu,
    nazwanego domyślnie <span class="inlinecode"><span class="id" title="var">n</span></span> (co jest, o dziwo, dość rozsądną nazwą).

<div class="paragraph"> </div>

    Wyrażenie <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="tactic">idtac</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> pokazuje nam, że taktyki również
    są wyrażeniami Ltaca i mogą być przypisywane do zmiennych (a także
    wyświetlane za pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">idtac</span></span>) tak jak każde inne wyrażenie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">garbage</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">idtac</span> "Here's some garbage: " <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">garbage</span> 0.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">garbage'</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="tactic">pose</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">idtac</span> "Here's some garbage: " <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">garbage'</span> 0.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Dowolną taktykę, której możemy użyć w dowodzie, możemy też nazwać
    za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> i odwoływać się do niej w dowodach za pomocą
    tej nazwy. Komenda <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> jest więc taktykowym odpowiednikiem komendy
    <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>.

<div class="paragraph"> </div>

    Podobnie jak <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>y i inne definicje, tak i taktyki zdefiniowane
    za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> mogą brać argumenty, którymi mogą być liczby,
    termy, nazwy hipotez albo inne taktyki.

<div class="paragraph"> </div>

    Zapis <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> <span class="inlinecode"><span class="id" title="var">name</span></span> <span class="inlinecode"><span class="id" title="var">arg_1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">arg_n</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">body</span></span> jest jedynie skrótem, który
    oznacza <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> <span class="inlinecode"><span class="id" title="var">name</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">arg_1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">arg_n</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">body</span></span>. Jest to uwaga
    mocno techniczna, gdyż pierwszy zapis jest prawie zawsze preferowany
    wobec drugiego. 
<div class="paragraph"> </div>

<a name="lab156"></a><h1 class="section">Backtracking</h1>

<div class="paragraph"> </div>

 Poznałeś już kombinator alternatywy <span class="inlinecode">||</span>. Nie jest to jednak jedyny
    kombinator służący do wyrażania tej idei — są jeszcze kombinatory <span class="inlinecode">+</span>
    oraz <span class="inlinecode"><span class="id" title="var">tryif</span></span> <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">t2</span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">t3</span></span>. Różnią się one działaniem — <span class="inlinecode">||</span> jest
    left-biased, podczas gdy <span class="inlinecode">+</span> nie jest biased i może powodować
    backtracking.

<div class="paragraph"> </div>

    Nie przestrasz się tych dziwnych słów. Stojące za nimi idee są z grubsza
    bardzo proste. Wcześniej dowiedziałeś się, że taktyka może zawieść lub
    zakończyć się sukcesem. W rzeczywistości sprawa jest nieco bardziej
    ogólna: każda taktyka może zakończyć się dowolną ilością sukcesów. Zero
    sukcesów oznacza, że taktyka zawodzi. Większość taktyk, które dotychczas
    poznaliśmy, mogła zakończyć się co najwyżej jednym sukcesem. Są jednak i
    takie, które mogą zakończyć się dwoma lub więcej sukcesami.

<div class="paragraph"> </div>

    Proces dowodzenia za pomocą taktyk można zobrazować za pomocą procesu
    przeszukiwania drzewa, którego wierzchołkami są częściowo skonstruowane
    prooftermy, zaś krawędziami — sukcesy pochodzące od wywoływania taktyk.
    Liśćmi są prooftermy (dowód się udał) lub ślepe zaułki (dowód się nie
    udał).

<div class="paragraph"> </div>

    W takiej wizualizacji taktyka może wyzwalać backtracking, jeżeli jej
    użycie prowadzi do powstania rozgałęzienia w drzewie. Samo drzewo
    przeszukiwane jest w głąb, a backtracking polega na tym, że jeżeli
    trafimy na ślepy zaułek (dowód się nie powiódł), to cofamy się (ang.
    "to backtrack" — cofać się) do ostatniego punktu rozgałęzienia i
    próbujemy pójść inną gałęzią.

<div class="paragraph"> </div>

    Tę intuicję dobrze widać na poniższym przykładzie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">existsNatFrom</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">n</span> || <span class="id" title="var">existsNatFrom</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">existsNat</span> := <span class="id" title="var">existsNatFrom</span> <span class="id" title="var">O</span>.<br/>

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="R3.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> (<span class="id" title="var">existsNat</span>; <span class="id" title="tactic">reflexivity</span>).<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">existsNatFrom'</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">n</span> + <span class="id" title="var">existsNatFrom'</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">existsNat'</span> := <span class="id" title="var">existsNatFrom'</span> <span class="id" title="var">O</span>.<br/>

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="R3.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">existsNat'</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Próba użycia taktyki <span class="inlinecode"><span class="id" title="var">existsNat</span></span>, która używa kombinatora <span class="inlinecode">||</span>, do
    udowodnienia, że <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">42</span> kończy się niepowodzeniem.
    Jest tak, gdyż <span class="inlinecode">||</span> nie może powodować backtrackingu — jeżeli taktyka
    <span class="inlinecode"><span class="id" title="var">t1</span></span> dokona postępu, to wtedy <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode">||</span> <span class="inlinecode"><span class="id" title="var">t2</span></span> ma taki sam efekt, jak <span class="inlinecode"><span class="id" title="var">t1</span></span>,
    a w przeciwnym wypadku taki sam jak <span class="inlinecode"><span class="id" title="var">t2</span></span>. Nawet jeżeli zarówno <span class="inlinecode"><span class="id" title="var">t1</span></span>
    jak i <span class="inlinecode"><span class="id" title="var">t2</span></span> zakończą się sukcesami, to sukcesy <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode">||</span> <span class="inlinecode"><span class="id" title="var">t2</span></span> będą sukcesami
    tylko <span class="inlinecode"><span class="id" title="var">t1</span></span>.

<div class="paragraph"> </div>

    Na mocy powyższych rozważań możemy skonkludować, że taktyka <span class="inlinecode"><span class="id" title="var">existsNat</span></span>
    ma co najwyżej jeden sukces i działa jak <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> dla pewnej liczby
    naturalnej <span class="inlinecode"><span class="id" title="var">n</span></span>. Ponieważ użycie <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">0</span> na celu <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">42</span>
    dokonuje postępu, to taktyka <span class="inlinecode"><span class="id" title="var">existsNat</span></span> ma taki sam efekt, jak <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">0</span>.
    Próba użycia <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> zawodzi, a ponieważ nie ma już więcej sukcesów
    pochodzących od <span class="inlinecode"><span class="id" title="var">existsNat</span></span> do wypróbowania, nie wyzwala backtrackingu.
    Wobec tego cała taktyka <span class="inlinecode"><span class="id" title="var">existsNat</span>;</span> <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> kończy się porażką.

<div class="paragraph"> </div>

    Inaczej sytuacja wygląda w przypadku <span class="inlinecode"><span class="id" title="var">existsNat'</span></span>, która bazuje na
    kombinatorze <span class="inlinecode">+</span>. Sukcesy <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">t2</span></span> to wszystkie sukcesy <span class="inlinecode"><span class="id" title="var">t1</span></span>, po
    których następują wszystkie sukcesy <span class="inlinecode"><span class="id" title="var">t2</span></span>. Wobec tego zbiór sukcesów
    <span class="inlinecode"><span class="id" title="var">existsNat'</span></span> jest nieskończony i wygląda tak: <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">0</span>, <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">1</span>,
    <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">2</span>... Użycie taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, które kończy się porażką
    wyzwala backtracking, więc całe wykonanie taktyki można zobrazować tak:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">0;</span> <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> — porażka

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">1;</span> <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> — porażka

</li>
<li> ...

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">42;</span> <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> — sukces 
</li>
</ul>

<div class="paragraph"> </div>

 Na koniec zaznaczyć należy, że backtracking nie jest za darmo — im go
    więcej, tym więcej rozgałęzień w naszym drzewie poszukiwań, a zatem
    tym więcej czasu zajmie wykonanie taktyki. W przypadku użycia taktyk
    takich jak <span class="inlinecode"><span class="id" title="var">existsNat</span></span>, które mają nieskończony zbiór sukcesów, dowód
    może nie zostać znaleziony nigdy, nawet jeżeli istnieje.

<div class="paragraph"> </div>

    Jednym ze sposobów radzenia sobie z tym problemem może być kombinator
    <span class="inlinecode"><span class="id" title="var">once</span></span>, który ogranicza liczbę sukcesów taktyki do co najwyżej jednego,
    zapobiegając w ten sposób potencjalnemu wyzwoleniu backtrackingu. Innymi
    słowy, <span class="inlinecode"><span class="id" title="var">once</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> zawsze ma 0 lub 1 sukcesów. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="R3.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="var">once</span> <span class="id" title="var">existsNat'</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Powyżej byliśmy w stanie udowodnić to twierdzenie za pomocą taktyki
    <span class="inlinecode"><span class="id" title="var">existsNat'</span></span>, gdyż jej 42  sukces pozwalał taktyce <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>
    uporać się z celem. Jednak jeżeli użyjemy na tej taktyce kombinatora
    <span class="inlinecode"><span class="id" title="var">once</span></span>, to zbiór jej sukcesów zostanie obcięty do co najwyżej jednego

<div class="paragraph"> </div>

    Skoro <span class="inlinecode"><span class="id" title="var">existsNat'</span></span> było równoważne któremuś z <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">0</span>, <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">1</span>,
    <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">2</span>, ..., to <span class="inlinecode"><span class="id" title="var">once</span></span> <span class="inlinecode"><span class="id" title="var">existsNat'</span></span> jest równoważne <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode">0</span>, a
    zatem zawodzi.

<div class="paragraph"> </div>

    Innym sposobem okiełznywania backtrackingu jest kombinator <span class="inlinecode"><span class="id" title="var">exactly_once</span></span>,
    który pozwala upewnić się, że dana taktyka ma dokładnie jeden sukces.
    Jeżeli <span class="inlinecode"><span class="id" title="var">t</span></span> zawodzi, to <span class="inlinecode"><span class="id" title="var">exactly_once</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> zawodzi tak jak <span class="inlinecode"><span class="id" title="var">t</span></span>. Jeżeli <span class="inlinecode"><span class="id" title="var">t</span></span>
    ma jeden sukces, <span class="inlinecode"><span class="id" title="var">exactly_once</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> działa tak jak <span class="inlinecode"><span class="id" title="var">t</span></span>. Jeżeli <span class="inlinecode"><span class="id" title="var">t</span></span> ma dwa
    lub więcej sukcesów, <span class="inlinecode"><span class="id" title="var">exactly_once</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> zawodzi. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="R3.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">exactly_once</span> <span class="id" title="var">existsNat</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="var">exactly_once</span> <span class="id" title="var">existsNat'</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="var">existsNat</span></span>, zrobiona kombinatorem alternatywy <span class="inlinecode">||</span>, ma dokładnie
    jeden sukces, a więc <span class="inlinecode"><span class="id" title="var">exactly_once</span></span> <span class="inlinecode"><span class="id" title="var">existsNat</span></span> działa tak jak <span class="inlinecode"><span class="id" title="var">existsNat</span></span>.
    Z drugiej strony taktyka <span class="inlinecode"><span class="id" title="var">existsNat'</span></span>, zrobiona mogącym dokonywać nawrotów
    kombinatorem alternatywy <span class="inlinecode">+</span>, ma wiele sukcesów i wobec tego
    <span class="inlinecode"><span class="id" title="var">exactly_once</span></span> <span class="inlinecode"><span class="id" title="var">existsNat'</span></span> zawodzi. 
<div class="paragraph"> </div>

<a name="lab157"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Przepisz taktykę <span class="inlinecode"><span class="id" title="var">existsNat'</span></span> za pomocą konstruktu <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">rec</span></span> —
    całość ma wyglądać tak: <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> <span class="inlinecode"><span class="id" title="var">existsNat''</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">rec</span></span> <span class="inlinecode">...</span> 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="R3.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 42.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">existsNat''</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab158"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij poniższe twierdzenie za pomocą pojedynczej taktyki, która
    generuje wszystkie możliwe listy wartości boolowskich. Całość zrób za
    pomocą konstruktu <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">rec</span></span> w miejscu, tj. bez użycia komendy <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#"><span class="id" title="library">List</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
<span class="id" title="keyword">Goal</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">exists</span></a> <span class="id" title="var">l</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#84eb6d2849dbf3581b1c0c05add5f2d8"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#length"><span class="id" title="definition">length</span></a> <a class="idref" href="R3.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 3.<br/>

<br/>
</div>

<div class="doc">
<a name="lab159"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Znajdź taki trywialnie prawdziwy cel i taką taktykę, która wywołuje
    <span class="inlinecode"><span class="id" title="var">existsNat'</span></span>, że taktyka ta nie skończy pracy i nigdy nie znajdzie
    dowodu, mimo że dla człowieka znalezienie dowodu jest banalne. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab160"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">search</span></span>, która potrafi udowodnić poniższe twierdzenia.
    Użyj rekursji, ale nie używaj konstruktu <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">rec</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="search"><span class="id" title="section">search</span></a>.<br/>

<br/>
<span class="id" title="keyword">Hypotheses</span> <a name="search.A"><span class="id" title="variable">A</span></a> <a name="search.B"><span class="id" title="variable">B</span></a> <a name="search.C"><span class="id" title="variable">C</span></a> <a name="search.D"><span class="id" title="variable">D</span></a> <a name="search.E"><span class="id" title="variable">E</span></a> <a name="search.F"><span class="id" title="variable">F</span></a> <a name="search.G"><span class="id" title="variable">G</span></a> <a name="search.H"><span class="id" title="variable">H</span></a> <a name="search.I"><span class="id" title="variable">I</span></a> <a name="search.J"><span class="id" title="variable">J</span></a> : <span class="id" title="keyword">Prop</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="search_0"><span class="id" title="lemma">search_0</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="R3.html#search.I"><span class="id" title="variable">I</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#search.A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.E"><span class="id" title="variable">E</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.I"><span class="id" title="variable">I</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.J"><span class="id" title="variable">J</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">search</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="search_1"><span class="id" title="lemma">search_1</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="R3.html#search.I"><span class="id" title="variable">I</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(((((((</span></a><a class="idref" href="R3.html#search.A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.B"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.D"><span class="id" title="variable">D</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.E"><span class="id" title="variable">E</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.F"><span class="id" title="variable">F</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.G"><span class="id" title="variable">G</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.I"><span class="id" title="variable">I</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.J"><span class="id" title="variable">J</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">search</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="search_2"><span class="id" title="lemma">search_2</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="R3.html#search.F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="R3.html#search.A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.B"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">((</span></a><a class="idref" href="R3.html#search.D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.E"><span class="id" title="variable">E</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="R3.html#search.F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.G"><span class="id" title="variable">G</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">))</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.H"><span class="id" title="variable">H</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.I"><span class="id" title="variable">I</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.J"><span class="id" title="variable">J</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">search</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="search_3"><span class="id" title="lemma">search_3</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="R3.html#search.J"><span class="id" title="variable">J</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.J"><span class="id" title="variable">J</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">((</span></a><a class="idref" href="R3.html#search.A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="R3.html#search.E"><span class="id" title="variable">E</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.E"><span class="id" title="variable">E</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">))))</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">search</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="search_4"><span class="id" title="lemma">search_4</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="R3.html#search.A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#search.A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.E"><span class="id" title="variable">E</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.F"><span class="id" title="variable">F</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.G"><span class="id" title="variable">G</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.I"><span class="id" title="variable">I</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.J"><span class="id" title="variable">J</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">search</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="search_5"><span class="id" title="lemma">search_5</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="R3.html#search.D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a><a class="idref" href="R3.html#search.A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">((</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a><a class="idref" href="R3.html#search.B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="R3.html#search.I"><span class="id" title="variable">I</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#search.I"><span class="id" title="variable">I</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="R3.html#search.J"><span class="id" title="variable">J</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#search.J"><span class="id" title="variable">J</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">))</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="R3.html#search.D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a><a class="idref" href="R3.html#search.D"><span class="id" title="variable">D</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~~</span></a><a class="idref" href="R3.html#search.D"><span class="id" title="variable">D</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="R3.html#search.B"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">))</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">search</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="search_6"><span class="id" title="lemma">search_6</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~~</span></a><a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~~~</span></a><a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">((</span></a><a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a><a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a><a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">/\</span></a> <a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">(</span></a><a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">~</span></a><a class="idref" href="R3.html#search.C"><span class="id" title="variable">C</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">))</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">search</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R3.html#search"><span class="id" title="section">search</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab161"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zbadaj samodzielnie na podstawie dokumentacji, jak działa kombinator
    <span class="inlinecode"><span class="id" title="var">tryif</span></span> <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">t2</span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">t3</span></span>. Wymyśl jakiś mądry przykład, który dobrze
    ukazuje jego działanie w kontraście do <span class="inlinecode">||</span> i <span class="inlinecode">+</span>. 
<div class="paragraph"> </div>

<a name="lab162"></a><h1 class="section">Dopasowanie kontekstu i celu</h1>

<div class="paragraph"> </div>

 Chyba najważniejszym konstruktem Ltaca jest <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode"><span class="id" title="keyword">goal</span></span>, który próbuje
    dopasować kontekst oraz cel do podanych wzorców. Mają one postać
    <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">kontekst</span></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">cel</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">taktyka</span></span> lub podkreślnika, który oznacza "dopasuj
    cokolwiek".

<div class="paragraph"> </div>

    Wyrażenie <span class="inlinecode"><span class="id" title="var">kontekst</span></span> jest listą hipotez, których szukamy w kontekście,
    tzn. jest postaci <span class="inlinecode"><span class="id" title="var">x_1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A_1</span>,</span> <span class="inlinecode"><span class="id" title="var">x_2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A_2</span>...</span>, gdzie <span class="inlinecode"><span class="id" title="var">A_1</span></span> jest wzorcem
    dopasowującym typ pierwszej hipotezy, a <span class="inlinecode"><span class="id" title="var">x_1</span></span> oznacza nazwę, którą
    nadajemy jej jedynie na potrzeby tego konkretnego dopasowania — nie musi
    być ona taka sama jak rzeczywista nazwa występująca w twierdzeniu.

<div class="paragraph"> </div>

    Wyrażenie <span class="inlinecode"><span class="id" title="var">cel</span></span> jest wzorcem dopasowującym typ, który reprezentuje nasz
    cel. Po strzałce <span class="inlinecode">=&gt;</span> następuje taktyka, której chcemy użyć, jeżeli dany
    wzorzec zostanie dopasowany.

<div class="paragraph"> </div>

    Wzorce dopasowujące typ wyglądają prawie tak samo jak wzorce, których
    używamy w definicjach przez pattern matching, ale nazwy zmiennych
    muszą być poprzedzone symbolem <span class="inlinecode">?</span>, zaś same wzorce mogą być nieliniowe,
    czyli te same zmienne mogą występować w wielu różnych miejscach.

<div class="paragraph"> </div>

    Uff, koniec wesołej pisaninki — zobaczmy w końcu przykłady! 
<div class="paragraph"> </div>

<a name="lab163"></a><h2 class="section">Dopasowanie kontekstu</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="Match"><span class="id" title="section">Match</span></a>.<br/>

<br/>
<span class="id" title="keyword">Goal</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#S"><span class="id" title="variable">S</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="keyword">Prop</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">idtac</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
W powyższym przykładzie szukamy w celu zdań logicznych, czyli termów
    typu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> i wypisujemy je. Nazwy szukanych obiektów są lokalne dla
    każdej gałęzi dopasowania i nie muszą pokrywać się z rzeczywistymi
    nazwami termów w kontekście. W naszym przypadku nazywamy szukane przez
    nas zdanie <span class="inlinecode"><span class="id" title="var">x</span></span>, choć zdania obecne w naszym kontekście tak naprawdę
    nazywają się <span class="inlinecode"><span class="id" title="var">P</span></span>, <span class="inlinecode"><span class="id" title="var">Q</span></span>, <span class="inlinecode"><span class="id" title="var">R</span></span> oraz <span class="inlinecode"><span class="id" title="var">S</span></span>.

<div class="paragraph"> </div>

    Przeszukiwanie obiektów w kontekście odbywa się w kolejności od
    najnowszego do najstarszego. Do wzorca <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> najpierw próbujemy
    dopasować <span class="inlinecode"><span class="id" title="var">H1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">R</span></span>, ale <span class="inlinecode"><span class="id" title="var">R</span></span> to nie <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, więc dopasowanie zawodzi.
    Podobnie dla <span class="inlinecode"><span class="id" title="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> oraz <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Następnie natrafiamy na <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>,
    które pasuje do wzorca. Dzięki temu na prawo od strzałki <span class="inlinecode">=&gt;</span> nazwa <span class="inlinecode"><span class="id" title="var">x</span></span>
    odnosi się do dopasowanego zdania <span class="inlinecode"><span class="id" title="var">S</span></span>. Za pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">idtac</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>
    wyświetlamy <span class="inlinecode"><span class="id" title="var">x</span></span> i faktycznie odnosi się on do <span class="inlinecode"><span class="id" title="var">S</span></span>. Po skutecznym
    dopasowaniu i wykonaniu taktyki <span class="inlinecode"><span class="id" title="tactic">idtac</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> cały <span class="inlinecode"><span class="id" title="keyword">match</span></span> kończy się
    sukcesem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#S"><span class="id" title="variable">S</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="keyword">Prop</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">idtac</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">fail</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
W tym przykładzie podobnie jak wyżej szukamy w kontekście zdań logicznych,
    ale taktyka po prawej od <span class="inlinecode">=&gt;</span> zawodzi. <span class="inlinecode"><span class="id" title="keyword">match</span></span> działa tutaj następująco:
<ul class="doclist">
<li> próbujemy do wzorca <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> dopasować <span class="inlinecode"><span class="id" title="var">H1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">R</span></span>, ale bez powodzenia
      i podobnie dla <span class="inlinecode"><span class="id" title="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> oraz <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span>.

</li>
<li> znajdujemy dopasowanie <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. Taktyka <span class="inlinecode"><span class="id" title="tactic">idtac</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> wypisuje do okna
      Messages wiadomość "S" i kończy się sukcesem, ale <span class="inlinecode"><span class="id" title="tactic">fail</span></span> zawodzi.

</li>
<li> Wobec powyższego próbujemy kolejnego dopasowania, tym razem <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>,
      które pasuje. <span class="inlinecode"><span class="id" title="tactic">idtac</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> wypisuje na ekran "R", ale <span class="inlinecode"><span class="id" title="tactic">fail</span></span> znów
      zawodzi.

</li>
<li> Próbujemy kolejno dopasowań <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> i <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, w wyniku których
      wypisane zostaje "Q" oraz "P", ale również w tych dwóch przypadkach
      taktyka <span class="inlinecode"><span class="id" title="tactic">fail</span></span> zawodzi.

</li>
<li> Nie ma więcej potencjalnych dopasowań, więc cały <span class="inlinecode"><span class="id" title="keyword">match</span></span> zawodzi. 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#S"><span class="id" title="variable">S</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="keyword">match</span> <span class="id" title="var">reverse</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="keyword">Prop</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">idtac</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">fail</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Ten przykład jest podobny do ostatniego, ale <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode"><span class="id" title="var">reverse</span></span> przeszukuje
    kontekst w kolejności od najstarszego do najnowszego. Dzięki temu od razu
    natrafiamy na dopasowanie <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, potem na <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> etc. Na samym
    końcu próbujemy do <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> dopasować <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span>, <span class="inlinecode"><span class="id" title="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> i <span class="inlinecode"><span class="id" title="var">H1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">R</span></span>, co
    kończy się niepowodzeniem.

<div class="paragraph"> </div>

    Zauważmy, że w dwóch ostatnich przykładach nie wystąpił backtracking —
    <span class="inlinecode"><span class="id" title="keyword">match</span></span> nigdy nie wyzwala backtrackingu. Obserwowane działanie <span class="inlinecode"><span class="id" title="keyword">match</span></span>a
    wynika stąd, że jeżeli taktyka po prawej od <span class="inlinecode">=&gt;</span> zawiedzie, to następuje
    próba znalezienia jakiegoś innego dopasowania wzorca <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. Dopiero
    gdy taktyka na prawo od <span class="inlinecode">=&gt;</span> zawiedzie dla wszystkich możliwych takich
    dopasowań, cały <span class="inlinecode"><span class="id" title="keyword">match</span></span> zawodzi. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#S"><span class="id" title="variable">S</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="keyword">Prop</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">idtac</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="tactic">fail</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Ten przykład potwierdza naszą powyższą obserwację dotyczącą backtrackingu.
    Mamy tutaj identyczne dopasowanie jak w pierwszym przykładzie — wypisuje
    ono <span class="inlinecode"><span class="id" title="var">S</span></span> i kończy się sukcesem, ale tuż po nim następuje taktyka <span class="inlinecode"><span class="id" title="tactic">fail</span></span>,
    przez co cała taktyka <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode">...;</span> <span class="inlinecode"><span class="id" title="tactic">fail</span></span> zawodzi. Jak widać, nie następuje
    próba ponownego dopasownia wzorca <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#S"><span class="id" title="variable">S</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">lazymatch</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="keyword">Prop</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">idtac</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">fail</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Konstrukt <span class="inlinecode"><span class="id" title="keyword">lazymatch</span></span> różni się od <span class="inlinecode"><span class="id" title="keyword">match</span></span>a tym, że jeżeli taktyka na
    prawo od <span class="inlinecode">=&gt;</span> zawiedzie, to alternatywne dopasowania wzorca po lewej
    nie będą rozważane i nastąpi przejście do kolejnej gałęzi dopasowania.
    W naszym przypadku nie ma kolejnych gałęzi, więc po pierwszym dopasowaniu
    <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> do <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> i wypisaniu "S" cały <span class="inlinecode"><span class="id" title="keyword">lazymatch</span></span> zawodzi. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#S"><span class="id" title="variable">S</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span><br/>
&nbsp;&nbsp;<span class="id" title="var">multimatch</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="keyword">Prop</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">idtac</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="tactic">fail</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">multimatch</span></span> to wariant <span class="inlinecode"><span class="id" title="keyword">match</span></span>a, który wyzwala backtracking. W powyższym
    przykładzie działa on następująco:
<ul class="doclist">
<li> do wzorca <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> dopasowujemy <span class="inlinecode"><span class="id" title="var">H1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">R</span></span>, a następnie <span class="inlinecode"><span class="id" title="var">H0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Q</span></span> i
      <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span>, co się rzecz jasna nie udaje.

</li>
<li> Znajdujemy dopasowanie <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> i cały <span class="inlinecode"><span class="id" title="var">multimatch</span></span> kończy się
      sukcesem.

</li>
<li> Taktyka <span class="inlinecode"><span class="id" title="tactic">fail</span></span> zawodzi i wobec tego cała taktyka <span class="inlinecode"><span class="id" title="var">multimatch</span></span> <span class="inlinecode">...;</span> <span class="inlinecode"><span class="id" title="tactic">fail</span></span>
      taże zawodzi.

</li>
<li> Następuje nawrót i znów próbujemy znaleźć dopasowanie wzorca <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.
      Znajdujemy <span class="inlinecode"><span class="id" title="var">R</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, <span class="inlinecode"><span class="id" title="var">multimatch</span></span> kończy się sukcesem, ale <span class="inlinecode"><span class="id" title="tactic">fail</span></span>
      zawodzi.

</li>
<li> Następują kolejne nawroty i dopasowania do wzorca. Ostatecznie po
      wyczerpaniu się wszystkich możliwość cała taktyka zawodzi. 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span> <span class="id" title="var">S</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#R"><span class="id" title="variable">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#S"><span class="id" title="variable">S</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="keyword">Prop</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">idtac</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">multimatch</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="keyword">Prop</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">idtac</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="keyword">Prop</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">idtac</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">multimatch</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> : <span class="id" title="keyword">Prop</span> |- <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">idtac</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Przyjrzyjmy się jeszcze różnicy w zachowaniach <span class="inlinecode"><span class="id" title="keyword">match</span></span>a i <span class="inlinecode"><span class="id" title="var">multimatch</span></span>a
    w połączeniu z kombinatorem <span class="inlinecode"><span class="id" title="tactic">repeat</span></span>. Bez <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> oba dopasowania
    zachowują się identycznie. Użycie <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> przed <span class="inlinecode"><span class="id" title="keyword">match</span></span> nie zmienia w
    tym konkretnym wypadku jego działania, ale w przypadku <span class="inlinecode"><span class="id" title="var">multimatch</span></span>a
    użycie <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> ujawnia wszystkie jego sukcesy.

<div class="paragraph"> </div>

    Źródło różnego zachowania <span class="inlinecode"><span class="id" title="keyword">match</span></span>a i <span class="inlinecode"><span class="id" title="var">multimatch</span></span>a, jeżeli chodzi o
    backtracking, jest bardzo proste: tak naprawdę <span class="inlinecode"><span class="id" title="keyword">match</span></span> jest jedynie
    skrótem dla <span class="inlinecode"><span class="id" title="var">once</span></span> <span class="inlinecode"><span class="id" title="var">multimatch</span></span>. 
<div class="paragraph"> </div>

<a name="lab164"></a><h2 class="section">Dopasowanie celu</h2>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab165"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisz taktykę <span class="inlinecode"><span class="id" title="var">my_assumption</span></span>, która działa tak samo, jak <span class="inlinecode"><span class="id" title="tactic">assumption</span></span>.
    Nie używaj <span class="inlinecode"><span class="id" title="tactic">assumption</span></span> — użyj <span class="inlinecode"><span class="id" title="keyword">match</span></span>a. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Goal</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="R3.html#P"><span class="id" title="variable">P</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">my_assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="R3.html#Match"><span class="id" title="section">Match</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab166"></a><h1 class="section">Dopasowanie termu</h1>

<div class="paragraph"> </div>

<a name="lab167"></a><h1 class="section">Inne wesołe rzeczy</h1>

</div>
<div class="code">
</div>
