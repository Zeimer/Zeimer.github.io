<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-88023543-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<h1 class="libtitle">X6: Rozdział z odpadami z R2</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab455"></a><h1 class="section">Parametryczność</h1>

<div class="paragraph"> </div>

 UWAGA TODO: ten podrozdział zawiera do pewnego stopnia kłamstwa (tzn.
    dość uproszczony punkt widzenia). 
<div class="paragraph"> </div>

 Niech <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Zadajmy sobie następujące pytanie: ile jest funkcji
    typu <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>? Żeby ułatwić sobie zadanie, ograniczmy się jedynie do
    typów, które mają skończoną ilość elementów.

<div class="paragraph"> </div>

    Nietrudno przekonać się, że ich ilość to |B|^|A|, gdzie ^ oznacza
    potęgowanie, zaś |T| to ilość elementów typu <span class="inlinecode"><span class="id" title="var">T</span></span> (ta notacja nie ma
    nic wspólnego z Coqiem — zaadaptowałem ją z teorii zbiorów jedynie
    na potrzeby tego podrozdziału).

<div class="paragraph"> </div>

    Udowodnić ten fakt możesz (choć póki co nie w Coqu) posługując się
    indukcją po ilości elementów typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Jeżeli <span class="inlinecode"><span class="id" title="var">A</span></span> jest pusty, to
    jest tylko jedna taka funkcja, o czym przekonałeś się już podczas
    ćwiczeń w podrozdziale o typie <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>. 
<div class="paragraph"> </div>

<a name="lab456"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij (nieformalnie, na papierze), że w powyższym akapicie nie
    okłamałem cię. 
<div class="paragraph"> </div>

<a name="lab457"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj wszystkie możliwe funkcje typu <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span>, <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    i <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
<div class="paragraph"> </div>

 Postawmy sobie teraz trudniejsze pytanie: ile jest funkcji typu
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>? W udzieleniu odpowiedzi pomoże nam
    parametryczność — jedna z właściwości Coqowego polimorfizmu.

<div class="paragraph"> </div>

    Stwierdzenie, że polimorfizm w Coqu jest parametryczny, oznacza, że
    funkcja biorąca typ jako jeden z argumentów działa w taki sam sposób
    niezależnie od tego, jaki typ przekażemy jej jako argument.

<div class="paragraph"> </div>

    Konsekwencją tego jest, że funkcje polimorficzne nie wiedzą (i nie
    mogą wiedzieć), na wartościach jakiego typu operują. Wobec tego
    elementem typu <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> nie może być funkcja, która
    np. dla typu <span class="inlinecode"><span class="id" title="var">nat</span></span> stale zwraca <span class="inlinecode">42</span>, a dla innych typów po prostu
    zwraca przekazany jej argument.

<div class="paragraph"> </div>

    Stąd konkludujemy, że typ <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> ma tylko jeden
    element, a mianowicie polimorficzną funkcję identycznościową. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">id'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Set</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Set</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) =&gt; <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab458"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj wszystkie elementy następujących typów lub udowodnij, że
    istnienie choć jednego elementu prowadzi do sprzeczności:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">sum</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">C</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
TODO: tu opisać kłamstwo 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">path</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">idpath</span> : <span class="id" title="var">path</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">idpath</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span>.<br/>

<br/>
<span class="id" title="keyword">Axiom</span> <span class="id" title="var">LEM</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>), <span class="id" title="var">A</span> + (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">Empty_set</span>).<br/>

<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bad'</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) :<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id" title="var">path</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">bool</span> <span class="id" title="var">A</span> * <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> &lt;&gt; <span class="id" title="var">x</span>) +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;((@<span class="id" title="var">path</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">bool</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Empty_set</span>) * <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">x</span>)}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">LEM</span> (@<span class="id" title="var">path</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">bool</span> <span class="id" title="var">A</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>. <span class="id" title="var">esplit</span> <span class="id" title="keyword">with</span> <span class="id" title="var">negb</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (@<span class="id" title="var">idpath</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">bool</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">esplit</span> <span class="id" title="keyword">with</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">x</span>). <span class="id" title="tactic">right</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bad</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> := <span class="id" title="var">projT1</span> (<span class="id" title="var">bad'</span> <span class="id" title="var">A</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bad_is_bad</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">bad</span> <span class="id" title="var">bool</span> <span class="id" title="var">b</span> &lt;&gt; <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">bad</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">bad'</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span> <span class="id" title="keyword">as</span> [[<span class="id" title="var">p</span> <span class="id" title="var">H</span>] | [<span class="id" title="var">p</span> <span class="id" title="var">H</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">p</span> (<span class="id" title="var">idpath</span> <span class="id" title="var">_</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bad_ist_gut</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id" title="var">path</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">bool</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Empty_set</span>) -&gt; <span class="id" title="var">bad</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> = <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">bad</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">bad'</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">f</span> [[<span class="id" title="var">q</span> <span class="id" title="var">H</span>] | [<span class="id" title="var">q</span> <span class="id" title="var">H</span>]]]; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">p</span> <span class="id" title="var">q</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab459"></a><h1 class="section">Rozstrzygalność</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">excluded_middle</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> \/ ~ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">left</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">intro</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Próba udowodnienia tego twierdzenia pokazuje nam zasadniczą różnicę
    między logiką konstruktywną, która jest domyślną logiką Coqa, oraz
    logiką klasyczną, najpowszechniej znanym i używanym rodzajem logiki.

<div class="paragraph"> </div>

    Każde zdanie jest, w pewnym "filozoficznym" sensie, prawdziwe lub
    fałszywe i to właśnie powyższe zdanie oznacza w logice klasycznej.
    Logika konstruktywna jednak, jak już wiemy, nie jest logiką prawdy,
    lecz logiką udowadnialności i ma swoją interpretację obliczeniową.
    Powyższe zdanie w logice konstruktywnej oznacza: program komputerowy
    <span class="inlinecode"><span class="id" title="var">exluded_middle</span></span> rozstrzyga, czy dowolne zdanie jest prawdziwe, czy
    fałszywe.

<div class="paragraph"> </div>

    Skonstruowanie programu o takim typie jest w ogólności niemożliwe,
    gdyż dysponujemy zbyt małą ilością informacji: nie wiemy czym jest
    zdanie <span class="inlinecode"><span class="id" title="var">P</span></span>, a nie posiadamy żadnego ogólnego sposobu dowodzenia lub
    obalania zdań o nieznanej nam postaci. Nie możemy np. użyć indukcji,
    gdyż nie wiemy, czy zdanie <span class="inlinecode"><span class="id" title="var">P</span></span> zostało zdefiniowane induktywnie, czy
    też nie. W Coqu jedynym sposobem uzyskania termu o typie <span class="inlinecode"><span class="id" title="keyword">forall</span></span>
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> jest przyjęcie go jako aksjomat. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">True_dec</span> : <span class="id" title="var">True</span> \/ ~ <span class="id" title="var">True</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">left</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższe dywagacje nie przeszkadzają nam jednak w udowadnianiu,
    że reguła wyłączonego środka zachodzi dla pewnych konkretnych
    zdań. Zdanie takie będziemy nazywać zdaniami rozstrzygalnymi
    (ang. decidable). O pozostałych zdaniach będziemy mówić, że są 
    nierozstrzygalne (ang. undecidable). Ponieważ w Coqu wszystkie
    funkcje są rekurencyjne, a dowody to programy, to możemy powyższą
    definicję rozumieć tak: zdanie jest rozstrzygalne, jeżeli istnieje
    funkcja rekurencyjna o przeciwdzidzinie <span class="inlinecode"><span class="id" title="var">bool</span></span>, która sprawdza, czy
    jest ono prawdziwe, czy fałszywe.

<div class="paragraph"> </div>

    Przykładami zdań, predykatów czy problemów rozstrzygalnych są:
<ul class="doclist">
<li> sprawdzanie, czy lista jest niepusta

</li>
<li> sprawdzanie, czy liczba naturalna jest parzysta

</li>
<li> sprawdzanie, czy dwie liczby naturalne są równe 
</li>
</ul>

<div class="paragraph"> </div>

 Przykładem problemów nierozstrzygalnych są:
<ul class="doclist">
<li> dla funkcji <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> sprawdzenie, czy
      <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> — jest to w ogólności niemożliwe,
      gdyż wymaga wykonania nieskończonej ilości porównań (co nie
      znaczy, że nie da się rozwiązać tego problemu dla niektórych
      funkcji)

</li>
<li> sprawdzenie, czy słowo o nieskończonej długości jest palindromem 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab460"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_nat_dec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = <span class="id" title="var">m</span> \/ ~ <span class="id" title="var">n</span> = <span class="id" title="var">m</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab461"></a><h2 class="section">Techniczne apekty rozstrzygalności</h2>

<div class="paragraph"> </div>

 Podsumowując powyższe rozważania, moglibyśmy stwierdzić: zdanie <span class="inlinecode"><span class="id" title="var">P</span></span> jest
    rozstrzygalne, jeżeli istnieje term typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Stwierdzenie takie
    nie zamyka jednak sprawy, gdyż bywa czasem mocno bezużyteczne.

<div class="paragraph"> </div>

    Żeby to zobrazować, spróbujmy użyć twierdzenia <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span> do napisania
    funkcji, która sprawdza, czy liczna naturalna <span class="inlinecode"><span class="id" title="var">n</span></span> występuje na liście
    liczb naturalnych <span class="inlinecode"><span class="id" title="var">l</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">inb_nat</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">eq_nat_dec</span> <span class="id" title="var">n</span> <span class="id" title="var">h</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_introl</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">inb_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Coq nie akceptuje powyższego kodu, racząc nas informacją o błędzie: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Error:<br/>
&nbsp;&nbsp;&nbsp;Incorrect&nbsp;elimination&nbsp;of&nbsp;"eq_nat_dec&nbsp;n&nbsp;h0"&nbsp;in&nbsp;the&nbsp;inductive&nbsp;type&nbsp;"or":<br/>
&nbsp;&nbsp;&nbsp;the&nbsp;return&nbsp;type&nbsp;has&nbsp;sort&nbsp;"Set"&nbsp;while&nbsp;it&nbsp;should&nbsp;be&nbsp;"Prop".<br/>
&nbsp;&nbsp;&nbsp;Elimination&nbsp;of&nbsp;an&nbsp;inductive&nbsp;object&nbsp;of&nbsp;sort&nbsp;Prop<br/>
&nbsp;&nbsp;&nbsp;is&nbsp;not&nbsp;allowed&nbsp;on&nbsp;a&nbsp;predicate&nbsp;in&nbsp;sort&nbsp;Set<br/>
&nbsp;&nbsp;&nbsp;because&nbsp;proofs&nbsp;can&nbsp;be&nbsp;eliminated&nbsp;only&nbsp;to&nbsp;build&nbsp;proofs.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Nasza porażka wynika z faktu, że do zdefiniowania funkcji, która
    jest programem (jej dziedzina i przeciwdziedzina są sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>)
    próbowaliśmy użyć termu <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>, który jest dowodem
    (konkluzją <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span> jest równość, która jest sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>).

<div class="paragraph"> </div>

    Mimo korespondencji Curry'ego-Howarda, która odpowiada za olbrzymie
    podobieństwo specyfikacji i zdań, programów i dowodów, sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>
    i sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, są one rozróżniane i niesie to za sobą konsekwencje:
    podczas gdy programów możemy używać wszędzie, dowodów możemy używać
    jedynie do konstruowania innych dowodów.

<div class="paragraph"> </div>

    Praktycznie oznacza to, że mimo iż równość liczb naturalnych jest
    rozstrzygalna, pisząc program nie mamy możliwości jej rozstrzygania
    za pomocą <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span>. To właśnie miałem na myśli pisząc, że termy
    typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> są mocno bezużyteczne.

<div class="paragraph"> </div>

    Uszy do góry: nie wszystko stracone! Jest to tylko drobna przeszkoda,
    którą bardzo łatwo ominąć: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sumbool</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">left</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">sumbool</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">right</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">sumbool</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">sumbool</span></span> jest niemal dokładną kopią <span class="inlinecode"><span class="id" title="var">or</span></span>, jednak nie żyje on
    w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, lecz w <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Ta drobna sztuczka, że termy typu
    <span class="inlinecode"><span class="id" title="var">sumbool</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> formalnie są programami, mimo że ich naturalna
    interpretacja jest taka sama jak <span class="inlinecode"><span class="id" title="var">or</span></span>, a więc jako dowodu
    dysjunkcji. 
<div class="paragraph"> </div>

<a name="lab462"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij twierdzenie <span class="inlinecode"><span class="id" title="var">eq_nat_dec'</span></span> o rozstrzygalności <span class="inlinecode">=</span> na
    liczbach naturalnych. Użyj typu <span class="inlinecode"><span class="id" title="var">sumbool</span></span>. Następnie napisz
    funkcję <span class="inlinecode"><span class="id" title="var">inb_nat</span></span>, która sprawdza, czy liczba naturalna <span class="inlinecode"><span class="id" title="var">n</span></span>
    jest obecna na liście <span class="inlinecode"><span class="id" title="var">l</span></span>. 
<div class="paragraph"> </div>

<a name="lab463"></a><h1 class="section">Pięć rodzajów reguł</h1>

<div class="paragraph"> </div>

 Być może jeszcze tego nie zauważyłeś, ale większość logiki konstruktywnej,
    programowania funkcyjnego, a przede wszystkim teorii typów kręci się wokół
    pięciu rodzajów reguł.
    Są to reguły:
<ul class="doclist">
<li> formacji (ang. formation rules)

</li>
<li> wprowadzania (ang. introduction rules)

</li>
<li> eliminacji (ang. elimination rules)

</li>
<li> obliczania (ang. computation rules)

</li>
<li> unikalności (ang. uniqueness principles) 
</li>
</ul>

<div class="paragraph"> </div>

 W tym podrozdziale przyjrzymy się wszystkim pięciu typom reguł. Zobaczymy
    jak wyglądają, skąd się biorą i do czego służą. Podrozdział będzie miał
    charakter mocno teoretyczny. 
<div class="paragraph"> </div>

<a name="lab464"></a><h2 class="section">Reguły formacji</h2>

<div class="paragraph"> </div>

 Reguły formacji mówią nam, jak tworzyć typy (termy sortów <span class="inlinecode"><span class="id" title="keyword">Set</span></span> i <span class="inlinecode"><span class="id" title="keyword">Type</span></span>)
    oraz zdania (termy sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>). Większość z nich pochodzi z nagłówków
    definicji induktywnych. Reguła dla typu <span class="inlinecode"><span class="id" title="var">bool</span></span> wygląda tak: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;----------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;:&nbsp;Set&nbsp;<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Ten mistyczny zapis pochodzi z publikacji dotyczących teorii typów.
    Nad kreską znajdują się przesłanki reguły, a pod kreską znajduje się
    konkluzja reguły.

<div class="paragraph"> </div>

    Regułę tę możemy odczytać: <span class="inlinecode"><span class="id" title="var">bool</span></span> jest typem sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Postać tej
    reguły wynika wprost z definicji typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">bool</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;bool&nbsp;:&nbsp;Set&nbsp;:=&nbsp;&nbsp;true&nbsp;:&nbsp;bool&nbsp;|&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Powyższej regule formacji odpowiada tutaj fragment <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span>,
    który stwierdza po prostu, że <span class="inlinecode"><span class="id" title="var">bool</span></span> jest typem sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>.

<div class="paragraph"> </div>

    Nie zawsze jednak reguły formacji są aż tak proste. Reguła dla produktu
    wygląda tak: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;B&nbsp;:&nbsp;Type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;prod&nbsp;A&nbsp;B&nbsp;:&nbsp;Type<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguła formacji dla <span class="inlinecode"><span class="id" title="var">prod</span></span> głosi: jeżeli <span class="inlinecode"><span class="id" title="var">A</span></span> jest typem sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    oraz <span class="inlinecode"><span class="id" title="var">B</span></span> jest typem sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, to <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest typem sortu
    <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Jest ona rzecz jasna konsekwencją definicji produktu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">prod</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Inductive&nbsp;prod&nbsp;(A&nbsp;B&nbsp;:&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pair&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;*&nbsp;B&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Regule odpowiada fragment <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. To,
    co w regule jest nad kreską (<span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>), tutaj występuje
    przed dwukropkiem, po prostu jako argumentu typu <span class="inlinecode"><span class="id" title="var">prod</span></span>. Jak widać,
    nagłówek typu induktywnego jest po prostu skompresowaną formą reguły
    formacji.

<div class="paragraph"> </div>

    Należy zauważyć, że nie wszystkie reguły formacji pochodzą z definicji
    induktywnych. Tak wygląda reguła formacji dla funkcji (między typami
    sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>): 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;B&nbsp;:&nbsp;Type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;:&nbsp;Type<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguła nie pochodzi z definicji induktywnej, gdyż typ funkcji <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>
    jest typem wbudowanym i nie jest zdefiniowany indukcyjnie. 
<div class="paragraph"> </div>

<a name="lab465"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisz, bez podglądania, jak wyglądają reguły formacji dla <span class="inlinecode"><span class="id" title="var">option</span></span>,
    <span class="inlinecode"><span class="id" title="var">nat</span></span> oraz <span class="inlinecode"><span class="id" title="var">list</span></span>. Następnie zweryfikuj swoje odpowiedzi za pomocą
    komendy <span class="inlinecode"><span class="id" title="keyword">Print</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab466"></a><h2 class="section">Reguły wprowadzania</h2>

<div class="paragraph"> </div>

 Reguły wprowadzania mówią nam, w jaki sposób formować termy danego
    typu. Większość z nich pochodzi od konstruktorów typów induktywnych.
    Dla typu bool reguły wprowadzania wyglądają tak: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-----------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;true&nbsp;:&nbsp;bool<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;false&nbsp;:&nbsp;bool<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguły te stwierdzają po prostu, że <span class="inlinecode"><span class="id" title="var">true</span></span> jest termem typu <span class="inlinecode"><span class="id" title="var">bool</span></span>
    oraz że <span class="inlinecode"><span class="id" title="var">false</span></span> jest termem typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. Wynikają one wprost z
    definicji typu <span class="inlinecode"><span class="id" title="var">bool</span></span> — każda z nich odpowiada jednemu konstruktorowi.

<div class="paragraph"> </div>

    Wobec powyższego nie powinna zaskoczyć cię reguła wprowadzania dla
    produktu: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;B&nbsp;:&nbsp;Type,&nbsp;a&nbsp;:&nbsp;A,&nbsp;b&nbsp;:&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;--------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;pair&nbsp;A&nbsp;B&nbsp;a&nbsp;b&nbsp;:&nbsp;prod&nbsp;A&nbsp;B<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Jeżeli jednak zaskoczyła cię obecność w regule <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>,
    przyjrzyj się dokładnie typowi konstruktora <span class="inlinecode"><span class="id" title="var">pair</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> @<span class="id" title="var">pair</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;pair&nbsp;:&nbsp;forall&nbsp;A&nbsp;B&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;-&gt;&nbsp;A&nbsp;*&nbsp;B&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Widać tutaj jak na dłoni, że <span class="inlinecode"><span class="id" title="var">pair</span></span> jest funkcją zależną biorącą
    cztery argumenty i zwracają wynik, którego typ jest produktem jej
    dwóch pierwszych argumentów.

<div class="paragraph"> </div>

    Podobnie jak w przypadku reguł formacji, nie wszystkie reguły
    wprowadzania pochodzą od konstruktorów typów induktywnych. W
    przypadku funkcji reguła wygląda mniej więcej tak: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Γ&nbsp;|-&nbsp;A&nbsp;-&gt;&nbsp;B&nbsp;:&nbsp;Type,&nbsp;Γ;&nbsp;x&nbsp;:&nbsp;T&nbsp;|-&nbsp;y&nbsp;:&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Γ&nbsp;|-&nbsp;fun&nbsp;x&nbsp;=&gt;&nbsp;y&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Pojawiło się tu kilka nowych rzeczy: litera Γ oznacza kontekst,
    zaś zapis Γ |- j, że osąd j zachodzi w kontekście Γ. Zapis Γ; j
    oznacza rozszerzenie kontekstu Γ poprzez dodanie do niego osądu j.

<div class="paragraph"> </div>

    Regułę możemy odczytać tak: jeżeli <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> jest typem sortu <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    w kontekście Γ i <span class="inlinecode"><span class="id" title="var">y</span></span> jest termem typu <span class="inlinecode"><span class="id" title="var">B</span></span> w kontekście Γ rozszerzonym
    o osąd <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">T</span></span>, to <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">y</span></span> jest termem typu <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> w kontekście
    Γ.

<div class="paragraph"> </div>

    Powyższa reguła nazywana jest "lambda abstrakcją" (gdyż zazwyczaj jest
    zapisywana przy użyciu symbolu λ zamiast słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">fun</span></span>, jak
    w Coqu). Nie przejmuj się, jeżeli jej. Znajomość reguł wprowadzania nie
    jest nam potrzebna, by skutecznie posługiwać się Coqiem.

<div class="paragraph"> </div>

    Należy też dodać, że reguła ta jest nieco uproszczona. Pełniejszy
    opis teoretyczny induktywnego rachunku konstrukcji można znaleźć
    w rozdziałach 4 i 5 manuala: https://coq.inria.fr/refman/toc.html 
<div class="paragraph"> </div>

<a name="lab467"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisz (bez podglądania) jak wyglądają reguły wprowadzania dla
    <span class="inlinecode"><span class="id" title="var">option</span></span>, <span class="inlinecode"><span class="id" title="var">nat</span></span> oraz <span class="inlinecode"><span class="id" title="var">list</span></span>. Następnie zweryfikuj swoje odpowiedzi
    za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Print</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab468"></a><h2 class="section">Reguły eliminacji</h2>

<div class="paragraph"> </div>

 Reguły eliminacji są w pewien sposób dualne do reguł wprowadzania.
    Tak jak reguły wprowadzania dla typu <span class="inlinecode"><span class="id" title="var">T</span></span> służą do konstruowania
    termów typu <span class="inlinecode"><span class="id" title="var">T</span></span> z innych termów, tak reguły eliminacji dla typu <span class="inlinecode"><span class="id" title="var">T</span></span>
    mówią nam, jak z termów typu <span class="inlinecode"><span class="id" title="var">T</span></span> skonstruować termy innych typów.

<div class="paragraph"> </div>

    Zobaczmy, jak wygląda jedna z reguł eliminacji dla typu <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;x&nbsp;:&nbsp;A,&nbsp;y&nbsp;:&nbsp;A,&nbsp;b&nbsp;:&nbsp;bool<br/>
&nbsp;&nbsp;&nbsp;&nbsp;--------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;b&nbsp;then&nbsp;x&nbsp;else&nbsp;y&nbsp;:&nbsp;A<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguła ta mówi nam, że jeżeli mamy typ <span class="inlinecode"><span class="id" title="var">A</span></span> oraz dwie wartości
    <span class="inlinecode"><span class="id" title="var">x</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>, a także term <span class="inlinecode"><span class="id" title="var">b</span></span> typu <span class="inlinecode"><span class="id" title="var">bool</span></span>, to możemy
    skonstruować inną wartość typu <span class="inlinecode"><span class="id" title="var">A</span></span>, mianowicie <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>
    <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>.

<div class="paragraph"> </div>

    Reguła ta jest dość prosta. W szczególności nie jest ona zależna,
    tzn. obie gałęzie <span class="inlinecode"><span class="id" title="keyword">if</span></span>a muszą być tego samego typu. Przyjrzyjmy
    się nieco bardziej ogólnej regule. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Type,&nbsp;x&nbsp;:&nbsp;P&nbsp;true,&nbsp;y&nbsp;:&nbsp;P&nbsp;false,&nbsp;b&nbsp;:&nbsp;bool<br/>
&nbsp;&nbsp;&nbsp;&nbsp;----------------------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;bool_rect&nbsp;P&nbsp;x&nbsp;y&nbsp;b&nbsp;:&nbsp;P&nbsp;b<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguła ta mówi nam, że jeżeli mamy rodzinę typów <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>
    oraz termy <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> i <span class="inlinecode"><span class="id" title="var">y</span></span> typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span>, a także term <span class="inlinecode"><span class="id" title="var">b</span></span>
    typu <span class="inlinecode"><span class="id" title="var">bool</span></span>, to możemy skonstruować term <span class="inlinecode"><span class="id" title="var">bool_rect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> typu
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>.

<div class="paragraph"> </div>

    Spójrzmy na tę regułę z nieco innej strony: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Type,&nbsp;x&nbsp;:&nbsp;P&nbsp;true,&nbsp;y&nbsp;:&nbsp;P&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;----------------------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;bool_rect&nbsp;P&nbsp;x&nbsp;y&nbsp;:&nbsp;forall&nbsp;b&nbsp;:&nbsp;bool,&nbsp;P&nbsp;b<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Widzimy, że reguły eliminacji dla typu induktywnego <span class="inlinecode"><span class="id" title="var">T</span></span> służą do
    konstruowania funkcji, których dziedziną jest <span class="inlinecode"><span class="id" title="var">T</span></span>, a więc mówią
    nam, jak "wyeliminować" term typu <span class="inlinecode"><span class="id" title="var">T</span></span>, aby uzyskać term innego typu. 

<div class="paragraph"> </div>

    Reguły eliminacji występują w wielu wariantach:
<ul class="doclist">
<li> zależnym i niezależnym — w zależności od tego, czy służą do definiowania
      funkcji zależnych, czy nie.

</li>
<li> rekurencyjnym i nierekurencyjnym — te druge służą jedynie do
      przeprowadzania rozumowań przez przypadki oraz definiowania funkcji
      przez pattern matching, ale bez rekurencji. Niektóre typy nie mają
      rekurencyjnych reguł eliminacji.

</li>
<li> pierwotne i wtórne — dla typu induktywnego <span class="inlinecode"><span class="id" title="var">T</span></span> Coq generuje regułę
      <span class="inlinecode"><span class="id" title="var">T_rect</span></span>, którą będziemy zwać regułą pierwotną. Jej postać wynika
      wprost z definicji typu <span class="inlinecode"><span class="id" title="var">T</span></span>. Reguły dla typów nieinduktywnych (np.
      funkcji) również będziemy uważać za pierwotne. Jednak nie wszystkie
      reguły są pierwotne — przekonamy się o tym w przyszłości, tworząc
      własne reguły indukcyjne.

</li>
</ul>

<div class="paragraph"> </div>

 Zgodnie z zaprezentowaną klasyfikacją, pierwsza z naszych reguł jest:
<ul class="doclist">
<li> niezależna, gdyż obie gałęzie <span class="inlinecode"><span class="id" title="keyword">if</span></span>a są tego samego typu. Innymi słowy,
      definiujemy term typu <span class="inlinecode"><span class="id" title="var">A</span></span>, który nie jest zależny

</li>
<li> nierekurencyjna, gdyż typ <span class="inlinecode"><span class="id" title="var">bool</span></span> nie jest rekurencyjny i wobec tego
      może posiadać jedynie reguły nierekurencyjne

</li>
<li> wtórna — regułą pierwotną dla <span class="inlinecode"><span class="id" title="var">bool</span></span> jest <span class="inlinecode"><span class="id" title="var">bool_rect</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Druga z naszych reguł jest:
<ul class="doclist">
<li> zależna, gdyż definiujemy term typu zależnego <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>

</li>
<li> nierekurencyjna z tych samych powodów, co reguła pierwsza

</li>
<li> pierwotna — Coq wygenerował ją dla nas automatycznie 
</li>
</ul>

<div class="paragraph"> </div>

 W zależności od kombinacji powyższych cech reguły eliminacji mogą
    występować pod różnymi nazwami:
<ul class="doclist">
<li> reguły indukcyjne są zależne i rekurencyjne. Służą do definiowania
      funkcji, których przeciwdziedzina jest sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, a więc do
      dowodzenia zdań przez indukcję

</li>
<li> rekursory to rekurencyjne reguły eliminacji, które służą do definiowania
      funkcji, których przeciwdziedzina jest sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span> lub <span class="inlinecode"><span class="id" title="keyword">Type</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

 Nie przejmuj się natłokiem nazw ani rozróżnień. Powyższą klasyfikację
    wymyśliłem na poczekaniu i nie ma ona w praktyce żadnego znaczenia.

<div class="paragraph"> </div>

    Zauważmy, że podobnie jak nie wszystkie reguły formacji i wprowadzania
    pochodzą od typów induktywnych, tak i nie wszystkie reguły eliminacji
    od nich pochodzą. Kontrprzykładem niech będzie reguła eliminacji dla
    funkcji (niezależnych): 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;B&nbsp;:&nbsp;Type,&nbsp;f&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B,&nbsp;x&nbsp;:&nbsp;A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;x&nbsp;:&nbsp;B<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Reguła ta mówi nam, że jeżeli mamy funkcję <span class="inlinecode"><span class="id" title="var">f</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> oraz
    argument <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>, to aplikacja funkcji <span class="inlinecode"><span class="id" title="var">f</span></span> do argumentu <span class="inlinecode"><span class="id" title="var">x</span></span>
    jest typu <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

    Zauważmy też, że mimo iż reguły wprowadzania i eliminacji są w pewien
    sposób dualne, to istnieją między nimi różnice.

<div class="paragraph"> </div>

    Przede wszystkim, poza regułami wbudowanymi, obowiązuje prosta zasada:
    jeden konstruktor typu induktywnego — jedna reguła wprowadzania. Innymi
    słowy, reguły wprowadzania dla typów induktywnych pochodzą bezpośrednio
    od konstruktorów i nie możemy w żaden sposób dodać nowych. Są one w
    pewien sposób pierwotne i nie mamy nad nimi (bezpośredniej) kontroli.

<div class="paragraph"> </div>

    Jeżeli chodzi o reguły eliminacji, to są one, poza niewielką ilością
    reguł pierwotnych, w pewnym sensie wtórne —
    możemy budować je z pattern matchingu i rekursji strukturalnej i to
    właśnie te dwie ostatnie idee są w Coqu ideami pierwotnymi. Jeżeli
    chodzi o kontrolę, to możemy swobodnie dodawać nowe reguły eliminacji
    za pomocą twierdzeń lub definiując je bezpośrednio.

<div class="paragraph"> </div>

    Działanie takie jest, w przypadku nieco bardziej zaawansowanych
    twierdzeń niż dotychczas widzieliśmy, bardzo częste. Ba! Częste
    jest także tworzenie reguł eliminacji dla każdej funkcji z osobna,
    perfekcyjnie dopasowanych do kształtu jej rekursji. Jest to nawet
    bardzo wygodne, gdyż Coq potrafi automatycznie wygenerować dla nas
    takie reguły.

<div class="paragraph"> </div>

    Przykładem niestandardowej reguły może być reguła eliminacji dla
    list działająca "od tyłu": 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;P&nbsp;:&nbsp;list&nbsp;A&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;H&nbsp;:&nbsp;P&nbsp;<span class="inlinecode">[]</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;H'&nbsp;:&nbsp;forall&nbsp;(h&nbsp;:&nbsp;A)&nbsp;(t&nbsp;:&nbsp;list&nbsp;A),&nbsp;P&nbsp;t&nbsp;-&gt;&nbsp;P&nbsp;(t&nbsp;++&nbsp;<span class="inlinecode">[<span class="id" title="var">h</span>]</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-------------------------------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;l&nbsp;:&nbsp;list&nbsp;A,&nbsp;P&nbsp;l<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Póki co wydaje mi się, że udowodnienie słuszności tej reguły będzie dla
    nas za trudne. W przyszłości na pewno napiszę coś więcej na temat reguł
    eliminacji, gdyż ze względu na swój "otwarty" charakter są one z punktu
    widzenia praktyki najważniejsze.

<div class="paragraph"> </div>

    Tymczasem na otarcie łez zajmijmy się inną, niestandardową regułą dla
    list. 
<div class="paragraph"> </div>

<a name="lab469"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, że reguła dla list "co dwa" jest słuszna. Zauważ, że komenda
    <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> może służyć do podawania definicji rekurencyjnych nie tylko
    "ręcznie", ale także za pomocą taktyk.

<div class="paragraph"> </div>

    Wskazówka: użycie hipotezy indukcyjnej <span class="inlinecode"><span class="id" title="var">list_ind_2</span></span> zbyt wcześnie
    ma podobne skutki co wywołanie rekurencyjne na argumencie, który
    nie jest strukturalnie mniejszy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">EliminationRules</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">List</span>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">list_ind_2</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">H0</span> : <span class="id" title="var">P</span> []) (<span class="id" title="var">H1</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> [<span class="id" title="var">x</span>])<br/>
&nbsp;&nbsp;(<span class="id" title="var">H2</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">P</span> <span class="id" title="var">l</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">x</span> :: <span class="id" title="var">y</span> :: <span class="id" title="var">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">P</span> <span class="id" title="var">l</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab470"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisz funkcję <span class="inlinecode"><span class="id" title="tactic">apply</span></span>, odpowiadającą regule eliminacji dla funkcji
    (niezależnych). Udowodnij jej specyfikację.

<div class="paragraph"> </div>

    Uwaga: notacja "$" na oznaczenie aplikacji funkcji pochodzi z języka
    Haskell i jest tam bardzo często stosowana, gdyż pozwala zaoszczędzić
    stawiania zbędnych nawiasów. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;f $ x" := (<span class="id" title="tactic">apply</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 5).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">apply_spec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>), <span class="id" title="var">f</span> $ <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">EliminationRules</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab471"></a><h2 class="section">Reguły obliczania</h2>

<div class="paragraph"> </div>

 Poznawszy reguły wprowadzania i eliminacji możemy zadać sobie pytanie:
    jakie są między nimi związki? Jedną z odpowiedzi na to pytanie dają
    reguły obliczania, które określają, w jaki sposób reguły eliminacji
    działają na obiekty stworzone za pomocą reguł wprowadzania. Zobaczmy
    o co chodzi na przykładzie. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;B&nbsp;:&nbsp;Type,&nbsp;x&nbsp;:&nbsp;A&nbsp;|-&nbsp;e&nbsp;:&nbsp;B,&nbsp;t&nbsp;:&nbsp;A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(fun&nbsp;x&nbsp;:&nbsp;A&nbsp;=&gt;&nbsp;e)&nbsp;t&nbsp;≡&nbsp;e{x/t}<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Powyższa reguła nazywa się "redukcja beta". Mówi ona, jaki efekt ma
    aplikacja funkcji zrobionej za pomocą lambda abstrakcji do argumentu,
    przy czym aplikacja jest regułą eliminacji dla funkcji, a lambda
    abstrakcja — regułą wprowadzania.

<div class="paragraph"> </div>

    Możemy odczytać ją tak: jeżeli <span class="inlinecode"><span class="id" title="var">A</span></span> i <span class="inlinecode"><span class="id" title="var">B</span></span> są typami, zaś <span class="inlinecode"><span class="id" title="var">e</span></span> termem
    typu <span class="inlinecode"><span class="id" title="var">B</span></span>, w którym występuje zmienna wolna <span class="inlinecode"><span class="id" title="var">x</span></span> typu <span class="inlinecode"><span class="id" title="var">A</span></span>, to wyrażenie
    <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">e</span>)</span> <span class="inlinecode"><span class="id" title="var">t</span></span> redukuje się (symbol ≡) do <span class="inlinecode"><span class="id" title="var">e</span></span>, w którym w miejsce
    zmiennej <span class="inlinecode"><span class="id" title="var">x</span></span> podstawiono term <span class="inlinecode"><span class="id" title="var">t</span></span>.

<div class="paragraph"> </div>

    Zauważ, że zarówno symbol ≡ jak i notacja <span class="inlinecode"><span class="id" title="var">e</span>{<span class="id" title="var">x</span>/<span class="id" title="var">t</span>}</span> są tylko nieformalnymi
    zapisami i nie mają żadnego znaczenia w Coqu.

<div class="paragraph"> </div>

    Nie jest tak, że dla każdego typu jest tylko jedna reguła obliczania.
    Jako, że reguły obliczania pokazują związek między regułami eliminacji
    i wprowadzania, ich ilość można przybliżyć prostym wzorem:

<div class="paragraph"> </div>

    # reguł obliczania = # reguł eliminacji * # reguł wprowadzania,

<div class="paragraph"> </div>

    gdzie # to nieformalny symbol oznaczający "ilość". W Coqowej praktyce
    zazwyczaj oznacza to, że reguł obliczania jest nieskończenie wiele,
    gdyż możemy wymyślić sobie nieskończenie wiele reguł eliminacji.
    Przykładem typu, który ma więcej niż jedną regułę obliczania dla danej
    reguły eliminacji, jest <span class="inlinecode"><span class="id" title="var">bool</span></span>: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Type,&nbsp;x&nbsp;:&nbsp;P&nbsp;true,&nbsp;y&nbsp;:&nbsp;P&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;bool_rect&nbsp;P&nbsp;x&nbsp;y&nbsp;true&nbsp;≡&nbsp;x<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;Type,&nbsp;x&nbsp;:&nbsp;P&nbsp;true,&nbsp;y&nbsp;:&nbsp;P&nbsp;false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;bool_rect&nbsp;P&nbsp;x&nbsp;y&nbsp;false&nbsp;≡&nbsp;y<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">bool</span></span> ma dwie reguły wprowadzania pochodzące od dwóch konstruktorów,
    a zatem ich związki z regułą eliminacji <span class="inlinecode"><span class="id" title="var">bool_rect</span></span> będą opisywać dwie
    reguły obliczania. Pierwsza z nich mówi, że <span class="inlinecode"><span class="id" title="var">bool_rect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>
    redukuje się do <span class="inlinecode"><span class="id" title="var">x</span></span>, a druga, że <span class="inlinecode"><span class="id" title="var">bool_rect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> redukuje się do
    <span class="inlinecode"><span class="id" title="var">y</span></span>.

<div class="paragraph"> </div>

    Gdyby zastąpić w nich regułe <span class="inlinecode"><span class="id" title="var">bool_rect</span></span> przez nieco prostszą regułę, w
    której nie występują typy zależne, to można by powyższe reguły zapisać
    tak: 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;x&nbsp;:&nbsp;A,&nbsp;y&nbsp;:&nbsp;A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;true&nbsp;then&nbsp;x&nbsp;else&nbsp;y&nbsp;≡&nbsp;x<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;x&nbsp;:&nbsp;A,&nbsp;y&nbsp;:&nbsp;A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;false&nbsp;then&nbsp;x&nbsp;else&nbsp;y&nbsp;≡&nbsp;y<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Wygląda dużo bardziej znajomo, prawda?

<div class="paragraph"> </div>

    Na zakończenie wypadałoby napisać, skąd biorą się reguły obliczania. W
    nieco mniej formalnych pracach teoretycznych na temat teorii typów są
    one zazwyczaj uznawane za byty podstawowe, z których następnie wywodzi
    się reguły obliczania takich konstrukcji, jak np. <span class="inlinecode"><span class="id" title="keyword">match</span></span>.

<div class="paragraph"> </div>

    W Coqu jest na odwrót. Tak jak reguły eliminacji pochodzą od pattern
    matchingu i rekursji, tak reguły obliczania pochdzą od opisanych już
    wcześniej reguł redukcji (beta, delta, jota i zeta), a także konwersji
    alfa. 
<div class="paragraph"> </div>

<a name="lab472"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Napisz reguły obliczania dla liczb naturalnych oraz list (dla reguł
    eliminacji <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> oraz <span class="inlinecode"><span class="id" title="var">list_ind</span></span>). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab473"></a><h2 class="section">Reguły unikalności</h2>

<div class="paragraph"> </div>

 Kolejną odpowiedzią na pytanie o związki między regułami wprowadzania
    i eliminacji są reguły unikalności. Są one dualne do reguł obliczania
    i określają, w jaki sposób reguły wprowadzania działają na obiekty
    pochodzące od reguł eliminacji. Przyjrzyjmy się przykładowi. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;B&nbsp;:&nbsp;Type,&nbsp;f&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(fun&nbsp;x&nbsp;:&nbsp;A&nbsp;=&gt;&nbsp;f&nbsp;x)&nbsp;≡&nbsp;f<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Powyższa reguła unikalności dla funkcji jest nazywana "redukcją eta".
    Stwierdza ona, że funkcja stworzona za pomocą abstrakcji <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>,
    której ciałem jest aplikacja <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> jest definicyjnie równa funkcji <span class="inlinecode"><span class="id" title="var">f</span></span>.
    Regułą wprowadzania dla funkcji jest oczywiście abstrakcja, a regułą
    eliminacji — aplikacja.

<div class="paragraph"> </div>

    Reguły unikalności różnią się jednak dość mocno od reguł obliczania,
    gdyż zamiast równości definicyjnej ≡ mogą czasem używać standardowej,
    zdaniowej równości Coqa, czyli <span class="inlinecode">=</span>. Nie do końca pasuje też do nich
    stwierdzenie, że określają działanie reguł wprowadzania na reguły
    eliminacji, gdyż zamiast reguł eliminacji mogą w nich występować
    inne byty, zdefiniowane jednak za pomocą reguł eliminacji. Zobaczmy
    o co chodzi na przykładzie. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;Type,&nbsp;B&nbsp;:&nbsp;Type,&nbsp;p&nbsp;:&nbsp;A&nbsp;*&nbsp;B<br/>
&nbsp;&nbsp;&nbsp;&nbsp;--------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(fst&nbsp;p,&nbsp;snd&nbsp;p)&nbsp;=&nbsp;p<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Powyższa reguła głosi, że para, której pierwszym elementem jest pierwszy
    element pary <span class="inlinecode"><span class="id" title="var">p</span></span>, a drugim elementem — drugi element pary <span class="inlinecode"><span class="id" title="var">p</span></span>, jest w
    istocie równa parze <span class="inlinecode"><span class="id" title="var">p</span></span>. W Coqu możemy ją wyrazić (i udowodnić) tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">prod_uniq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">A</span> * <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">fst</span> <span class="id" title="var">p</span>, <span class="id" title="var">snd</span> <span class="id" title="var">p</span>) = <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Podsumowując, reguły unikalności występują w dwóch rodzajach:
<ul class="doclist">
<li> dane nam z góry, niemożliwe do wyrażenia bezpośrednio w Coqu i
      używające równości definicyjnej, jak w przypadku redukcji eta
      dla funkcji

</li>
<li> możliwe do wyrażenia i udowodnienia w Coqu, używające zwykłej
      równości, jak dla produktów i w ogólności dla typów induktywnych 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab474"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Sformułuj reguły unikalności dla funkcji zależnych (<span class="inlinecode"><span class="id" title="keyword">forall</span></span>), sum
    zależnych (<span class="inlinecode"><span class="id" title="var">sigT</span></span>) i <span class="inlinecode"><span class="id" title="var">unit</span></span> (zapisz je w notacji z poziomą kreską).
    Zdecyduj, gdzie w powyższej klasyfikacji mieszczą się te reguły.
    Jeżeli to możliwe, wyraź je i udowodnij w Coqu. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab475"></a><h1 class="section">Typy hybrydowe</h1>

<div class="paragraph"> </div>

 Ostatnim z typów istotnych z punktu widzenia silnych specyfikacji
    jest typ o wdzięcznej nazwie <span class="inlinecode"><span class="id" title="var">sumor</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">sumor</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sumor</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inleft</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">sumor</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inright</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">sumor</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
Jak sama nazwa wskazuje, <span class="inlinecode"><span class="id" title="var">sumor</span></span> jest hybrydą sumy rozłącznej <span class="inlinecode"><span class="id" title="var">sum</span></span>
    oraz dysjunkcji <span class="inlinecode"><span class="id" title="var">or</span></span>. Możemy go interpretować jako typ, którego
    elementami są elementy <span class="inlinecode"><span class="id" title="var">A</span></span> albo wymówki w stylu "nie mam elementu <span class="inlinecode"><span class="id" title="var">A</span></span>,
    ponieważ zachodzi zdanie <span class="inlinecode"><span class="id" title="var">B</span></span>". <span class="inlinecode"><span class="id" title="var">B</span></span> nie zależy od <span class="inlinecode"><span class="id" title="var">A</span></span>, a więc jest to
    zwykła suma (a nie suma zależna, czyli uogólnienie produktu). <span class="inlinecode"><span class="id" title="var">sumor</span></span>
    żyje w <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, a więc jest to specyfikacja i liczy się konkretna
    postać jego termów, a nie jedynie fakt ich istnienia. 
<div class="paragraph"> </div>

<a name="lab476"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">pred'</span></span>)</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">pred'</span></span>, która przypisuje liczbie naturalnej jej
    poprzednik. Poprzednikiem <span class="inlinecode">0</span> nie powinno być <span class="inlinecode">0</span>. Mogą przydać ci
    się typ <span class="inlinecode"><span class="id" title="var">sumor</span></span> oraz sposób definiowania za pomocą taktyk, omówiony
    w podrozdziale dotyczącym sum zależnych. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">sumor</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab477"></a><h1 class="section">Small scale reflection</h1>

</div>
<div class="code">

<br/>
</div>
